\newcommand\wgTitle{std::simd --- merge data-parallel types from the Parallelism TS 2}
\newcommand\wgName{Matthias Kretz <m.kretz@gsi.de>}
\newcommand\wgDocumentNumber{D1928R4}
\newcommand\wgGroup{LEWG}
\newcommand\wgTarget{\CC{}26}
%\newcommand\wgAcknowledgements{ }

\usepackage{mymacros}
\usepackage{wg21}
\setcounter{tocdepth}{2} % show sections and subsections in TOC
\hypersetup{bookmarksdepth=5}
\usepackage{changelog}
\usepackage{underscore}
\usepackage{comment}

\addbibresource{extra.bib}

\newcommand\simd[1][]{\type{simd#1}\xspace}
\newcommand\simdT{\type{simd<T>}\xspace}
\newcommand\valuetype{\type{value\_type}\xspace}
\newcommand\referencetype{\type{reference}\xspace}
\newcommand\whereexpression{\type{where\_expression}\xspace}
\newcommand\simdcast{\code{simd\_cast}\xspace}
\newcommand\mask[1][]{\type{simd\_mask#1}\xspace}
\newcommand\maskT{\type{simd\_mask<T>}\xspace}
\newcommand\fixedsizeN{\type{simd\_abi::fixed\_size<N>}\xspace}
\newcommand\fixedsizescoped{\type{simd\_abi::fixed\_size}\xspace}
\newcommand\fixedsize{\type{fixed\_size}\xspace}
\newcommand\wglink[1]{\href{https://wg21.link/#1}{#1}}
\DeclareRobustCommand\simdabi{\code{simd\_abi\MayBreak::\MayBreak}}

\renewcommand{\lst}[1]{Listing~\ref{#1}}
\renewcommand{\sect}[1]{Section~\ref{#1}}
\renewcommand{\ttref}[1]{Tony~Table~\ref{#1}}

\begin{document}
\selectlanguage{american}
\begin{wgTitlepage}
  After the Parallelism TS 2 was published in 2018, data-parallel types
  (\simdT) have been implemented and used.
  Now there is sufficient feedback to improve and merge Section 9 of the
  Parallelism TS 2 into the IS working draft.
\end{wgTitlepage}

\pagestyle{scrheadings}

\input{changelog}
\input{strawpolls}

\section{Introduction}
\cite{P0214R9} introduced \simdT and related types and functions into the Parallelism TS 2 Section 9.
The TS was published in 2018.
An incomplete and non-conforming (because P0214 evolved) implementation existed for the whole time P0214 progressed through the committee.
Shortly after the GCC 9 release, a complete implementation of Section 9 of the TS was made available.
Since GCC 11 a complete \code{simd} implementation of the TS is part of its standard library.

In the meantime the TS feedback progressed to a point where a merge should happen ASAP.
This paper proposes to merge only the feature-set that is present in the Parallelism TS 2.
(Note: The first revision of this paper did not propose a merge.)
If, due to feedback, any of these features require a change, then this paper (P1928) is the intended vehicle.
If a new feature is basically an addition to the wording proposed here, then it will progress in its own paper.

\subsection{Related papers}
\begin{description}
  \item[\wglink{P0350}] Before publication of the TS, SG1 approved \cite{P0350R0} which did not progress in time in LEWG to make it into the TS.
    \wglink{P0350} is moving forward independently.

  \item[\wglink{P0918}] After publication of the TS, SG1 approved \cite{P0918R2} which adds \code{shuffle}, \code{interleave}, \code{sum_to}, \code{multiply_sum_to}, and \code{saturated_simd_cast}.
    \wglink{P0918} will move forward independently.

  \item[\wglink{P1068}] R3 of the paper removed discussion/proposal of a \code{simd} based API because it was targeting \CC{}23 with the understanding of \code{simd} not being ready for \CC{}23.
    This is unfortunate as the presence of \code{simd} in the IS might lead to a considerably different assessment of the iterator/range-based API proposed in P1068.

  \item[\wglink{P0917}] The ability to write code that is generic wrt. arithmetic types and \code{simd} types is considered to be of high value (TS feedback).
    Conditional expressions via the \code{where} function were not all too well received.
    Conditional expressions via the conditional operator would provide a solution deemed perfect by those giving feedback (myself included).

  \item[draft on non-member {operator[]}] TODO

  \item[\wglink{P2600}] The fix for ADL is important to ensure the above two papers do not break existing code.

  \item[\wglink{P0543}] The paper proposing functions for saturation arithmetic expects \code{simd} overloads as soon as \code{simd} is merged to the IS.

  \item[\wglink{P0553}] The bit operations that are part of \CC{}20 expects \code{simd} overloads as soon as \code{simd} is merged to the IS.

  \item[\wglink{P2638}] Intel’s response to \wglink{P1915R0} for \code{std::simd}

  \item[\wglink{P2663}] \code{std::simd<std::complex<T>>}.

  \item[\wglink{P2664}] Permutations for \code{simd}.

  \item[\wglink{P2509}] \textcite{P2509R0} proposes a ``type trait to detect
    conversions between arithmetic-like types that always preserve the numeric
    value of the source object''. This matches the \textit{value-preserving}
    conversions the \code{simd} specification uses.
\end{description}
The papers \wglink{P0350}, \wglink{P0918}, \wglink{P2663}, \wglink{P2664}, and
the \code{simd}-based \wglink{P1068} fork currently have no shipping vehicle
and are basically blocked on this paper.

\section{Changes after TS feedback}\label{sec:changes}
\cite{P1915R0} (Expected Feedback from \code{simd} in the Parallelism TS 2) was published in 2019, asking for feedback to the TS.
I received feedback on the TS via the GitHub issue tracker, e-mails, and personal conversations.
There is also a lot of valuable feedback published in \wglink{P2638} ``Intel’s response to \wglink{P1915R0} for \code{std::simd}''.

\subsection{improve ABI tags}
Summary:
\begin{itemize}
  \item Change the default SIMD ABI tag to \simdabi\code{native<T>} instead of \simdabi\code{compatible<T>}.
  \item Change \simdabi\code{fixed_size} to not recommend implementations make it ABI compatible.
\end{itemize}

For a discussion, see \wglink{P1928R3} Section 4.1.

Follow-up open questions are discussed in \sect{sec:simplifyfixedsize} and \sect{sec:basicsimdmask}.

\subsection{Simplify/generalize casts}\label{sec:casts}

For a discussion, see \wglink{P1928R3} Section 4.2.

Summary of changes wrt. TS:
\begin{enumerate}
  \item \code{simd<T0, A0>} is convertible to \code{simd<T1, A1>} if
    \code{simd_size_v<T0, A0> == simd_size_v<T1, A1>}.

  \item \code{simd<T0, A0>} is implicitly convertible to \code{simd<T1, A1>}
    if, additionally, the conversion \code{T0} to \code{T1} is
    value-preserving.

  \item \code{simd_mask<T0, A0>} is convertible to \code{simd_mask<T1, A1>} if
    \code{simd_size_v<T0, A0> == simd_size_v<T1, A1>}.

  \item \code{simd_mask<T0, A0>} is implicitly convertible to
    \code{simd_mask<T1, A1>} if, additionally, \code{sizeof(T0) ==
    sizeof(T1)}.
    (This point is irrelevant if \sect{sec:basicsimdmask} is accepted.)

  \item \code{simd<T0, A0>} can be \code{bit_cast}ed to \code{simd<T1, A1>} if
    \code{sizeof(simd<T0, A0>) == sizeof(simd<T1, A1>)}.

  \item \code{simd_mask<T0, A0>} can be \code{bit_cast}ed to \code{simd_mask<T1, A1>} if
    \code{sizeof(simd_mask<T0, A0>) == sizeof(simd_mask<T1, A1>)}.
\end{enumerate}

\subsection{Add \code{simd_mask} generator constructor}

This constructor was added:
\begin{wgText}
\begin{itemdecl}
template<class G> simd_mask(G&& gen) noexcept;
\end{itemdecl}
\end{wgText}

For a discussion, see \wglink{P1928R3} Section 4.3.

\subsection{Default load/store flags to \code{element_aligned}}

Different to the TS, load/store flags default to \code{element_aligned}.
For a discussion, see \wglink{P1928R3} Section 4.4.

\subsection{Contiguous iterators for loads and stores}\label{sec:contiguousItLoadStore}

Different to the TS, loads and stores use \code{contiguous_iterator} instead of pointers.
For a discussion, see \wglink{P1928R3} Section 4.5.

\subsection{\code{constexpr} everything}
The merge adds \code{constexpr} to all functions.
For a discussion, see \wglink{P1928R3} Section 4.6.

\subsection{Specify \code{simd::size} as \code{integral_constant}}

Different to the TS, this paper uses a static data member \code{size} of type
\std\code{integral_constant<\MayBreak\std{}size_t, N>} in \simd and \mask.
For a discussion, see \wglink{P1928R3} Section 4.7.

\subsection{Replace \code{where} facilities}

The following load/store overloads have been added as a replacement for
\stdx\code{where_expression::copy_from} and \stdx\code{const_where_expression::copy_to}:
\begin{itemize}
  \item \code{simd::simd(contiguous_iterator, const mask_type\&, Flags = \{\})} (selected elements are copied from given range, otherwise use value-initialization)
  \item \code{simd::copy_from(contiguous_iterator, const mask_type\&, Flags = \{\})} (selected elements are copied from given range)
  \item \code{simd::copy_to(contiguous_iterator, const mask_type\&, Flags = \{\})} (selected elements are copied to given range)
  \item \code{simd_mask::simd_mask(contiguous_iterator, const mask_type\&, Flags = \{\})} (selected elements are copied from given range, otherwise use value-initialization)
  \item \code{simd_mask::copy_from(contiguous_iterator, const mask_type\&, Flags = \{\})} (selected elements are copied from given range)
  \item \code{simd_mask::copy_to(contiguous_iterator, const mask_type\&, Flags = \{\})} (selected elements are copied to given range)
\end{itemize}

The \code{reduce}, \code{hmin}, and \code{hmax} overloads with
\code{const_where_expression} argument have been replaced by overloads with
\simd and \mask arguments.

The following operators were added to \mask:
\begin{itemize}
  \item \code{simd_mask::operator simd<U, A>() const noexcept}
  \item \code{simd_mask::operator+() const noexcept}
  \item \code{simd_mask::operator-() const noexcept}
  \item \code{simd_mask::operator\~{}() const noexcept}
\end{itemize}

For a discussion, see \wglink{P1928R3} Section 4.8.

\subsection{Make use of \code{int} and \code{size_t} consistent}

Different to the TS, this paper uses \code{size_t} for
\stdx\simdabi\code{fixed_size}, \stdx\code{fixed_size_simd},
\stdx\code{fixed_size_simd_mask}, \stdx\code{resize_simd}, and
\stdx\simdabi\code{max_fixed_size}.
For a discussion, see \wglink{P1928R3} Section 4.9.

\subsection{Clean up math function overloads}
The wording that produces \code{simd} overloads misses a few cases and leaves room for ambiguity.
There is also no explicit mention of integral overloads that are supported in \code{<cmath>} (e.g. \code{std::cos(1)} calling \code{std::cos(double)}).
At the very least, \code{std::abs(simd<\textit{signed-integral}>)} should be specified.

Also, from implementation experience, ``undefined behavior'' for domain, pole,
or range error is unnecessary.
It could either be an unspecified result or even match the expected result of
the function according to Annex F in the C standard.
The latter could possibly be a recommendation, i.e. QoI.
The intent is to avoid \code{errno} altogether, while still supporting
floating-point exceptions (possibly depending on compiler flags).

This needs more work and is not reflected in the wording at this point.

%Wording idea:
%\begin{wgText}
%  \setcounter{Paras}{2}
%  \pnum
%  For each function with at least one parameter of type
%  \term{floating-point-type} other than \tcode{abs}, the implementation also
%  provides additional overloads sufficient to ensure that:
%  \begin{enumerate}
%    \item If at least one argument has a type that is a specialization of \tcode{simd}, then,
%      \begin{itemize}
%        \item if any two arguments are specializations of \tcode{simd} with
%          different width, then overload resolution does not result in a usable
%          candidate ([over.match.general]) from the overloads provided by the
%          implementation; otherwise
%        % now all simd arguments have equal width, or arguments are non-simd
%        \item every argument that is a specialization of \tcode{simd}
%      \end{itemize}
%      if every argument corresponding to a \term{floating-point-type} parameter
%      has arithmetic type or is a specialization of \tcode{simd}, then every
%      such
%      argument is effectively cast to the floating-point type with the greatest
%      floating-point conversion rank and greatest floating-point conversion
%      subrank among the types of all such arguments, where arguments of integer
%      type are considered to have the same floating-point conversion rank as
%      \tcode{double}.
%
%    \item Otherwise, if every argument corresponding to a
%      \term{floating-point-type} parameter has arithmetic type, then every such
%      argument is effectively cast to the floating-point type with the greatest
%      floating-point conversion rank and greatest floating-point conversion
%      subrank among the types of all such arguments, where arguments of integer
%      type are considered to have the same floating-point conversion rank as
%      \tcode{double}.
%      If no such floating-point type with the greatest rank and subrank exists,
%      then overload resolution does not result in a usable candidate
%      ([over.match.general]) from the overloads provided by the implementation.
%  \end{enumerate}
%\end{wgText}

\subsection{Add lvalue-qualifier to non-const subscript}\label{sec:lvalue-subscript}
The \code{operator[]} overloads of \code{simd} and \code{simd_mask} returned a
proxy reference object for non-\code{const} objects and the \code{value_type}
for \code{const} objects.
This made expressions such as \code{(x * 2)[0] = 1} well-formed.
However, assignment to temporaries can only be an error in the code (or code obfuscation).
Both \code{operator[]} overloads should be lvalue-ref qualified to make
\code{(x * 2)[0]} pick the const overload, which returns a prvalue that is not
assignable.

\subsection{Rename \code{simd_mask} reductions}
Summary:
\begin{itemize}
  \item The function \stdx\code{some_of} was removed.
  \item The function \stdx\code{popcount} was renamed to \std\code{reduce_count}.
  \item The function \stdx\code{find_first_set} was renamed to \std\code{reduce_min_index}.
  \item The function \stdx\code{find_last_set} was renamed to \std\code{reduce_max_index}.
\end{itemize}

For a discussion of this topic see \wglink{P1928R3} Section 5.2.

\subsection{Added constraints on operators and functions to match their underlying element types}

Previously some operators (e.g., \code{operator<}) and functions which relied on
some property of the element type (e.g., \tcode{min} relies on ordering)
were unconstrained. Operations which were not permitted on individual elements
were still available in the overload set for simd objects of those types.
Constraints have been added where necessary to remove such operators and
functions from the overload set where they aren't supported.

\section{Open questions}

\subsection{Alternatives to \code{hmin} and \code{hmax}}
The functions \code{hmin(simd)} and \code{hmax(simd)} are basically
specializations of \code{reduce(simd)}.
I received feedback asking for better names.

With \CC{}17, there was nothing equivalent to \code{std::plus<>} for minimum
and maximum.
Since the merge of Ranges (\CC{}20), we have \stdranges\code{min} and
\stdranges\code{max}.
The \code{reduce(simd)} specification requires the \code{binary_op} to be
callable with two \code{simd} arguments, though (split initial argument in
half, call \code{binary_op}, split again, call \code{binary_op}, \ldots until
only a scalar is left).
This doesn't work with \stdranges\code{min} (and \code{max}) because it
requires an lvalue reference as return type.
If we added another \code{operator()} to \stdranges\code{min}, then their
use with \code{reduce(simd)} would be slightly inconsistent:
\medskip\begin{lstlisting}
simd<unsigned> v = ...;
auto a = reduce(v, std::bit_and<>); // must type <>
auto b = reduce(v, std::ranges::min); // must *not* type <>
\end{lstlisting}

However, if \code{simd} will be an \code{input_range} (see \sect{sec:ranges})
then the
\stdranges\code{min(\MayBreak{}ranges\MayBreak{}::\MayBreak{}input_range
auto\&\&, ...)} overload matches and \stdranges\code{min(simd)} works out of
the box.
We could then leave it up to QoI to recognize the opportunity for a SIMD
implementation of the reduction.

Alternatively (or in addition) we could rename the TS functions to
\code{reduce_min(simd)} and \code{reduce_max(simd)}.

\subsubsection{Suggested Polls}

\wgPoll{We want to do something about \code{hmin} and \code{hmax}; i.e. the TS
status quo is not acceptable for the IS.}
{&&&&}

\wgPoll{Rename to \code{reduce_min} and \code{reduce_max}.}
{&&&&}

\wgPoll{Extend \stdranges\code{min} and \code{max} to allow prvalue return types.}
{&&&&}

\wgPoll{Remove \code{hmin} and \code{hmax} expecting \code{simd} to become a range.}
{&&&&}

\subsection{Argument order and naming of masked overloads}\label{sec:maskedOverloads}

In the TS, where-expressions made it possible to reuse existing function names
and argument orders for masked operations.
With the removal of where-expressions the mask must become a function argument.
See \tabref{tab:callsWithoutWhere} for a possible pattern to replace where-expressions.
\begin{beforeaftertable}[Parallelism TS 2 & possible replacement]{Possible replacement for where-expressions}
  \label{tab:callsWithoutWhere}
  \begin{lstlisting}
stdx::native_simd<float> v = ...;
where(v > 0, v).copy_from(ptr, stdx::element_aligned);
where(v < 0, v).copy_to(ptr, stdx::element_aligned);
float pos_sum = reduce(where(v > 0, v));
  \end{lstlisting}
  &
  \begin{lstlisting}
std::simd<float> v = ...;
v.copy_from_if(ptr, v > 0);
v.copy_to_if(ptr, v < 0);
float pos_sum = reduce_if(v, v > 0);
  \end{lstlisting}
\end{beforeaftertable}%

There are more options, of course.
E.g. possible replacements for \stdx\code{where_expression::copy_from}:
\begin{itemize}
  \item \lstinline@v.copy_from_if(v > 0, ptr)@\\
    Here the condition directly follows the word ``if'', which seems helpful.
    However:
  \item \lstinline@v.copy_from_if(ptr, v > 0)@\\
    This argument order follows precedent from algorithms, which always append
    the predicate to the list of arguments (e.g. \code{copy_if(first, last,
    d_first, pred)}).
    In addition, the argument order matches the order of words in the function
    name: ``from'' --- \code{ptr}, ``if'' --- \code{mask}.
  \item \lstinline@v.copy_from(v > 0, ptr)@
  \item \lstinline@v.copy_from(ptr, v > 0)@
  \item \lstinline@v.copy_from_where(v > 0, ptr)@
  \item \lstinline@v.copy_from_where(ptr, v > 0)@
\end{itemize}

The TS has no facility for masked load constructors.
I did not receive feedback that such a constructor is needed/wanted, so this paper will not propose one.

I propose to append \code{_if} to the masked functions and append the mask
argument (but before default arguments or additional arguments required for
masked operations, such as the \code{identity_element} in \code{reduce}).

\subsubsection{Suggested Polls}

\wgPoll{The names of masked ``overloads'' should include an \code{if} and follow the argument order proposed in \wgDocumentNumber{} \sect{sec:maskedOverloads}}
{&&&&}

%\subsection{Tuning masked loads and stores}
%
%The TS specifies masked loads and stores to prefer memory safety over performance:
%\begin{quote}{}
%  [§9.5 p9] Requires: [\ldots] the largest selected index is less than the number of values pointed to by mem.]
%
%  [§9.5 p19] Requires: [\ldots] for all selected indices i, i shall be less than the number of values pointed to by mem.
%\end{quote}
%I.e. the implementation is not allowed to read or write the memory locations that are masked off.
%Consequently,\\
%\lstinline@where(stdx::simd_mask<int>(false), v).copy_from(&*data.end(), stdx::element_aligned)@\\
%would not access any memory and the code would not invoke undefined behavior.
%However, this precludes efficient implementations on ISAs that have no native
%support for masked load and store operations.
%If a user ensures his memory allocations are always padded as necessary and
%thus expects highest performance, there is no good knob to turn to ``fast and
%faults are on you''.
%
%Such a knob could easily be provided via an additional load/store flag:\\
%\lstinline@v.copy_from_if(ptr, v > 0, std::vector_aligned | std::may_dereference_all)@.
\subsection{Converting loads \& stores consistency}\label{sec:convertingLoadsAndStores}

For the TS, we allowed pointers to any \emph{vectorizable} type as valid
arguments to \code{copy_from} and \code{copy_to}.
I.e. loads and stores can be converting operations without a clue in the code
other than the type of the pointer.
It can therefore happen that a conversion that is not value-preserving goes
unnoticed.
The broadcast and \code{simd} conversion constructurs guard against accidental
use of such conversions.

I have not received feedback that users wrote buggy because of this liberal
interface.
However, in the TS process this question was never really considered.
Therefore, I just wanted to show a suggestion for a stricter but just as
powerful interface.
\lst{lst:saferConvertingLoads} presents converting broadcast and cast
\begin{lstlisting}[numbers=left,float={hbtp},label=lst:saferConvertingLoads,caption={
    Load-store flags as opt-in to converting loads and stores
}]
float  fmem[std::simd_size_v<float>] = {};
double dmem[std::simd_size_v<float>] = {};
short  smem[std::simd_size_v<float>] = {};

std::simd<float> a = 1.; // ERROR: double -> float conversion is not value-preserving
std::simd<float> b = std::rebind_simd_t<int, std::simd<float>>(1); // ERROR:
                                                  // int -> float is not value-preserving

// TS:
stdx::simd<float> ts;
ts.copy_from(fmem, stdx::element_aligned); // OK
ts.copy_from(dmem, stdx::element_aligned); // OK
ts.copy_from(smem, stdx::element_aligned); // OK

// idea, not status quo of this paper:
std::simd<float> v;
v.copy_from(fmem); // OK
v.copy_from(dmem); // ERROR: converting load
v.copy_from(smem); // ERROR: converting load

// Option (a) - one flag only:
v.copy_from(dmem, std::simd_converting); // OK
v.copy_from(smem, std::simd_converting); // OK

// Option (b) - two flags:
v.copy_from(dmem, std::simd_safe_cvt); // ERROR: double -> float is not value-preserving
v.copy_from(dmem, std::simd_any_cvt);  // OK
v.copy_from(smem, std::simd_safe_cvt); // OK
v.copy_from(smem, std::simd_any_cvt);  // OK
\end{lstlisting}
expressions, which are ill-formed because the type conversion is not
value-preserving.
The equivalent conversions on \code{copy_from} are well-formed, though.
I believe it would be better for users to opt-in to conversions on load and
store.
There are value-preserving and non-value-preserving conversions, which could be
combined into the same opt-in or we provide a separate spelling for
value-preserving conversions (the safe kind of conversion).

If LEWG is interested, I would be thankful for naming suggestions.
I do not believe that using ``safe'' is a good term here.

%
\subsection{Integration with ranges}\label{sec:ranges}
\code{simd} itself is not a container \cite{P0851R0}.
The value of a data-parallel object is not an array of elements but rather needs to be understood as a single opaque value that happens to have means for reading and writing element values.
I.e. \code{simd<int> x = \{\};} does not start the lifetime of \type{int} objects.
This implies that \code{simd} cannot model a contiguous range.
But \code{simd} can trivially model \code{random_access_range}.
However, in order to model \code{output_range}, the iterator of every non-const
\code{simd} would have to return an \code{element_reference} on dereference.
Without the ability of \code{element_reference} to decay to the element type
(similar to how arrays decay to pointers on deduction), I would prefer to
simply make \code{simd} model only \code{random_access_range}.

If \code{simd} is a range, then \code{std::vector<std::simd<float>> data} can
be flattened trivially via \code{data | std::views::join}.
This makes the use of ``arrays of \code{simd<T>}'' easier to integrate into
existing interfaces the expect ``array of \code{T}''.

I plan to pursue adding iterators and conversions to array and from
random-access ranges, specifically \code{span} with static extent, in a
follow-up paper.
I believe it is not necessary to resolve this question before merging
\code{simd} from the TS.

\subsection{Formatting support}\label{sec:formatting}
If \code{simd} \emph{is a} range, as suggested above and to be proposed in a
follow-up paper, then \code{simd} will automatically be formatted as a range.
This seems to be a good solution unless there is a demand to format \code{simd}
objects differently from \code{random_access_range}.

\subsection{Correct place for \code{simd} in the IS?}

While \code{simd} is certainly very important for numerics and therefore fits into the “Numerics library” clause, it is also more than that.
E.g. \code{simd} can be used for vectorization of text processing.
In principle \code{simd} should be understood similar to fundamental types.
Is the “General utilities library” clause a better place?
Or rename “Concurrency support library” to “Parallelism and concurrency support library” and put it there?
Alternatively, add a new library clause?

I am seeking feedback before making a recommendation.

\subsection{\code{element_reference} is overspecified}
\code{element_reference} is spelled out in a lot of detail.
It may be better to define its requirements in a list of requirements or a table instead.

This change is not reflected in the wording, pending encouragement from WG21 (mostly LWG).

\subsection{Simplify fixed_size}\label{sec:simplifyfixedsize}
To understand the following discussion it is worth remembering that given an
element type \code{T} and SIMD width \code{N}, the ABI tag is not necessarily
distinct.
For example, given AVX-512, \code{fixed_size_simd<float, 16>} could either be
one \code{zmm} register or two \code{ymm} registers.
Orthogonally, the \code{simd_mask} type could either be stored as a bit-mask or
as a vector-mask.
Thus, we already have four reasonable choices for the ABI tag.

There are only three possible reasons why \simdabi\code{fixed_size<T, N>} should
not be an alias for \simdabi\code{deduce_t<T, N>} (or rather a rename of
\code{deduce_t}):
\begin{enumerate}
  \item We want \code{N} in \code{fixed_size_simd<T, N>} to be deducible.

  \item We want to support overloading via differently named ABI tags (i.e. if
    the user types a different name, then the actual type should be different).

  \item We want the actual type name of \simdabi\code{fixed_size<T, N>} to be
    recognizable as ``fixed size'' and not just hide behind some
    implementation-defined ABI tag.
\end{enumerate}

In the TS, \code{fixed_size_simd<T, N>} is required to be deducible.
However, after the changes we did to \code{fixed_size} and conversions, there is
no good motivation over deducing \code{fixed_size_simd<T, N>} instead of
\code{simd<T, Abi>}.
Let's just communicate that \code{simd<T, Abi>} is the one and only way to
deduce arbitrary length \code{simd} types.

In the TS, a user could write the following overload set:
\medskip\begin{lstlisting}
void f(stdx::native_simd<float>);

template <int N>
void f(stdx::fixed_size_simd<float, N>);
\end{lstlisting}
Besides \code{N} not being deducible anymore, if \code{N ==
stdx::native_simd<float>::size()}, then the overloads would clash, using the
same argument type.
However, again, after the changes we did to \code{fixed_size} and conversions,
there is probably no good reason left for declaring such an overload set.
Instead a user should write a single function template passing
\code{simd<float, Abi>}, deducing \code{Abi} and potentially constraining the
function using Concepts.

That leaves the question of diagnostics / debugging with regard to ABI tag names.
This argument can also go the other way:
By hiding the actual ABI tag used for implementing \code{fixed_size<T, N>} the
user has a harder time understanding what is going on.
So I don't think this argument has much weight.

\subsubsection{Suggested Poll}

Consequently, I propose the following poll:\\
\wgPoll{Remove \simdabi\code{fixed_size}, rename \simdabi\code{deduce_t} to
  \simdabi\code{fixed_size}, and remove (no public API) \simdabi\code{deduce}.
  Require \code{fixed_size_simd<T, simd_size_v<T>>} to be the same type as
  \code{simd<T>}. Require \code{fixed_size_simd<T, 1>} to be the same type as
  \code{simd<T, \simdabi{}scalar>}.}
{&&&&}

\subsection{Basic mask type?}\label{sec:basicsimdmask}
Now that \mask types have become interconvertible, the distinction between
\mask[<T, Abi>] and \mask[<U, Abi>] with \code{sizeof(T) == sizeof(U)} is gone.
Actually, the fact that the type is interconvertible makes it harder to use
(because it is easier to construct ambiguous overloads).

Solution: \emph{Make \mask[<T, Abi>] an alias for \code{basic_simd_mask<sizeof(T), Abi>}.}

\begin{description}
  \item[Pros]
    \begin{itemize}
      \item reduces the number of template instantiations

      \item equivalent masks can now trivially be used on mixed type simd

      \item choosing the right template parameters for \mask is still simple
        and consistent with \simd
    \end{itemize}

  \item[Cons]
    \begin{itemize}
      \item It may be surprising that \mask[<T, Abi>] and \mask[<U, Abi>] are
        not different types.
        E.g. if someone wants to distinguish an overload set (why, though?).
        This is resolved by the alternative solution below.

      \item The \code{simd_mask::simd_type} member type must be removed or
        defined to an integer type of the corresponding \code{sizeof}.
        I.e. the mapping from mask type to simd type changes or doesn't exist
        anymore.

      \item Unary minus and unary plus on \mask objects must return an integer
        simd type.\\
        (\code{-(x < 0)} with \code{x} of type \code{simd<float>} would be of
        type \code{simd<int>} instead of \code{simd<float>})

      \item \code{sizeof(T) > sizeof(long long)} needs a different rule to
        determine the \code{simd_type} member and/or the unary operator return
        types.
        (E.g. \code{sizeof(long double) == 12} on Linux 32-bit,
        \code{sizeof(long double)} == 16 on Linux 64-bit)
        Proposed solution: Define \code{simd_mask<B, Abi>::simd_type} as
        \code{simd<I, Abi>} with \code{I} the largest standard signed integer
        type where \code{sizeof(I) <= B}.
    \end{itemize}
\end{description}

Alternative: \emph{Define the class template \code{template <size_t Bytes,
class Abi> class simd_mask;} and let users deal with the difference in template
parameters.}

Note that \code{simd<T, Abi>::mask_type} exists and is basically equivalent to
an alias template parameterized on \code{T} and \code{Abi}.

\subsubsection{Suggested Polls}

\wgPoll{Respecify \code{simd_mask<T, Abi>} as alias for \code{basic_simd_mask<sizeof(T), Abi>}.}
{&&&&}

\wgPoll{Specify \mask as \code{simd_mask<Bytes, Abi>}.}
{&&&&}

\wgPoll{Define \code{simd_mask<B, Abi>::simd_type} as \code{simd<I, Abi>} with \code{I} the largest standard signed integer type where \code{sizeof(I) <= B}.}
{&&&&}

\wgPoll{Do not define a \code{simd_type} member type, but use the above rule for the return type of unary minus and unary plus.}
{&&&&}

\section{Wording: Add Section 9 of N4808 with modifications}\label{sec:wording}

The following section presents the wording to be applied against the \CC{}
working draft.

The wording still needs work:
\begin{itemize}
  \item Replace \code{where} \& \code{where_expression} wording with \code{conditional_operator} and masked overloads.
  \item Apply the new library specification style from P0788R3.
\end{itemize}

\begin{wgText}[In {[version.syn]}, add]
  \begin{codeblock}
    #define __cpp_lib_simd YYYYMML // also in <simd>
  \end{codeblock}
\end{wgText}
Adjust the placeholder value as needed so as to denote this proposal's date of adoption.

\begin{wgText}[Add a new subclause after §28.8 {[numerics.numbers]}]
  \setcounter{WGClause}{28}
  \setcounter{WGSubSection}{8}
  \lstset{%
    columns=fullflexible,
    deletedelim=**[is]{|-}{-|},
    moredelim=[is][\color{white}\fontsize{0.1pt}{0.1pt}\selectfont{}]{|-}{-|}
  }
  \input{wording}
\end{wgText}

\end{document}
% vim: sw=2 sts=2 ai et tw=0
