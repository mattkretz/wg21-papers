\def\rSec#1[#2]#3{%
  \ifcase#1\wgSubsection[subsection]{#3}{#2}
  \or\wgSubsubsection[subsubsection]{#3}{#2}
  \or\wgSubsubsubsection[paragraph]{#3}{#2}
  \or\error
\fi}

\renewcommand\foralli[1][]{for all $i$ in the range of \range{0}{#1size()}}
\renewcommand\forallmaskedi{for all selected indices $i$ of \tcode{mask}}

\newcommand\validMaskedRange[1][first]{For all selected indices $i$,
\range{#1}{#1 + $i$ + 1} is a valid range.}

\newcommand\flagsRequires[2]{
\item If the template parameter pack \tcode{Flags} contains
  \tcode{\alignedflag}, \tcode{to_address(first)} points to storage
  aligned by \tcode{simd_alignment_v<#1>}.
\item If the template parameter pack \tcode{Flags} contains
  \tcode{\overalignedflag<N>}, \tcode{to_address(first)}
  points to storage aligned by \tcode{N}.
}

\newcommand\conversionFlagsMandate[2]{
  If the template parameter pack \tcode{Flags} does not contain
  \tcode{\convertflag}, then the conversion from \tcode{#1} to
  \tcode{#2} is value-preserving.
}

\newcommand\op{\textrm{\textit{op}}}

\newcommand\ConstraintUnaryOperatorWellFormed[2][const ]{%
  \constraints \tcode{requires (#1value_type a) \{ #2; \}} is \tcode{true}.
}

\newcommand\ConstraintOperatorTWellFormed{%
  \constraints \tcode{requires (value_type a, value_type b) \{ a \op{} b; \}} is \tcode{true}.
}

\rSec0[simd]{Data-parallel types}
\rSec1[simd.general]{General}

\pnum
[simd] defines data-parallel types and operations on these types.
\begin{note}
The intent is to support acceleration through data-parallel execution resources
where available, such as SIMD registers and instructions or execution units
driven by a common instruction decoder.
%If such execution resources are unavailable, the interfaces support a
%transparent fallback to sequential execution.
\end{note}

\pnum\label{wording.vectorizable.types}%
The set of \defn{vectorizable types} comprises all standard integer types,
character types, and the types \tcode{float} and \tcode{double}
([basic.fundamental]).
In addition, \tcode{std::float16_t}, \tcode{std::float32_t}, and
\tcode{std::float64_t} are vectorizable types if defined ([basic.extended.fp]).

\pnum
The term \defn{data-parallel type} refers to all enabled specializations of
the \tcode{basic_simd} and \tcode{basic_simd_mask} class templates. A \defn{data-parallel object} is
an object of \term{data-parallel type}.

\pnum
Each specialization of \tcode{basic_simd} or \tcode{basic_simd_mask} is either enabled or disabled,
as described in \ref{simd.overview} and \ref{simd.mask.overview}.

\pnum
A data-parallel type consists of one or more elements of an underlying vectorizable type,
called the \defn{element type}.
The number of elements is a constant for each data-parallel type and called the
\defn{width} of that type.
The elements in a data-parallel type are indexed from 0 to $\textrm{width} - 1$.

\pnum
An \defn{element-wise operation} applies a specified operation to the elements of one or more
data-parallel objects. Each such application is unsequenced with respect to the others. A
\defn{unary element-wise operation} is an element-wise operation that applies a unary operation to
each element of a data-parallel object. A \defn{binary element-wise operation} is an element-wise
operation that applies a binary operation to corresponding elements of two data-parallel objects.

\pnum\label{wording.selected.indices}%
Given a \tcode{basic_simd_mask<Bytes, Abi>} object \tcode{mask}, the
\defn{selected indices} signify the integers $i$ in the range
\range{0}{mask.size()} for which \tcode{mask[$i$]} is \tcode{true}.
Given an object \tcode{data} of type \tcode{basic_simd<T, Abi>} or \tcode{basic_simd_mask<Bytes, Abi>},
the \defn{selected elements} signify the elements \tcode{data[$i$]} for all selected indices $i$.

\pnum
The conversion from an arithmetic type \tcode{U} to a vectorizable type \tcode{T} is
\defn{value-preserving} if
all possible values of \tcode{U} can be represented with type \tcode{T}.

\rSec1[simd.syn]{Header \texorpdfstring{\tcode{<simd>}}{<simd>} synopsis}

%\indexhdr{simd}
\begin{codeblock}
namespace std {
  using @\simdsizetype@ = @\seebelow@;                                  // \expos
  template <class T, class Abi> constexpr @\simdsizetype\ \simdsizev@ = @\seebelow@; // \expos

  template <class T> constexpr size_t @\maskelementsize@ = @\seebelow@; // \expos
  template <size_t Bytes> using @\integerfrom@ = @\seebelow@;            // \expos

  template <class T>
    concept @\constexprwrapperlike@ =                                 // \expos
      convertible_to<T, decltype(T::value)> &&
      equality_comparable_with<T, decltype(T::value)> &&
      bool_constant<T() == T::value>::value &&
      bool_constant<static_cast<decltype(T::value)>(T()) == T::value>::value;

  // \ref{simd.abi}, \tcode{simd} ABI tags
  template<class T> using @\nativeabi@ = @\seebelow@;                    // \expos
  template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@;    // \expos

  // \ref{simd.traits}, \tcode{simd} type traits
  template<class T, class U = typename T::value_type> struct simd_alignment;
  template<class T, class U = typename T::value_type>
    inline constexpr size_t simd_alignment_v = simd_alignment<T, U>::value;

  template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
  template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
  template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
  template<@\simdsizetype@ N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

  // \ref{simd.flags}, Load and store flags
  struct @\convertflag@; // \expos
  struct @\alignedflag@; // \expos
  template<size_t N> struct @\overalignedflag@; // \expos

  template <class... Flags> struct simd_flags;
  inline constexpr simd_flags<> simd_flag_default{};
  inline constexpr simd_flags<@\convertflag@> simd_flag_convert{};
  inline constexpr simd_flags<@\alignedflag@> simd_flag_aligned{};
  template<size_t N> requires (has_single_bit(N))
    inline constexpr simd_flags<@\overalignedflag<N>@> simd_flag_overaligned{};

  // \ref{simd.class}, Class template \tcode{basic_simd}
  template<class T, class Abi = @\nativeabi@<T>> class basic_simd;
  template<class T, @\simdsizetype@ N = @\simdsizev@<T, @\nativeabi@<T>>>
    using simd = basic_simd<T, @\deducet@<T, N>>;

  // \ref{simd.mask.class}, Class template \tcode{basic_simd_mask}
  template<size_t Bytes, class Abi = @\nativeabi@<@\integerfrom@<Bytes>>> class basic_simd_mask;
  template<class T, @\simdsizetype@ N = @\simdsizev@<T, @\nativeabi@<T>>>
    using simd_mask = basic_simd_mask<sizeof(T), @\deducet@<T, N>>;

  // \ref{simd.creation}, \tcode{basic_simd} and \tcode{basic_simd_mask} creation
  template<class V, class Abi>
    constexpr auto
      simd_split(const basic_simd<typename V::value_type, Abi>& x) noexcept;
  template<class M, class Abi>
    constexpr auto
      simd_split(const basic_simd_mask<@\maskelementsize@<M>, Abi>& x) noexcept;

  template<class T, class... Abis>
    constexpr basic_simd<T, @\deducet@<T, (basic_simd<T, Abis>::size() + ...)>>
      simd_cat(const basic_simd<T, Abis>&...) noexcept;
  template<size_t Bs, class... Abis>
    constexpr basic_simd_mask<Bs, @\deducet@<@\integerfrom@<Bs>,
                              (basic_simd_mask<Bs, Abis>::size() + ...)>>
      simd_cat(const basic_simd_mask<Bs, Abis>&...) noexcept;

  // \ref{simd.mask.reductions}, \tcode{basic_simd_mask} reductions
  template<size_t Bs, class Abi>
    constexpr bool all_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr bool any_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr bool none_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bs, Abi>&);
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bs, Abi>&);

  constexpr bool all_of(same_as<bool> auto) noexcept;
  constexpr bool any_of(same_as<bool> auto) noexcept;
  constexpr bool none_of(same_as<bool> auto) noexcept;
  constexpr @\simdsizetype@ reduce_count(same_as<bool> auto) noexcept;
  constexpr @\simdsizetype@ reduce_min_index(same_as<bool> auto);
  constexpr @\simdsizetype@ reduce_max_index(same_as<bool> auto);

  // \ref{simd.reductions}, \tcode{basic_simd} reductions
  template <class BinaryOperation, class T>
    concept @\reductionoperation@ =                                    // \expos
      requires (BinaryOperation binary_op, simd<T, 1> v) {
        { binary_op(v, v) } -> same_as<simd<T, 1>>;
      };

  template<class T, class Abi, @\reductionoperation@<T> BinaryOperation = plus<>>
    constexpr T reduce(const basic_simd<T, Abi>&, BinaryOperation = {});
  template<class T, class Abi, @\reductionoperation@<T> BinaryOperation = plus<>>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       BinaryOperation binary_op = {}, type_identity_t<T> identity_element = @\seebelow@);

  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&,
                           const typename basic_simd<T, Abi>::mask_type&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&,
                           const typename basic_simd<T, Abi>::mask_type&) noexcept;

  // \ref{simd.alg}, Algorithms
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
      minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      clamp(const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo,
            const basic_simd<T, Abi>& hi);

  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype(@\simdselect@(c, a, b));
}
\end{codeblock}

\pnum
\simdsizetype{} is an alias for a signed integer type.

\pnum
\tcode{\simdsizev<T, Abi>} denotes the width of \tcode{basic_simd<T, Abi>} if
the specialization \tcode{basic_simd<T, Abi>} is enabled, or \tcode{0} otherwise.
\begin{note}
  \tcode{\simdsizev<T, Abi>} does not require instantiation of \tcode{basic_simd<T, Abi>}.
\end{note}
\FIXME{drop the note?}

\pnum
\tcode{\maskelementsize<basic_simd_mask<Bytes, Abi>>} has the value \tcode{Bytes}.

\pnum
\tcode{\integerfrom<Bytes>} is an alias for a signed integer type \tcode{T} so that \tcode{sizeof(T)
== Bytes}.

\rSec1[simd.abi]{\tcode{simd} ABI tags}

\begin{codeblock}
template<class T> using @\nativeabi@ = @\seebelow@; // \expos
template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@; // \expos
\end{codeblock}

\pnum\label{wording.ABI.tag}
An \defn{ABI tag} is a type that indicates a choice of size and binary
representation for objects of data-parallel type.
\begin{note}
  The intent is for the size and binary representation to depend on the target
  architecture and compiler flags.
\end{note}
The ABI tag, together with a given element type, implies the width.

\pnum
\begin{note}
The ABI tag is orthogonal to selecting the machine instruction set.
The selected machine instruction set limits the usable ABI tag types, though
(see \ref{simd.overview}).
The ABI tags enable users to safely pass objects of data-parallel type between
translation unit boundaries (e.g. function calls or I/O).
\end{note}

\pnum
An implementation defines ABI tag types as necessary for the following aliases.

\pnum\label{wording.deducet}
\tcode{\deducet<T, N>} is defined if
\begin{itemize}
  \item \tcode{T} is a vectorizable type,
  \item \tcode{N} is greater than zero, and
  \item \tcode{N} is not larger than an implementation-defined maximum.
\end{itemize}
The implementation-defined maximum for \tcode{N} is not smaller than 64
and can differ depending on \tcode{T}.

\pnum
Where present, \tcode{\deducet<T, N>} names an ABI tag type that satisfies
\begin{itemize}
  \item \tcode{\simdsizev<T, \deducet<T, N>> == N}, and
  \item \tcode{basic_simd<T, \deducet<T, N>>} is enabled (see \ref{simd.overview}).
\end{itemize}

% TODO: If we really want the Abis... pack back this needs a paper to LEWG.
%       The pack allows e.g. to stay with ymm registers even when zmm is available,
%         or to implement an MMX ABI that doesn't get used unless explicitly called for.
%       Also one can imagine a target with multiple different SIMD execution facilities
%         where moving between them has a high cost and shouldn't happen without a request.
%\begin{note}
  %If multiple ABI tags can satisfy the above conditions, differences in \tcode{Abis...} can lead to different results.
%\end{note}

\INFO{I removed the paragraph saying “The type of \tcode{\deducet<T, N>} in
  translation unit 1 differs from the type of \tcode{\deducet<T, N>} in
  translation unit 2 if and only if the type of \tcode{\nativeabi<T>} in
  translation unit 1 differs from the type of \tcode{\nativeabi<T>} in
  translation unit 2.” after consulting Jens.
  He said I can't reasonably say anything about working around ODR problems in an implementation.
Implementations thus have to figure this out on their own.}

\pnum
\tcode{\nativeabi<T>} is an implementation-defined alias for an ABI tag.
\tcode{basic_simd<T, \nativeabi<T>} is an enabled specialization.
\begin{note}
The intent is to use the ABI tag producing the most efficient data-parallel
execution for the element type \tcode{T} on the currently
targeted system.
For target architectures with ISA extensions, compiler flags can change the
type of the \tcode{\nativeabi<T>} alias.
\end{note}\\
\begin{example}
  Consider a target architecture supporting the ABI tags
  \tcode{__simd128} and \tcode{__simd256}, where hardware support for
  \tcode{__simd256} exists only for floating-point types.
  The implementation therefore defines \tcode{\nativeabi<T>} as an alias for
  \begin{itemize}
    \item \tcode{__simd256} if \tcode{T} is a floating-point type, and
    \item \tcode{__simd128} otherwise.
  \end{itemize}
\end{example}

\rSec1[simd.traits]{\tcode{simd} type traits}

\begin{itemdecl}
template<class T, class U = typename T::value_type> struct simd_alignment { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{simd_alignment<T, U>} has a member \tcode{value} if and only if
\begin{itemize}
  \item \tcode{T} is a specialization of \tcode{basic_simd_mask} and \tcode{U} is \tcode{bool}, or
  \item \tcode{T} is a specialization of \tcode{basic_simd} and \tcode{U} is a vectorizable type.
\end{itemize}

\pnum
If \tcode{value} is present, the type \tcode{simd_alignment<T, U>} is a \tcode{BinaryTypeTrait} with
a base characteristic of \tcode{integral_constant<size_t, N>} for some unspecified
\tcode{N} (see \ref{simd.copy} and \ref{simd.mask.copy}). \begin{note}\tcode{value} identifies the
alignment restrictions on pointers used for (converting) loads and stores for the given type
\tcode{T} on arrays of type \tcode{U}.\end{note}

\pnum
The behavior of a program that adds specializations for \tcode{simd_alignment} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is a specialization of either \tcode{basic_simd} or
      \tcode{basic_simd_mask},
    \item \tcode{T} is a vectorizable type, and
    \item \tcode{\deducet<T, V::size()>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote an ABI tag such that \tcode{basic_simd<T,
  Abi1>::size() == V::size()}.
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T,
  Abi1>} if \tcode V is a specialization of \tcode{basic_simd} or
  \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is a specialization of
  \tcode{basic_simd_mask}.
\end{itemdescr}

\begin{itemdecl}
template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{T} denote
  \begin{itemize}
    \item \tcode{typename V::value_type} if \tcode{V} is a specialization of
      \tcode{basic_simd} or
    \item \tcode{\integerfrom<\maskelementsize<V>>} if \tcode{V} is a
      specialization of \tcode{basic_simd_mask}.
  \end{itemize}

  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is a specialization of either \tcode{basic_simd} or
      \tcode{basic_simd_mask}, and
    \item \tcode{\deducet<T, N>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote an ABI tag such that \tcode{basic_simd<T,
  Abi1>::size() == V::size()}.
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T,
  Abi1>} if \tcode V is a specialization of \tcode{basic_simd} or
  \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is a specialization of
  \tcode{basic_simd_mask}.
\end{itemdescr}

\rSec1[simd.flags]{Load and store flags}

\rSec2[simd.flags.overview]{Class template \tcode{simd_flags} overview}

\begin{codeblock}
template <class... Flags> struct simd_flags {
  // \ref{simd.flags.oper}, \tcode{simd_flags} operators
  template <class... Other>
    friend consteval auto operator|(simd_flags, simd_flags<Other...>);
};
\end{codeblock}

\pnum
\begin{note}
The class template \tcode{simd_flags} acts like an integer bit-flag for types.
\end{note}

\pnum\constraints
Every type in \tcode{Flags} is one of \tcode{\convertflag},
\tcode{\alignedflag}, or \tcode{\overalignedflag<N>}.

\rSec2[simd.flags.oper]{\tcode{simd_flags} operators}

\begin{itemdecl}
template <class... Other>
  friend consteval auto operator|(simd_flags a, simd_flags<Other...> b);
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A default-initialized object of type \tcode{simd_flags<Flags2...>} where
  every type in pack \tcode{Flags2} is present either in pack \tcode{Flags} or
  pack \tcode{Other} and every type in packs \tcode{Flags} and \tcode{Other} is
  present in \tcode{Flags2}.
  If the packs \tcode{Flags} and \tcode{Other} contain two
  different specializations \tcode{\overalignedflag<N1>} and
  \tcode{\overalignedflag<N2>}, \tcode{Flags2} is not required to contain the
  specialization \tcode{\overalignedflag<std\colcol{}min(N1, N2)>}.
\end{itemdescr}

\rSec1[simd.class]{Class template \tcode{basic_simd}}

\rSec2[simd.overview]{Class template \tcode{basic_simd} overview}

\begin{codeblock}
template<class T, class Abi> class basic_simd {
public:
  using value_type = T;
  using mask_type = basic_simd_mask<sizeof(T), Abi>;
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\simdsizev@<T, Abi>> size {};

  constexpr basic_simd() noexcept = default;

  // \ref{simd.ctor}, \tcode{basic_simd} constructors
  template<class U> constexpr basic_simd(U&& value) noexcept;
  template<class U, class UAbi>
    constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
  template<class It, class... Flags>
    constexpr explicit basic_simd(It first, simd_flags<Flags...> = {});
  template<class It, class... Flags>
    constexpr explicit basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});

  // \ref{simd.copy}, \tcode{basic_simd} copy functions
  template<class It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> f = {});
  template<class It, class... Flags>
    constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;

  // \ref{simd.subscr}, \tcode{basic_simd} subscript operators
  constexpr value_type operator[](@\simdsizetype@) const;

  // \ref{simd.unary}, \tcode{basic_simd} unary operators
  constexpr basic_simd& operator++() noexcept;
  constexpr basic_simd operator++(int) noexcept;
  constexpr basic_simd& operator--() noexcept;
  constexpr basic_simd operator--(int) noexcept;
  constexpr mask_type operator!() const noexcept;
  constexpr basic_simd operator~() const noexcept;
  constexpr basic_simd operator+() const noexcept;
  constexpr basic_simd operator-() const noexcept;

  // \ref{simd.binary}, \tcode{basic_simd} binary operators
  friend constexpr basic_simd operator+(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator-(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator*(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator/(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator%(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator&(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator|(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator^(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.cassign}, \tcode{basic_simd} compound assignment
  friend constexpr basic_simd& operator+=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator-=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator*=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator/=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator%=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator&=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator|=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator^=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator<<=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator>>=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator<<=(basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd& operator>>=(basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.comparison}, \tcode{basic_simd} compare operators
  friend constexpr mask_type operator==(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator!=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<(const basic_simd&, const basic_simd&) noexcept;

  // \ref{simd.cond}, \tcode{basic_simd} exposition-only conditional operators
  friend constexpr basic_simd @\simdselect@(
    const mask_type&, const basic_simd&, const basic_simd&) noexcept;
};
\end{codeblock}

\pnum
The specializations of class template \tcode{basic_simd} are data-parallel types.

\pnum
Every specialization of \tcode{basic_simd} is a complete type.
The types \tcode{basic_simd<T, \deducet<T, N>>} for all vectorizable
\tcode{T} and with \tcode{N} in the range of \crange{1}{64} are enabled.
It is implementation-defined whether any other \tcode{basic_simd<T, Abi>} specialization
with vectorizable \tcode{T} is enabled.
Any other specialization of \tcode{basic_simd} is disabled.

If \tcode{basic_simd<T, Abi>} is disabled, the specialization has a
deleted default constructor, deleted destructor, deleted copy constructor, and
deleted copy assignment.
In addition only the \tcode{value_type}, \tcode{abi_type}, and
\tcode{mask_type} members are present.

If \tcode{basic_simd<T, Abi>} is enabled, \tcode{basic_simd<T, Abi>} is
trivially copyable.

\pnum\recommended:
Implementations should enable explicit conversion from and to
implementation-defined types. This adds one or more of the following
declarations to class \tcode{basic_simd}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit basic_simd(const @\impdef@& init);
\end{codeblock}

\begin{example}
  Consider an implementation that supports the type \tcode{__vec4f} and the function \tcode{__vec4f
  _vec4f_addsub(__vec4f, __vec4f)} for the architecture of the execution environment.
  A user may require the use of \tcode{_vec4f_addsub} for maximum performance and thus writes:
  \begin{codeblock}
    using V = basic_simd<float, simd_abi::__simd128>;
    V addsub(V a, V b) {
      return static_cast<V>(_vec4f_addsub(static_cast<__vec4f>(a), static_cast<__vec4f>(b)));
    }
  \end{codeblock}
\end{example}


\rSec2[simd.ctor]{\tcode{basic_simd} constructors}

\begin{itemdecl}
template<class U> constexpr basic_simd(U&&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{From} denote the type \tcode{remove_cvref_t<U>}.

  \pnum\constraints
  \tcode{From} satisfies \tcode{convertible_to<value_type>}, and either
  \begin{itemize}
    \item \tcode{From} is an arithmetic type and the conversion from
      \tcode{From} to \tcode{value_type} is value-preserving
      (\ref{simd.general}), or

    \item \tcode{From} is not an arithmetic type and does not satisfy
      \tcode{\constexprwrapperlike}, or

    \item \tcode{From} satisfies \tcode{\constexprwrapperlike} (\ref{simd.syn}),
      \tcode{remove_const_t<decltype(From::value)>} is an arithmetic type, and \tcode{From::value}
      is representable by \tcode{value_type}.
  \end{itemize}

  \pnum\effects
  Initializes each element to the value of the argument after conversion to \tcode{value_type}.
\end{itemdescr}

\begin{itemdecl}
template<class U, class UAbi>
  constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, UAbi> == size()} is \tcode{true}.

  \pnum\effects
  Initializes the $i^\text{th}$ element with \tcode{static_cast<T>(x[$i$])} \foralli.

  \pnum\remarks
  %The constructor is \tcode{explicit} if
  The expression inside \tcode{explicit} evaluates to \tcode{true} if either
  \begin{itemize}
    \item the conversion from \tcode{U} to \tcode{value_type} is not
      value-preserving, or

    \item both \tcode{U} and \tcode{value_type} are integral types and the
      integer conversion rank (\iref{conv.rank}) of \tcode{U} is greater than
      the integer conversion rank of \tcode{value_type}, or

    \item both \tcode{U} and \tcode{value_type} are floating-point types and
      the floating-point conversion rank (\iref{conv.rank}) of \tcode{U} is
      greater than the floating-point conversion rank of \tcode{value_type}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{From}$_i$ denote the type
  \tcode{decltype(gen(integral_constant<\simdsizetype, $i$>()))}.

  \pnum\constraints
  \tcode{From}$_i$ satisfies \tcode{convertible_to<value_type>} \foralli.
  In addition, \foralli, if \tcode{From}$_i$ is an arithmetic type, conversion from
  \tcode{From}$_i$ to \tcode{value_type} is value-preserving.

  \pnum\effects
  Initializes the $i^\text{th}$ element with
  \tcode{static_cast<value_type>(gen(integral_constant<\simdsizetype, i>()))} \foralli.

  \pnum
    The calls to \tcode{gen} are unsequenced with respect to each other.
    Vectorization-unsafe (\iref{algorithms.parallel.defns}) standard library
    functions may not be invoked by \tcode{gen}.
    \tcode{gen} is invoked exactly once for each $i$.
\end{itemdescr}

\newcommand\SimdLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is a vectorizable type, and
    \item \tcode{It} models \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{iter_value_t<It>}{value_type}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd, iter_value_t<It>}{iter_value_t<It>}
  \end{itemize}

  \pnum\effects #2
}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr explicit basic_simd(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\range{first}{first + size()} is a valid range.}
    {Initializes the $i^\text{th}$ element with \tcode{static_cast<T>(to_address(first)[$i$])}
    \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr explicit basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Initializes the $i^\text{th}$ element with \tcode{mask[$i$] ?
      static_cast<T>(to_address(first)[$i$]) : T()}
    \foralli.}
\end{itemdescr}

\rSec2[simd.copy]{\tcode{basic_simd} copy functions}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\range{first}{first + size()} is a valid range.}
    {Replaces the elements of the \tcode{basic_simd} object such that the $i^\text{th}$ element is
    assigned with \tcode{static_cast<T>(to_address(first)[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd} object such that the $i^\text{th}$
    element is replaced with \tcode{static_cast<T>(to_address(first)[$i$])} \forallmaskedi.}
\end{itemdescr}

\newcommand\SimdStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is a vectorizable type, and
    \item \tcode{Out} models \tcode{contiguous_iterator}, and
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{value_type}{iter_value_t<Out>}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd, iter_value_t<Out>}{iter_value_t<Out>}
  \end{itemize}

  \pnum\effects #2
}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\range{first}{first + size()} is a valid range.}
    {Copies all \tcode{basic_simd} elements as if \tcode{to_address(first)[$i$] =
    static_cast<iter_value_t<Out>>(operator[]($i$))} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\validMaskedRange}
    {Copies the selected elements as if \tcode{to_address(first)[$i$] =
    static_cast<iter_value_t<Out>>(operator[]($i$))} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.subscr]{\tcode{basic_simd} subscript operator}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i >= 0 \&\& i < size()} is \tcode{true}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.unary]{\tcode{basic_simd} unary operators}

\pnum
Effects in [simd.unary] are applied as unary element-wise operations.

\begin{itemdecl}
constexpr basic_simd& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{++a}

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{a++}

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  A copy of \tcode{*this} before incrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{--a}

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{a--}

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  A copy of \tcode{*this} before decrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr mask_type operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{!a}

  \pnum\returns
  A \tcode{basic_simd_mask} object with the $i^\text{th}$ element set to \tcode{!operator[]($i$)}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{\~{}a}

  \pnum\returns
  A \tcode{basic_simd} object with the $i^\text{th}$ element set to \tcode{\~{}operator[]($i$)}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator+() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{+a}

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator-() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{-a}

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to
  \tcode{-operator[]($i$)} \foralli.
\end{itemdescr}

\rSec1[simd.nonmembers]{\tcode{basic_simd} non-member operations}

\rSec2[simd.binary]{\tcode{basic_simd} binary operators}

\begin{itemdecl}
friend constexpr basic_simd operator+(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator-(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator*(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator/(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator%(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator&(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator|(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator^(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator<<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd} object initialized with the results of applying \op{} to \tcode{lhs} and
  \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd operator<<(const basic_simd& v, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& v, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\constraints
  \tcode{requires (value_type a, \simdsizetype{} b) \{ a \op{} b; \}} is \tcode{true}.

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to the result of
  applying \op{} to \tcode{v[$i$]} and \tcode{n} \foralli.
\end{itemdescr}

\rSec2[simd.cassign]{\tcode{basic_simd} compound assignment}

\begin{itemdecl}
friend constexpr basic_simd& operator+=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator-=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator*=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator/=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator%=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator&=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator|=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator^=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator<<=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator>>=(basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as an element-wise
  operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd& operator<<=(basic_simd& lhs, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd& operator>>=(basic_simd& lhs, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\constraints
  \tcode{requires (value_type a, \simdsizetype{} b) \{ a \op{} b; \}} is \tcode{true}.

  \pnum\effects
  Equivalent to: \tcode{return operator \textit{op} (lhs, basic_simd(n));}
\end{itemdescr}

\rSec2[simd.comparison]{\tcode{basic_simd} compare operators}

\begin{itemdecl}
friend constexpr mask_type operator==(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator!=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying \op{} to \tcode{lhs} and
  \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.cond]{\tcode{basic_simd} exposition-only conditional operators}

\begin{itemdecl}
friend constexpr basic_simd
@\simdselect@(const mask_type& mask, const basic_simd& a, const basic_simd& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] :
  b[$i$]} \foralli.
\end{itemdescr}

\rSec2[simd.reductions]{\tcode{basic_simd} reductions}

\pnum
In [simd.reductions], \tcode{BinaryOperation} shall be a binary element-wise operation.

\TODO{
  \todoitem Add own section for exposition-only concept \reductionoperation?
  \todoitem Move the above paragraph into the semantic requirements.
  \todoitem Add another semantic constraint: the binary operation can be invoked with two arguments
  of type \code{basic_simd<T, Abi>}, with unspecified ABI tag \code{Abi}, returning a
  \code{basic_simd<T, Abi>}.
}

\begin{itemdecl}
template<class T, class Abi, @\reductionoperation@<T> BinaryOperation = plus<>>
  constexpr T reduce(const basic_simd<T, Abi>& x, BinaryOperation binary_op = {});
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{binary_op} does not modify \tcode{x}.

  \pnum\returns
  \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, simd<T, 1>(x[0]), $\ldots$, simd<T, 1>(x[x.size() - 1])[0]}
  (\iref{numerics.defns}).

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi, @\reductionoperation@<T> BinaryOperation = plus<>>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     BinaryOperation binary_op = {}, type_identity_t<T> identity_element = @\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \begin{itemize}
    \item \tcode{binary_op} does not modify \tcode{x}.

    \item For every \tcode{A1} that is an ABI tag type and for all finite
      values \tcode{y} representable by \tcode{T}, the results of
      \tcode{all_of(y == binary_op(basic_simd<T, A1>(identity_element),
      basic_simd<T, A1>(y)))} and \tcode{all_of(y == binary_op(basic_simd<T, A1>(y), basic_simd<T,
      A1>(identity_element)))} are \tcode{true}.
  \end{itemize}

  \pnum\returns
  If \tcode{none_of(mask)} is \tcode{true}, returns \tcode{identity_element}.
  Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, simd<T, 1>(x[$k_0$]),
  $\ldots$, simd<T, 1>(x[$k_n$]))[0]} where $k_0, \ldots, k_n$ are the selected indices of
  \tcode{mask}.

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.

  \pnum\remarks
  The default argument for \code{identity_element} is equal to
  \begin{itemize}
    \item \tcode{T()} if \code{BinaryOperation} is \code{plus<>},
    \item \tcode{T(1)} if \code{BinaryOperation} is \code{multiplies<>},
    \item \tcode{T(\~{}T())} if \code{BinaryOperation} is \code{bit_and<>},
    \item \tcode{T()} if \code{BinaryOperation} is \code{bit_or<>},
    \item \tcode{T()} if \code{BinaryOperation} is \code{bit_xor<>}, or
    \item ill-formed otherwise.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_min(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_min(
    const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)} is \tcode{true}, returns \tcode{numeric_limits<T>::max()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$i$] <
  x[$j$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_max(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$j$] < x[$i$]} is \tcode{false}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_max(
    const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)} is \tcode{true}, returns \tcode{numeric_limits<V::value_type>::lowest()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$j$] <
  x[$i$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\rSec2[simd.creation]{\tcode{basic_simd} and \tcode{basic_simd_mask} creation}

\begin{itemdecl}
template<class T, class Abi>
  constexpr auto simd_split(const basic_simd<typename T::value_type, Abi>& x) noexcept;
template<class T, class Abi>
  constexpr auto simd_split(const basic_simd_mask<@\maskelementsize@<T>, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  % probably not necessary/helpful:
  %\pnum\mandates \tcode{T::size() <= \simdsizev<V::value_type, Abi>}.

  \pnum\constraints
  \begin{itemize}
    \item For the first overload \tcode{T} is a specialization of \tcode{basic_simd}.
    \item For the second overload \tcode{T} is a specialization of \tcode{basic_simd_mask}.
  \end{itemize}

  \pnum Let $N$ be \tcode{x.size() / T::size()}.

    \pnum\returns
    \begin{itemize}
      \item If \tcode{x.size() \% T::size() == 0}, an \tcode{array<T, $N$>} with
        the $i^\text{th}$ \simd or \mask element of the $j^\text{th}$ \tcode{array}
        element initialized to the value of the element in \tcode{x} with index
        \tcode{$i$ + $j$ * T::size()}.

      \item Otherwise, a \tcode{tuple} of $N$ objects of type \tcode{T} and one
        object of type \tcode{resize_simd_t<x.size() \% T::size(), T>}.
        The $i^\text{th}$ \simd or \mask element of the $j^\text{th}$
        \tcode{tuple} element of type \tcode{T} is initialized to the value of
        the element in \tcode{x} with index \tcode{$i$ + $j$ * T::size()}.
        The $i^\text{th}$ \simd or \mask element of the \tcode{N}$^\text{th}$
        \tcode{tuple} element is initialized to the value of the element in
        \tcode{x} with index \tcode{$i$ + $N$ * T::size()}.
    \end{itemize}
  \end{itemdescr}

\begin{itemdecl}
template<class T, class... Abis>
  constexpr simd<T, (basic_simd<T, Abis>::size() + ...)>
    simd_cat(const basic_simd<T, Abis>&... xs) noexcept;
template<size_t Bytes, class... Abis>
  constexpr simd_mask<@\deducet@<@\integerfrom@<Bytes>, (basic_simd_mask<Bytes, Abis>::size() + ...)>
    simd_cat(const basic_simd_mask<Bytes, Abis>&... xs) noexcept;

\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A data-parallel object initialized with the concatenated values in the \tcode{xs} pack of
  data-parallel objects: The $i^\text{th}$ \tcode{basic_simd}/\tcode{basic_simd_mask} element of the
  $j^\text{th}$ parameter in the \tcode{xs} pack is copied to the return value's element with index
  $i$ + the sum of the width of the first $j$ parameters in the \tcode{xs} pack.
\end{itemdescr}

\rSec2[simd.alg]{Algorithms}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
  minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  A \tcode{pair} initialized with
  \begin{itemize}
    \item the result of element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli{} in
      the \tcode{first} member, and
    \item the result of element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli{} in
      the \tcode{second} member.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> clamp(
    const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo, const basic_simd<T, Abi>& hi);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\expects
  No element in \tcode{lo} shall be greater than the corresponding element in \tcode{hi}.

  \pnum\returns
  The result of element-wise application of \tcode{std::clamp(v[$i$], lo[$i$], hi[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
\end{itemdecl}

\begin{itemdescr}
    \pnum\returns As-if \tcode{c ? a : b}.
\end{itemdescr}

\begin{itemdecl}
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype(@\simdselect@(c, a, b));
\end{itemdecl}

\begin{itemdescr}
    \pnum\returns As-if \tcode{\simdselect(c, a, b)}.
\end{itemdescr}

\rSec2[simd.math]{\tcode{basic_simd} math library}

\pnum
For each set of overloaded functions within \tcode{<cmath>}, there shall be additional overloads
sufficient to ensure that if any argument corresponding to a \tcode{double} parameter has type
\tcode{basic_simd<T, Abi>}, where \tcode{is_floating_point_v<T>} is \tcode{true}, then:
\begin{itemize}
  \item All arguments corresponding to \tcode{double} parameters shall be convertible to
    \tcode{basic_simd<T, Abi>}.
  \item All arguments corresponding to \tcode{double*} parameters shall be of type
    \tcode{basic_simd<T, Abi>*}.
  \item All arguments corresponding to parameters of integral type \tcode{U} shall be convertible to
    \tcode{rebind_simd_t<U, basic_simd<T, Abi>>}.
  \item All arguments corresponding to \tcode{U*}, where \tcode{U} is integral, shall be of type
    \tcode{rebind_simd_t<U, basic_simd<T, Abi>>*}.
  \item If the corresponding return type is \tcode{double}, the return type of the additional
    overloads is \tcode{basic_simd<T, Abi>}. Otherwise, if the corresponding return type is
    \tcode{bool}, the return type of the additional overload is \tcode{basic_simd<T,
    Abi>::mask_type}. Otherwise, the return type is \tcode{rebind_simd_t<R, basic_simd<T, Abi>>},
    with \tcode{R} denoting the corresponding return type.
\end{itemize}
It is unspecified whether a call to these overloads with arguments that are all convertible to
\tcode{basic_simd<T, Abi>} but are not of type \tcode{basic_simd<T, Abi>} is well-formed.

\pnum
Each function overload produced by the above rules applies the indicated \tcode{<cmath>} function
element-wise. For the mathematical functions, the results per element only need to be approximately
equal to the application of the function which is overloaded for the element type.

\pnum
The result is unspecified if a domain, pole, or range error occurs when the input argument(s) are
applied to the indicated \tcode{<cmath>} function.
\begin{note}Implementations are encouraged to follow the C specification (especially Annex
F).\end{note}

\pnum
\FIXME{Allow \tcode{abs(basic_simd<\textrm{signed-integral}>)}.}

\pnum
If \tcode{abs} is called with an argument of type \tcode{basic_simd<X, Abi>} for which
\tcode{is_unsigned_v<X>} is \tcode{true}, the program is ill-formed.

\rSec1[simd.mask.class]{Class template \tcode{basic_simd_mask}}

\rSec2[simd.mask.overview]{Class template \tcode{basic_simd_mask} overview}

\begin{codeblock}
template<size_t Bytes, class Abi> class basic_simd_mask {
public:
  using value_type = bool;
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\simdsizev@<@\integerfrom@<Bytes>, Abi>> size {};

  constexpr basic_simd_mask() noexcept = default;

  // \ref{simd.mask.ctor}, \tcode{basic_simd_mask} constructors
  constexpr explicit basic_simd_mask(value_type) noexcept;
  template<size_t UBytes, class UAbi>
    constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
  template<class It, class... Flags>
    constexpr basic_simd_mask(It first, Flags = {});
  template<class It, class... Flags>
    constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});

  // \ref{simd.mask.copy}, \tcode{basic_simd_mask} copy functions
  template<class It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> = {});
  template<class It, class... Flags>
    constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;

  // \ref{simd.mask.subscr}, \tcode{basic_simd_mask} subscript operators
  constexpr value_type operator[](@\simdsizetype@) const;

  // \ref{simd.mask.unary}, \tcode{basic_simd_mask} unary operators
  constexpr basic_simd_mask operator!() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator+() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator-() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator~() const noexcept;

  // \ref{simd.mask.conv}, \tcode{basic_simd_mask} conversion operators
  template <class U, class A>
    constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;

  // \ref{simd.mask.binary}, \tcode{basic_simd_mask} binary operators
  friend constexpr basic_simd_mask
    operator&&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator||(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator|(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator^(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cassign}, \tcode{basic_simd_mask} compound assignment
  friend constexpr basic_simd_mask&
    operator&=(basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask&
    operator|=(basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask&
    operator^=(basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.comparison}, \tcode{basic_simd_mask} comparisons
  friend constexpr basic_simd_mask
    operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator>=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator<=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator>(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator<(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cond}, \tcode{basic_simd_mask} exposition-only conditional operators
  friend constexpr basic_simd_mask @\simdselect@(
    const basic_simd_mask&, const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask @\simdselect@(
    const basic_simd_mask&, same_as<bool> auto, same_as<bool> auto) noexcept;
  template <class T0, class T1>
    friend constexpr simd<@\seebelow@, size()>
      @\simdselect@(const basic_simd_mask&, const T0&, const T1&) noexcept;
};
\end{codeblock}

\pnum
The specializations of class template \tcode{basic_simd_mask} are data-parallel types with element
type \tcode{bool}.

\pnum
Every specialization of \tcode{basic_simd_mask} is a complete type.
The types \tcode{basic_simd_mask<sizeof(T), \deducet<T, N>>} for all vectorizable
\tcode{T} and with \tcode{N} in the range of \crange{1}{64} are enabled.
It is implementation-defined whether any other \tcode{basic_simd_mask<sizeof(T), Abi>}
specialization with vectorizable \tcode{T} is enabled.
Any other specialization of \tcode{basic_simd_mask} is disabled.

If \tcode{basic_simd_mask<Bytes, Abi>} is disabled, the specialization has a deleted
default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
In addition only the \tcode{value_type} and \tcode{abi_type} members are present.

If \tcode{basic_simd_mask<Bytes, Abi>} is enabled, \tcode{basic_simd_mask<Bytes, Abi>} is
trivially copyable.

\pnum
Implementations should enable explicit conversion from and to implementation-defined types. This
adds one or more of the following declarations to class \tcode{basic_simd_mask}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit basic_simd_mask(const @\impdef@& init);
\end{codeblock}

\rSec2[simd.mask.ctor]{\tcode{basic_simd_mask} constructors}

\begin{itemdecl}
constexpr explicit basic_simd_mask(value_type x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Initializes each element with \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
template<size_t UBytes, class UAbi>
  constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, UAbi> == size()}.

  \pnum\effects
  Initializes the $i^\text{th}$ element with \tcode{x[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{static_cast<bool>(gen(integral_constant<\simdsizetype, i>()))} is
  well-formed \foralli.

  \pnum\effects
  Initializes the $i^\text{th}$ element with
  \tcode{gen(integral_constant<\simdsizetype, i>())} \foralli.

  \pnum
  The calls to \tcode{gen} are unsequenced with respect to each other.
  Vectorization-unsafe standard library functions may not be invoked by \tcode{gen}
  (\iref{algorithms.parallel.exec}).
\end{itemdescr}

\newcommand\MaskLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is of type \tcode{bool}, and
    \item \tcode{It} models \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr basic_simd_mask(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\range{first}{first + size()} is a valid range.}
    {Initializes the $i^\text{th}$ element with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Initializes the $i^\text{th}$ element with \tcode{mask[$i$] ? first[$i$] : false} \foralli.}
\end{itemdescr}

\rSec2[simd.mask.copy]{\tcode{basic_simd_mask} copy functions}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
  {\range{first}{first + size()} is a valid range.}
  {Replaces the elements of the \tcode{basic_simd_mask} object such that the $i^\text{th}$ element
  is replaced with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd_mask} object such that the
    $i^\text{th}$ element is replaced with \tcode{first[$i$]} \forallmaskedi.}
\end{itemdescr}

\newcommand\MaskStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is of type \tcode{bool}, and
    \item \tcode{Out} models \tcode{contiguous_iterator}, and
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
    {\range{first}{first + size()} is a valid range.}
    {Copies all \tcode{basic_simd_mask} elements as if \tcode{first[$i$] = operator[]($i$)}
    \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
  {\validMaskedRange}
  {Copies the selected elements as if \tcode{first[$i$] = operator[]($i$)} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.mask.subscr]{\tcode{basic_simd_mask} subscript operator}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i >= 0 \&\& i < size()} is \tcode{true}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.mask.unary]{\tcode{basic_simd_mask} unary operators}

\begin{itemdecl}
constexpr basic_simd_mask operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The result of the element-wise application of \tcode{operator!}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator+() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator-() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  Application of the indicated unary operator to objects of type \tcode{T} is well-formed.

  \pnum\returns
  The result of applying the indicated operator to \tcode{static_cast<simd_type>(*this)}.
\end{itemdescr}

\rSec2[simd.mask.conv]{\tcode{basic_simd_mask} conversion operators}

\begin{itemdecl}
template <class U, class A>
  constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, A> == \simdsizev<T, Abi>}.

  \pnum\returns
  An object where the $i^\text{th}$ element is initialized to
  \tcode{static_cast<U>(operator[]($i$))}.
\end{itemdescr}

\rSec1[simd.mask.nonmembers]{Non-member operations}

\rSec2[simd.mask.binary]{\tcode{basic_simd_mask} binary operators}

\begin{itemdecl}
friend constexpr basic_simd_mask
  operator&&(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator||(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator& (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator| (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator^ (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator
  to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cassign]{\tcode{basic_simd_mask} compound assignment}

\begin{itemdecl}
friend constexpr basic_simd_mask&
  operator&=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask&
  operator|=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask&
  operator^=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary
  element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\rSec2[simd.mask.comparison]{\tcode{basic_simd_mask} comparisons}

\begin{itemdecl}
friend constexpr basic_simd_mask
  operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator>=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator<=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator>(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator<(const basic_simd_mask&, const basic_simd_mask&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator
  to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cond]{\tcode{basic_simd_mask} exposition-only conditional operators}

\begin{itemdecl}
friend constexpr basic_simd_mask @\simdselect@(
  const basic_simd_mask& mask, const basic_simd_mask& a, const basic_simd_mask& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$]
  : b[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd_mask
@\simdselect@(const basic_simd_mask& mask, same_as<bool> auto a, same_as<bool> auto b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T0, class T1>
  friend constexpr simd<@\seebelow@, size()>
    @\simdselect@(const basic_simd_mask& mask, const T0& a, const T1& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{U} be the common type of \tcode{T0} and \tcode{T1} without
  applying integral promotions on integral types with integer conversion rank
  less than the rank of \tcode{int}.

  \pnum\constraints
  \begin{itemize}
    \item \tcode{U} is a vectorizable type, and
    \item \tcode{sizeof(U) == Bytes}, and
    \item \tcode{T0} satisfies \tcode{convertible_to<simd<U, size()>>}, and
    \item \tcode{T1} satisfies \tcode{convertible_to<simd<U, size()>>}.
  \end{itemize}

  \pnum\returns
  A \tcode{basic_simd<U, Abi>} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a :
  b} \foralli.
\end{itemdescr}

\rSec2[simd.mask.reductions]{\tcode{basic_simd_mask} reductions}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool all_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if all boolean elements in \tcode{k} are \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool any_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if at least one boolean element in \tcode{k} is \tcode{true}, \tcode{false}
  otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool none_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if none of the one boolean elements in \tcode{k} is \tcode{true}, \tcode{false}
  otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The number of boolean elements in \tcode{k} that are \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} is \tcode{true}.

  \pnum\returns
  The lowest element index $i$ where \tcode{k[$i$]} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} is \tcode{true}.

  \pnum\returns
  The greatest element index $i$ where \tcode{k[$i$]} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
constexpr bool all_of(same_as<bool> auto) noexcept;
constexpr bool any_of(same_as<bool> auto) noexcept;
constexpr bool none_of(same_as<bool> auto) noexcept;
constexpr @\simdsizetype@ reduce_count(same_as<bool> auto x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{all_of} and \tcode{any_of} return their arguments; \tcode{none_of}
  returns the negation of its argument; \tcode{reduce_count} returns the
  integral representation of \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
constexpr @\simdsizetype@ reduce_min_index(same_as<bool> auto y);
constexpr @\simdsizetype@ reduce_max_index(same_as<bool> auto z);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  The value of the argument is \tcode{true}.

  \pnum\returns \tcode{0}.
\end{itemdescr}

% vim: tw=100
