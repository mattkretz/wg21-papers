\def\rSec#1[#2]#3{%
  \ifcase#1\wgSubsection[subsection]{#3}{#2}
  \or\wgSubsubsection[subsubsection]{#3}{#2}
  \or\wgSubsubsubsection[paragraph]{#3}{#2}
  \or\error
\fi}

\newcommand\openrange[1]{{[}\tcode{#1})}

\renewcommand\foralli[1][]{for all $i$ in the range of [\tcode{0, #1size()})}
%\renewcommand\forallmaskedi{for all selected indices $i$}

\newcommand\validMaskedRange[1][first]{For all selected indices $i$,
[\tcode{#1, #1 + $i$ + 1}) is a valid range.}

\newcommand\flagsRequires[2]{
\item If the template parameter pack \tcode{Flags} contains the type
  identifying \tcode{simd_flag_aligned}, \tcode{addressof(*first)} shall
  point to storage aligned by \tcode{simd_alignment_v<#1>}.
\item If the template parameter pack \tcode{Flags} contains the type
  identifying \tcode{simd_flag_overaligned<N>}, \tcode{addressof(*first)}
  points to storage aligned by \tcode{N}.
}

\newcommand\conversionFlagsMandate[2]{
  If the template parameter pack \tcode{Flags} does not contain the type
  identifying \tcode{simd_flag_convert}, then the conversion from \tcode{#1} to
  \tcode{#2} is value-preserving.
}

\newcommand\op{\textrm{\textit{op}}}

\newcommand\ConstraintUnaryOperatorWellFormed[2][const ]{%
  \constraints \tcode{requires (#1value_type a) \{ #2; \}} is \tcode{true}.
}

\newcommand\ConstraintOperatorTWellFormed{%
  \constraints \tcode{requires (value_type a, value_type b) \{ a \op{} b; \}} is \tcode{true}.
}

\rSec0[simd]{Data-parallel types}
\rSec1[simd.general]{General}

\pnum
[simd] defines data-parallel types and operations on these types.
\begin{note}
The intent is to support acceleration through data-parallel execution resources
where available, such as SIMD registers and instructions or execution units
driven by a common instruction decoder.
%If such execution resources are unavailable, the interfaces support a
%transparent fallback to sequential execution.
\end{note}

\pnum\label{wording.vectorizable.types}%
The set of \defn{vectorizable types} comprises all standard integer types,
character types, and the types \tcode{float} and \tcode{double}
([basic.fundamental]).
In addition, \tcode{std::float16_t}, \tcode{std::float32_t}, and
\tcode{std::float64_t} are vectorizable types if defined ([basic.extended.fp]).

\pnum
The term \defn{data-parallel type} refers to all supported (\ref{simd.overview}) specializations of the \tcode{basic_simd} and \tcode{basic_simd_mask} class templates. A \defn{data-parallel object} is an object of \term{data-parallel type}.

\pnum
A data-parallel type consists of one or more elements of an underlying vectorizable type,
called the \defn{element type}.
The number of elements is a constant for each data-parallel type and called the
\defn{width} of that type.
The elements in a data-parallel type are indexed from 0 to $\textrm{width} - 1$.

\pnum
An \defn{element-wise operation} applies a specified operation to the elements of one or more data-parallel objects. Each such application is unsequenced with respect to the others. A \defn{unary element-wise operation} is an element-wise operation that applies a unary operation to each element of a data-parallel object. A \defn{binary element-wise operation} is an element-wise operation that applies a binary operation to corresponding elements of two data-parallel objects.

\pnum\label{wording.selected.indices}%
Given a \tcode{basic_simd_mask<Bytes, Abi>} object \tcode{mask}, the
\defn{selected indices} signify the integers $i$ in the range \tcode{[0,
mask.size())} for which \tcode{mask[$i$]} is \tcode{true}.
Given an object \tcode{data} of type \tcode{basic_simd<T, Abi>} or \tcode{basic_simd_mask<Bytes, Abi>},
the \defn{selected elements} signify the elements \tcode{data[$i$]} for all selected indices $i$.

\pnum
The conversion from vectorizable type \tcode{U} to vectorizable type \tcode{T} is \defn{value-preserving} if
all possible values of \tcode{U} can be represented with type \tcode{T}.

\rSec1[simd.syn]{Header \texorpdfstring{\tcode{<simd>}}{<simd>} synopsis}

%\indexhdr{simd}
\begin{codeblock}
namespace std {
  using @\simdsizetype@ = @\seebelow@; // \expos
  template <class T, class Abi> constexpr @\simdsizetype\ \simdsizev@ = @\seebelow@; // \expos

  template <class T> constexpr size_t @\maskelementsize@ = @\seebelow@; // \expos
  template <size_t Bytes> using @\integerfrom@ = @\seebelow@; // \expos

  template <class T>
    concept @\constexprwrapperlike@ =                     // \expos
      convertible_to<T, decltype(T::value)> &&
      equality_comparable_with<T, decltype(T::value)> &&
      bool_constant<T() == T::value>::value &&
      bool_constant<static_cast<decltype(T::value)>(T()) == T::value>::value;

  // \ref{simd.abi}, \tcode{simd} ABI tags
  template<class T> using @\nativeabi@ = @\seebelow@; // \expos
  template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@; // \expos

  // \ref{simd.traits}, \tcode{simd} type traits
  template<class T, class U = typename T::value_type> struct simd_alignment;
  template<class T, class U = typename T::value_type>
    inline constexpr size_t simd_alignment_v = simd_alignment<T, U>::value;

  template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
  template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
  template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
  template<@\simdsizetype@ N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

  // \ref{simd.flags}, Load and store flags
  template <class... Flags> struct simd_flags;
  inline constexpr simd_flags<> simd_flag_default{};
  inline constexpr simd_flags<@\seebelow@> simd_flag_convert{};
  inline constexpr simd_flags<@\seebelow@> simd_flag_aligned{};
  template<size_t N> requires (has_single_bit(N))
    inline constexpr simd_flags<@\seebelow@> simd_flag_overaligned{};

  // \ref{simd.class}, Class template \tcode{basic_simd}
  template<class T, class Abi = @\nativeabi@<T>> class basic_simd;
  template<class T, @\simdsizetype@ N = basic_simd<T>::size()>
    using simd = basic_simd<T, @\deducet@<T, N>>;

  // \ref{simd.mask.class}, Class template \tcode{basic_simd_mask}
  template<size_t Bytes, class Abi = @\nativeabi@<@\integerfrom@<Bytes>>> class basic_simd_mask;
  template<class T, @\simdsizetype@ N = basic_simd<T>::size()>
    using simd_mask = basic_simd_mask<sizeof(T), @\deducet@<T, N>>;

  // \ref{simd.creation}, \tcode{basic_simd} and \tcode{basic_simd_mask} creation
  template<class V, class Abi>
    constexpr auto
      simd_split(const basic_simd<typename V::value_type, Abi>& x) noexcept;
  template<class M, class Abi>
    constexpr auto
      simd_split(const basic_simd_mask<@\maskelementsize@<M>, Abi>& x) noexcept;

  template<class T, class... Abis>
    constexpr basic_simd<T, @\deducet@<T, (basic_simd<T, Abis>::size() + ...)>>
      simd_cat(const basic_simd<T, Abis>&...) noexcept;
  template<size_t Bs, class... Abis>
    constexpr basic_simd_mask<Bs, @\deducet@<@\integerfrom@<Bs>,
                              (basic_simd_mask<Bs, Abis>::size() + ...)>>
      simd_cat(const basic_simd_mask<Bs, Abis>&...) noexcept;

  // \ref{simd.mask.reductions}, \tcode{basic_simd_mask} reductions
  template<size_t Bs, class Abi>
    constexpr bool all_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr bool any_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr bool none_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bs, Abi>&);
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bs, Abi>&);

  constexpr bool all_of(same_as<bool> auto) noexcept;
  constexpr bool any_of(same_as<bool> auto) noexcept;
  constexpr bool none_of(same_as<bool> auto) noexcept;
  constexpr @\simdsizetype@ reduce_count(same_as<bool> auto) noexcept;
  constexpr @\simdsizetype@ reduce_min_index(same_as<bool> auto);
  constexpr @\simdsizetype@ reduce_max_index(same_as<bool> auto);

  // \ref{simd.reductions}, \tcode{basic_simd} reductions
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(const basic_simd<T, Abi>&, BinaryOperation = {});
  template<class T, class Abi, class BinaryOperation>
    constexpr T reduce(const basic_simd<T, Abi>& x,
      const typename basic_simd<T, Abi>::mask_type& mask, type_identity_t<T> identity_element,
      BinaryOperation binary_op);
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x,
      const typename basic_simd<T, Abi>::mask_type& mask, plus<> binary_op = {}) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x,
      const typename basic_simd<T, Abi>::mask_type& mask, multiplies<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x,
      const typename basic_simd<T, Abi>::mask_type& mask, bit_and<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x,
      const typename basic_simd<T, Abi>::mask_type& mask, bit_or<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x,
      const typename basic_simd<T, Abi>::mask_type& mask, bit_xor<> binary_op) noexcept;

  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&,
                           const typename basic_simd<T, Abi>::mask_type&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&,
                           const typename basic_simd<T, Abi>::mask_type&) noexcept;

  // \ref{simd.alg}, Algorithms
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
      minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      clamp(const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo,
            const basic_simd<T, Abi>& hi);

  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype(@\simdselect@(c, a, b));
}
\end{codeblock}

\pnum
\simdsizetype{} is an alias for a signed integer type.

\pnum
\tcode{\simdsizev<T, Abi>} denotes the width of \tcode{basic_simd<T, Abi>}.
\begin{note}
  \tcode{\simdsizev<T, Abi>} does not require instantiation of \tcode{basic_simd<T, Abi>}.
\end{note}

\pnum
\tcode{\maskelementsize<basic_simd_mask<Bytes, Abi>>} has the value \tcode{Bytes}.

\pnum
\tcode{\integerfrom<Bytes>} is an alias for a signed integer type \tcode{T} so that \tcode{sizeof(T) == Bytes}.

\rSec1[simd.abi]{\tcode{simd} ABI tags}

\begin{codeblock}
template<class T> using @\nativeabi@ = @\seebelow@; // \expos
template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@; // \expos
\end{codeblock}

\pnum\label{wording.ABI.tag}
An \defn{ABI tag} is a type that indicates a choice of size and binary
representation for objects of data-parallel type.
\begin{note}
  The intent is for the size and binary representation to depend on the target
  architecture and compiler flags.
\end{note}
The ABI tag, together with a given element type, implies the width.

\pnum
\begin{note}
The ABI tag is orthogonal to selecting the machine instruction set.
The selected machine instruction set limits the usable ABI tag types, though
(see \ref{simd.overview}).
The ABI tags enable users to safely pass objects of data-parallel type between
translation unit boundaries (e.g. function calls or I/O).
\end{note}

\pnum
An implementation defines ABI tag types as necessary for the following aliases.

\pnum\label{wording.deducet}
\tcode{\deducet<T, N>} is defined if
\begin{itemize}
  \item \tcode{T} is a vectorizable type,
  \item \tcode{N} is greater than zero, and
  \item \tcode{N} is not larger than an implementation-defined maximum.
\end{itemize}
The implementation-defined maximum for \tcode{N} is not smaller than 64
and can differ depending on \tcode{T}.

\pnum
Where present, \tcode{\deducet<T, N>} names an ABI tag type that satisfies
\begin{itemize}
  \item \tcode{\simdsizev<T, \deducet<T, N>> == N}, and
  \item \tcode{basic_simd<T, \deducet<T, N>>} is supported (see \ref{simd.overview}).
\end{itemize}

% TODO: If we really want the Abis... pack back this needs a paper to LEWG.
%       The pack allows e.g. to stay with ymm registers even when zmm is available,
%         or to implement an MMX ABI that doesn't get used unless explicitly called for.
%       Also one can imagine a target with multiple different SIMD execution facilities
%         where moving between them has a high cost and shouldn't happen without a request.
%\begin{note}
  %If multiple ABI tags can satisfy the above conditions, differences in \tcode{Abis...} can lead to different results.
%\end{note}

\INFO{I removed the paragraph saying “The type of \tcode{\deducet<T, N>} in
  translation unit 1 differs from the type of \tcode{\deducet<T, N>} in
  translation unit 2 if and only if the type of \tcode{\nativeabi<T>} in
  translation unit 1 differs from the type of \tcode{\nativeabi<T>} in
  translation unit 2.” after consulting Jens.
  He said I can't reasonably say anything about working around ODR problems in an implementation.
Implementations thus have to figure this out on their own.}

\pnum
\tcode{\nativeabi<T>} is an implementation-defined alias for an ABI tag.
\begin{note}
The intent is to use the ABI tag producing the most efficient data-parallel
execution for the element type \tcode{T} that is supported on the currently
targeted system.
For target architectures with ISA extensions, compiler flags can change the
type of the \tcode{\nativeabi<T>} alias.
\end{note}\\
\begin{example}
  Consider a target architecture supporting the ABI tags
  \tcode{__simd128} and \tcode{__simd256}, where hardware support for
  \tcode{__simd256} exists only for floating-point types.
  The implementation therefore defines \tcode{\nativeabi<T>} as an alias for
  \begin{itemize}
    \item \tcode{__simd256} if \tcode{T} is a floating-point type, and
    \item \tcode{__simd128} otherwise.
  \end{itemize}
\end{example}

\rSec1[simd.traits]{\tcode{simd} type traits}

\begin{itemdecl}
template<class T, class U = typename T::value_type> struct simd_alignment { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{simd_alignment<T, U>} has a member \tcode{value} if and only if
\begin{itemize}
  \item \tcode{T} is a specialization of \tcode{basic_simd_mask} and \tcode{U} is \tcode{bool}, or
  \item \tcode{T} is a specialization of \tcode{basic_simd} and \tcode{U} is a vectorizable type.
\end{itemize}

\pnum
If \tcode{value} is present, the type \tcode{simd_alignment<T, U>} is a \tcode{BinaryTypeTrait} with a base characteristic of \tcode{integral_constant<size_t, N>} for some implementation-defined \tcode{N} (see \ref{simd.copy} and \ref{simd.mask.copy}). \begin{note}\tcode{value} identifies the alignment restrictions on pointers used for (converting) loads and stores for the give type \tcode{T} on arrays of type \tcode{U}.\end{note}

\pnum
The behavior of a program that adds specializations for \tcode{simd_alignment} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is a specialization of either \tcode{basic_simd} or
      \tcode{basic_simd_mask},
    \item \tcode{T} is a vectorizable type, and
    \item \tcode{\deducet<T, V::size()>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote an ABI tag such that \tcode{basic_simd<T,
  Abi1>::size() == V::size()}.
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T,
  Abi1>} if \tcode V is a specialization of \tcode{basic_simd} or
  \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is a specialization of
  \tcode{basic_simd_mask}.
\end{itemdescr}

\begin{itemdecl}
template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{T} denote
  \begin{itemize}
    \item \tcode{typename V::value_type} if \tcode{V} is a specialization of
      \tcode{basic_simd} or
    \item \tcode{\integerfrom<\maskelementsize<V>>} if \tcode{V} is a
      specialization of \tcode{basic_simd_mask}.
  \end{itemize}

  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is a specialization of either \tcode{basic_simd} or
      \tcode{basic_simd_mask}, and
    \item \tcode{\deducet<T, N>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote an ABI tag such that \tcode{basic_simd<T,
  Abi1>::size() == V::size()}.
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T,
  Abi1>} if \tcode V is a specialization of \tcode{basic_simd} or
  \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is a specialization of
  \tcode{basic_simd_mask}.
\end{itemdescr}

\rSec1[simd.flags]{Load and store flags}

\begin{itemdecl}
inline constexpr simd_flags<@\seebelow@> simd_flag_convert{};
inline constexpr simd_flags<@\seebelow@> simd_flag_aligned{};
template<size_t N> requires (has_single_bit(N))
  inline constexpr simd_flags<@\seebelow@> simd_flag_overaligned{};
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The template arguments to \tcode{simd_flags} are unspecified types used
  by the implementation to identify the different load and store flags.
\end{itemdescr}

\rSec2[simd.flags.overview]{Class template \tcode{simd_flags} overview}

\begin{codeblock}
template <class... Flags> struct simd_flags {
  // \ref{simd.flags.oper}, \tcode{simd_flags} operators
  template <class... Other>
    friend consteval auto operator|(simd_flags, simd_flags<Other...>);
};
\end{codeblock}

\pnum
\begin{note}
The class template \tcode{simd_flags} acts like a integer bit-flag for types.
\end{note}

\pnum\constraints
Every type in \code{Flags} is a valid template argument to one of
\code{simd_flag_convert}, \tcode{simd_flag_aligned}, or
\tcode{simd_flag_overaligned}.

\rSec2[simd.flags.oper]{\tcode{simd_flags} operators}

\begin{itemdecl}
template <class... Other>
  friend consteval auto operator|(simd_flags a, simd_flags<Other...> b);
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A specialization of \tcode{simd_flags} identifying all load and
  store flags identified either by \tcode{a} or \tcode{b}.
\end{itemdescr}

\rSec1[simd.class]{Class template \tcode{basic_simd}}

\rSec2[simd.overview]{Class template \tcode{basic_simd} overview}

\begin{codeblock}
template<class T, class Abi> class basic_simd {
public:
  using value_type = T;
  @\wgRem{using reference = \mbox{\seebelow};}@
  using mask_type = basic_simd_mask<sizeof(T), Abi>;
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\simdsizev@<T, Abi>> size {};

  constexpr basic_simd() noexcept = default;

  // \ref{simd.ctor}, \tcode{basic_simd} constructors
  template<class U> constexpr basic_simd(U&& value) noexcept;
  template<class U, class UAbi>
    constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
  template<class It, class... Flags>
    constexpr explicit basic_simd(It first, simd_flags<Flags...> = {});
  template<class It, class... Flags>
    constexpr explicit basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});

  // \ref{simd.copy}, \tcode{basic_simd} copy functions
  template<class It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> f = {});
  template<class It, class... Flags>
    constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;

  // \ref{simd.subscr}, \tcode{basic_simd} subscript operators
  @\wgRem{constexpr reference operator[](\mbox{\simdsizetype}) \&;}@
  constexpr value_type operator[](@\simdsizetype@) const@\wgRem{\&}@;

  // \ref{simd.unary}, \tcode{basic_simd} unary operators
  constexpr basic_simd& operator++() noexcept;
  constexpr basic_simd operator++(int) noexcept;
  constexpr basic_simd& operator--() noexcept;
  constexpr basic_simd operator--(int) noexcept;
  constexpr mask_type operator!() const noexcept;
  constexpr basic_simd operator~() const noexcept;
  constexpr basic_simd operator+() const noexcept;
  constexpr basic_simd operator-() const noexcept;

  // \ref{simd.binary}, \tcode{basic_simd} binary operators
  friend constexpr basic_simd operator+(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator-(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator*(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator/(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator%(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator&(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator|(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator^(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.cassign}, \tcode{basic_simd} compound assignment
  friend constexpr basic_simd& operator+=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator-=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator*=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator/=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator%=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator&=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator|=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator^=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator<<=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator>>=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator<<=(basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd& operator>>=(basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.comparison}, \tcode{basic_simd} compare operators
  friend constexpr mask_type operator==(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator!=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<(const basic_simd&, const basic_simd&) noexcept;

  // \ref{simd.cond}, \tcode{basic_simd} conditional operators
  friend constexpr basic_simd @\simdselect@(
    const mask_type&, const basic_simd&, const basic_simd&) noexcept;
};
\end{codeblock}

\pnum
The specializations of class template \tcode{basic_simd} are data-parallel types.

\pnum
Every specialization of \tcode{basic_simd} is a complete type.
The types \tcode{basic_simd<T, \deducet<T, N>>} for all vectorizable
\tcode{T} and with \tcode{N} in the range of \tcode{[1, 64]} are \defn{supported}.
It is \impdef\ whether any other \tcode{basic_simd<T, Abi>} specializations
with vectorizable \tcode{T} are supported.

\begin{note}
  The intent is for implementations to determine on the basis of the currently
  targeted system, whether \tcode{basic_simd<T, Abi>} is supported.
\end{note}
\FIXME{drop the note?}

If \tcode{basic_simd<T, Abi>} is not supported, the specialization has a
deleted default constructor, deleted destructor, deleted copy constructor, and
deleted copy assignment.
In addition only the \tcode{value_type}, \tcode{abi_type}, and
\tcode{mask_type} members are present.

If \tcode{basic_simd<T, Abi>} is supported, \tcode{basic_simd<T, Abi>} is
trivially copyable.

\pnum
Implementations are encouraged to enable explicit conversion from and to
implementation-defined types. This adds one or more of the following
declarations to class \tcode{basic_simd}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit basic_simd(const @\impdef@& init);
\end{codeblock}

\begin{example}
  Consider an implementation that supports the type \tcode{__vec4f} and the function \tcode{__vec4f _vec4f_addsub(__vec4f, __vec4f)} for the currently targeted system.
  A user may require the use of \tcode{_vec4f_addsub} for maximum performance and thus writes:
  \begin{codeblock}
    using V = basic_simd<float, simd_abi::__simd128>;
    V addsub(V a, V b) {
      return static_cast<V>(_vec4f_addsub(static_cast<__vec4f>(a), static_cast<__vec4f>(b)));
    }
  \end{codeblock}
\end{example}

\begin{wgBRem}
\rSec2[simd.reference]{\texorpdfstring{\wgRem{Element references}}{Element references}}

\pnum
\wgRem{A \tcode{reference} is an object that refers to an element in a
  \tcode{basic_simd} or \tcode{basic_simd_mask} object.
  \tcode{reference::value_type} is the same type as \tcode{simd::value_type} or
\tcode{simd_mask::value_type}, respectively.}

\pnum
\wgRem{Class \tcode{reference} is for exposition only. An implementation is permitted to provide equivalent functionality without providing a class with this name.}

\begingroup\noindent\ttfamily
\st{class reference // \mbox{\expos}\\
\{\\
public:\\
\ \ reference() = delete;\\
\ \ reference(const reference\&) = delete;\\
\\
\ \ constexpr operator value_type() const noexcept;\\
\\
\ \ template<class U> constexpr reference operator=(U\&\& x) \&\& noexcept;\\
\\
\ \ template<class U> constexpr reference operator+=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator-=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator*=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator/=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator\%=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator|=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator\&=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator\^=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator<<=(U\&\& x) \&\& noexcept;\\
\ \ template<class U> constexpr reference operator>>=(U\&\& x) \&\& noexcept;\\
\\
\ \ constexpr reference operator++() \&\& noexcept;\\
\ \ constexpr value_type operator++(int) \&\& noexcept;\\
\ \ constexpr reference operator--() \&\& noexcept;\\
\ \ constexpr value_type operator--(int) \&\& noexcept;\\
\\
\ \ friend constexpr void swap(reference\&\& a, reference\&\& b) noexcept;\\
\ \ friend constexpr void swap(value_type\& a, reference\&\& b) noexcept;\\
\ \ friend constexpr void swap(reference\&\& a, value_type\& b) noexcept;\\
\};}
\endgroup

\begin{itemdecl}
@\wgRem{constexpr operator value_type() const noexcept;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\returns
  The value of the element referred to by \tcode{*this}.}
\end{itemdescr}

\begin{itemdecl}
@\wgRem{template<class U> constexpr reference operator=(U\&\& x) \&\& noexcept;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\constraints
  \tcode{declval<value_type\&>() = std::forward<U>(x)} is well-formed.}

  \pnum\wgRem{\effects
  Replaces the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask} with \tcode{static_cast<value_type>(std\colcol{}forward<U>(x))}.}

  \pnum\wgRem{\returns A copy of \tcode{*this}.}
\end{itemdescr}

\begin{itemdecl}
@\wgRem{template<class U> constexpr reference operator+=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator-=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator*=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator/=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator\%=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator|=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator\&=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator\^=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator<<=(U\&\& x) \&\& noexcept;}@
@\wgRem{template<class U> constexpr reference operator>>=(U\&\& x) \&\& noexcept;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\constraints
  \tcode{declval<value_type\&>() @= std\colcol{}forward<U>(x)} (where \tcode{@=} denotes the indicated compound assignment operator) is well-formed.}

  \pnum\wgRem{\effects
  Applies the indicated compound operator to the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask} and \tcode{std\colcol{}forward<U>(x)}.}

  \pnum\wgRem{\returns
  A copy of \tcode{*this}.}
\end{itemdescr}

\begin{itemdecl}
@\wgRem{constexpr reference operator++() \&\& noexcept;}@
@\wgRem{constexpr reference operator--() \&\& noexcept;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\constraints
  The indicated operator can be applied to objects of type \tcode{value_type}.}

  \pnum\wgRem{\effects
  Applies the indicated operator to the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask}.}

  \pnum\wgRem{\returns
  A copy of \tcode{*this}.}
\end{itemdescr}

\begin{itemdecl}
@\wgRem{constexpr value_type operator++(int) \&\& noexcept;}@
@\wgRem{constexpr value_type operator--(int) \&\& noexcept;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\remarks
  The indicated operator can be applied to objects of type \tcode{value_type}.}

  \pnum\wgRem{\effects
  Applies the indicated operator to the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask}.}

  \pnum\wgRem{\returns
  A copy of the referred to element before applying the indicated operator.}
\end{itemdescr}

\begin{itemdecl}
@\wgRem{friend constexpr void swap(reference\&\& a, reference\&\& b) noexcept;}@
@\wgRem{friend constexpr void swap(value_type\& a, reference\&\& b) noexcept;}@
@\wgRem{friend constexpr void swap(reference\&\& a, value_type\& b) noexcept;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\effects
  Exchanges the values \tcode{a} and \tcode{b} refer to.}
\end{itemdescr}
\end{wgBRem}

\rSec2[simd.ctor]{\tcode{basic_simd} constructors}

\begin{itemdecl}
template<class U> constexpr basic_simd(U&&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{From} denote the type \code{remove_cvref_t<U>}.

  \pnum\constraints
  \tcode{From} satisfies \tcode{convertible_to<value_type>}, and either
  \begin{itemize}
    \item \tcode{From} satisfies \tcode{\constexprwrapperlike} (\ref{simd.syn})
      and the actual value of \tcode{From::value} after conversion to
      \tcode{value_type} will fit into \tcode{value_type} and will produce the
      original value when converted back to \tcode{decltype(From::value)}, or

    \item \tcode{From} is a vectorizable type and the conversion from
      \tcode{From} to \tcode{value_type} is value-preserving
      (\ref{simd.general}), or

    \item \tcode{From} is not an arithmetic type and does not satisfy
      \tcode{\constexprwrapperlike}.
  \end{itemize}

  \pnum\effects
  Initializes each element to the value of the argument after conversion to \tcode{value_type}.
\end{itemdescr}

\begin{itemdecl}
template<class U, class UAbi>
  constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, UAbi> == size()} is \tcode{true}.

  \pnum\effects
  Initializes the $i^\text{th}$ element with \tcode{static_cast<T>(x[$i$])} \foralli.

  \pnum\remarks
  %The constructor is \tcode{explicit} if
  The expression inside \code{explicit} evaluates to \code{true} if either
  \begin{itemize}
    \item the conversion from \tcode{U} to \tcode{value_type} is not
      value-preserving, or

    \item both \tcode{U} and \tcode{value_type} are integral types and the
      integer conversion rank (\iref{conv.rank}) of \tcode{U} is greater than
      the integer conversion rank of \tcode{value_type}, or

    \item both \tcode{U} and \tcode{value_type} are floating-point types and
      the floating-point conversion rank (\iref{conv.rank}) of \tcode{U} is
      greater than the floating-point conversion rank of \tcode{value_type}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{basic_simd(gen(integral_constant<\simdsizetype, $i$>()))} is well-formed
  and the return type of \tcode{gen(integral_constant<\simdsizetype, $i$>())}
  satisfies \tcode{convertible_to<value_type>} \foralli.

  \pnum\effects
  Initializes the $i^\text{th}$ element with
  \tcode{gen(integral_constant<\simdsizetype, i>())} \foralli.

  \pnum
    The calls to \tcode{gen} are unsequenced with respect to each other.
    Vectorization-unsafe (\iref{algorithms.parallel.defns}) standard library
    functions may not be invoked by \tcode{gen}.
    \tcode{gen} is invoked exactly once for each $i$.
\end{itemdescr}

\newcommand\SimdLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is a vectorizable type, and
    \item \tcode{It} models \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{iter_value_t<It>}{value_type}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd, iter_value_t<It>}{iter_value_t<It>}
  \end{itemize}

  \pnum\effects #2
}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr explicit basic_simd(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\openrange{first, first + size()} is a valid range.}
    {Initializes the $i^\text{th}$ element with \tcode{static_cast<T>(first[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr explicit basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Initializes the $i^\text{th}$ element with \tcode{mask[$i$] ? static_cast<T>(first[$i$]) : T()} \foralli.}
\end{itemdescr}

\rSec2[simd.copy]{\tcode{basic_simd} copy functions}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\openrange{first, first + size()} is a valid range.}
    {Replaces the elements of the \tcode{basic_simd} object such that the $i^\text{th}$ element is assigned with \tcode{static_cast<T>(first[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd} object such that the $i^\text{th}$ element is replaced with \tcode{static_cast<T>(first[$i$])} \forallmaskedi.}
\end{itemdescr}

\newcommand\SimdStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is a vectorizable type, and
    \item \tcode{Out} models \tcode{contiguous_iterator}, and
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{value_type}{iter_value_t<Out>}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd, iter_value_t<Out>}{iter_value_t<Out>}
  \end{itemize}

  \pnum\effects #2
}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\openrange{first, first + size()} is a valid range.}
    {Copies all \tcode{basic_simd} elements as if \tcode{first[$i$] = static_cast<iter_value_t<Out>>(operator[]($i$))} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\validMaskedRange}
    {Copies the selected elements as if \tcode{first[$i$] = static_cast<iter_value_t<Out>>(operator[]($i$))} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.subscr]{\tcode{basic_simd} subscript operator\texorpdfstring{\wgRem{s}}{s}}

\begin{wgBRem}
\begin{itemdecl}
@\wgRem{constexpr reference operator[](\mbox{\simdsizetype} i) \&;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\expects
  \tcode{i < size()}.}

  \pnum\wgRem{\returns
  A \tcode{reference} (see \mbox{\ref{simd.reference}}) referring to the $i^\text{th}$ element.}

  \pnum\wgRem{\throws Nothing.}
\end{itemdescr}
\end{wgBRem}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const@\wgRem{\&}@;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i >= 0 \&\& i < size()} is \tcode{true}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.unary]{\tcode{basic_simd} unary operators}

\pnum
Effects in [simd.unary] are applied as unary element-wise operations.

\begin{itemdecl}
constexpr basic_simd& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{++a}

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{a++}

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  A copy of \tcode{*this} before incrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{--a}

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{a--}

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  A copy of \tcode{*this} before decrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr mask_type operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{!a}

  \pnum\returns
  A \tcode{basic_simd_mask} object with the $i^\text{th}$ element set to \tcode{!operator[]($i$)} \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{\~{}a}

  \pnum\returns
  A \tcode{basic_simd} object where each bit is the inverse of the corresponding bit in \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator+() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{+a}

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator-() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{-a}

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to \tcode{-operator[]($i$)} \foralli.
\end{itemdescr}

\rSec1[simd.nonmembers]{\tcode{basic_simd} non-member operations}

\rSec2[simd.binary]{\tcode{basic_simd} binary operators}

\begin{itemdecl}
friend constexpr basic_simd operator+(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator-(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator*(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator/(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator%(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator&(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator|(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator^(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator<<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd operator<<(const basic_simd& v, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& v, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to the result of applying the indicated operator to \tcode{v[$i$]} and \tcode{n} \foralli.
\end{itemdescr}

\rSec2[simd.cassign]{\tcode{basic_simd} compound assignment}

\begin{itemdecl}
friend constexpr basic_simd& operator+=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator-=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator*=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator/=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator%=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator&=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator|=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator^=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator<<=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator>>=(basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as an element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd& operator<<=(basic_simd& lhs, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd& operator>>=(basic_simd& lhs, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  Equivalent to: \tcode{return operator \textit{op} (lhs, basic_simd(n));}
\end{itemdescr}

\rSec2[simd.comparison]{\tcode{basic_simd} compare operators}

\begin{itemdecl}
friend constexpr mask_type operator==(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator!=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.cond]{\tcode{basic_simd} conditional operators}

\begin{itemdecl}
friend constexpr basic_simd
@\simdselect@(const mask_type& mask, const basic_simd& a, const basic_simd& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] : b[$i$]} \foralli.
\end{itemdescr}

\rSec2[simd.reductions]{\tcode{basic_simd} reductions}

\pnum
In [simd.reductions], \tcode{BinaryOperation} shall be a binary element-wise operation.

\INFO{
  In principle, reductions over signed integral \code{T} have a precondition.
  It could actually be nice to call this out here, and implement a precondition check in simd reductions.
}

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation = plus<>>
  constexpr T reduce(const basic_simd<T, Abi>& x, BinaryOperation binary_op = {});
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{BinaryOperation} satisfies \tcode{invocable<simd<T, 1>, simd<T, 1>>}.

  \pnum\mandates
  \tcode{binary_op} can be invoked with two arguments of type
  \tcode{basic_simd<T, A1>} returning \tcode{basic_simd<T, A1>} for every
  \tcode{A1} that is an ABI tag type.

  \pnum\expects
  \tcode{BinaryOperation} does not modify \tcode{x}.

  \pnum\returns
  \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, simd<T, 1>(x[$i$]), ...)[0]} \foralli{} (\iref{numerics.defns}).

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     type_identity_t<T> identity_element, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{BinaryOperation} satisfies \tcode{invocable<simd<T, 1>, simd<T, 1>>}.

  \pnum\mandates
  \tcode{binary_op} can be invoked with two arguments of type \tcode{basic_simd<T, A1>} returning \tcode{basic_simd<T, A1>} for every \tcode{A1} that is an ABI tag type.

  \pnum\expects
  \begin{itemize}
    \item \tcode{BinaryOperation} does not modify \tcode{x}.

    \item For every \tcode{A1} that is an ABI tag type and for all finite
      values \tcode{y} representable by \tcode{T}, the results of
      \tcode{all_of(y == binary_op(basic_simd<T, A1>(identity_element),
      basic_simd<T, A1>(y)))} and \tcode{all_of(basic_simd<T, A1>(y) ==
      binary_op(y, basic_simd<T, A1>(identity_element)))} are \tcode{true}.
  \end{itemize}

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{identity_element}.
  Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, simd<T, 1>(x[$i$]), ...)[0]} \forallmaskedi.

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     plus<> binary_op = {}) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     multiplies<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  If \tcode{none_of(x)}, returns \tcode{1}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     bit_and<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{is_integral_v<T>} is \tcode{true}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{\~{}T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     bit_or<> binary_op) noexcept;
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     bit_xor<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{is_integral_v<T>} is \tcode{true}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_min(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_min(
    const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{numeric_limits<T>::max()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_max(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$j$] < x[$i$]} is \tcode{false} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_max(
    const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{numeric_limits<V::value_type>::lowest()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$j$] < x[$i$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\rSec2[simd.creation]{\tcode{basic_simd} and \tcode{basic_simd_mask} creation}

\begin{itemdecl}
template<class T, class Abi>
  constexpr auto simd_split(const basic_simd<typename T::value_type, Abi>& x) noexcept;
template<class T, class Abi>
  constexpr auto simd_split(const basic_simd_mask<@\maskelementsize@<T>, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  % probably not necessary/helpful:
  %\pnum\mandates \tcode{T::size() <= \simdsizev<V::value_type, Abi>}.

  \pnum\constraints
  \begin{itemize}
    \item For the first overload \tcode{T} is a specialization of \tcode{basic_simd}.
    \item For the second overload \tcode{T} is a specialization of \tcode{basic_simd_mask}.
  \end{itemize}

  \pnum Let $N$ be \tcode{x.size() / T::size()}.

    \pnum\returns
    \begin{itemize}
      \item If \tcode{x.size() \% T::size() == 0}, an \tcode{array<T, $N$>} with
        the $i^\text{th}$ \simd or \mask element of the $j^\text{th}$ \tcode{array}
        element initialized to the value of the element in \tcode{x} with index
        \tcode{$i$ + $j$ * T::size()}.

      \item Otherwise, a \tcode{tuple} of $N$ objects of type \tcode{T} and one
        object of type \tcode{resize_simd_t<x.size() \% T::size(), T>}.
        The $i^\text{th}$ \simd or \mask element of the $j^\text{th}$
        \tcode{tuple} element of type \tcode{T} is initialized to the value of
        the element in \tcode{x} with index \tcode{$i$ + $j$ * T::size()}.
        The $i^\text{th}$ \simd or \mask element of the \code{N}$^\text{th}$
        \tcode{tuple} element is initialized to the value of the element in
        \tcode{x} with index \tcode{$i$ + $N$ * T::size()}.
    \end{itemize}
  \end{itemdescr}

\begin{itemdecl}
template<class T, class... Abis>
  constexpr simd<T, (basic_simd<T, Abis>::size() + ...)>
    simd_cat(const basic_simd<T, Abis>&... xs) noexcept;
template<size_t Bytes, class... Abis>
  constexpr simd_mask<@\deducet@<@\integerfrom@<Bytes>, (basic_simd_mask<Bytes, Abis>::size() + ...)>
    simd_cat(const basic_simd_mask<Bytes, Abis>&... xs) noexcept;

\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A data-parallel object initialized with the concatenated values in the \tcode{xs} pack of data-parallel objects: The $i^\text{th}$ \tcode{basic_simd}/\tcode{basic_simd_mask} element of the $j^\text{th}$ parameter in the \tcode{xs} pack is copied to the return value's element with index $i$ + the sum of the width of the first $j$ parameters in the \tcode{xs} pack.
\end{itemdescr}

\rSec2[simd.alg]{Algorithms}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
  minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  A \tcode{pair} initialized with
  \begin{itemize}
    \item the result of element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli{} in the \tcode{first} member, and
    \item the result of element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli{} in the \tcode{second} member.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> clamp(
    const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo, const basic_simd<T, Abi>& hi);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\expects
  No element in \tcode{lo} shall be greater than the corresponding element in \tcode{hi}.

  \pnum\returns
  The result of element-wise application of \tcode{std::clamp(v[$i$], lo[$i$], hi[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
\end{itemdecl}

\begin{itemdescr}
    \pnum\returns As-if \tcode{c ? a : b}.
\end{itemdescr}

\begin{itemdecl}
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype(@\simdselect@(c, a, b));
\end{itemdecl}

\begin{itemdescr}
    \pnum\returns As-if \tcode{\simdselect(c, a, b)}.
\end{itemdescr}

\rSec2[simd.math]{\tcode{basic_simd} math library}

\pnum
For each set of overloaded functions within \tcode{<cmath>}, there shall be additional overloads sufficient to ensure that if any argument corresponding to a \tcode{double} parameter has type \tcode{basic_simd<T, Abi>}, where \tcode{is_floating_point_v<T>} is \tcode{true}, then:
\begin{itemize}
  \item All arguments corresponding to \tcode{double} parameters shall be convertible to \tcode{basic_simd<T, Abi>}.
  \item All arguments corresponding to \tcode{double*} parameters shall be of type \tcode{basic_simd<T, Abi>*}.
  \item All arguments corresponding to parameters of integral type \tcode{U} shall be convertible to \tcode{rebind_simd_t<U, basic_simd<T, Abi>>}.
  \item All arguments corresponding to \tcode{U*}, where \tcode{U} is integral, shall be of type \tcode{rebind_simd_t<U, basic_simd<T, Abi>>*}.
  \item If the corresponding return type is \tcode{double}, the return type of the additional overloads is \tcode{basic_simd<T, Abi>}. Otherwise, if the corresponding return type is \tcode{bool}, the return type of the additional overload is \tcode{basic_simd<T, Abi>::mask_type}. Otherwise, the return type is \tcode{rebind_simd_t<R, basic_simd<T, Abi>>}, with \tcode{R} denoting the corresponding return type.
\end{itemize}
It is unspecified whether a call to these overloads with arguments that are all convertible to \tcode{basic_simd<T, Abi>} but are not of type \tcode{basic_simd<T, Abi>} is well-formed.

\pnum
Each function overload produced by the above rules applies the indicated \tcode{<cmath>} function element-wise. For the mathematical functions, the results per element only need to be approximately equal to the application of the function which is overloaded for the element type.

\pnum
The result is unspecified if a domain, pole, or range error occurs when the input argument(s) are applied to the indicated \tcode{<cmath>} function.
\begin{note}Implementations are encouraged to follow the C specification (especially Annex F).\end{note}

\pnum
\FIXME{Allow \tcode{abs(basic_simd<\textrm{signed-integral}>)}.}

\pnum
If \tcode{abs} is called with an argument of type \tcode{basic_simd<X, Abi>} for which \tcode{is_unsigned_v<X>} is \tcode{true}, the program is ill-formed.

\rSec1[simd.mask.class]{Class template \tcode{basic_simd_mask}}

\rSec2[simd.mask.overview]{Class template \tcode{basic_simd_mask} overview}

\begin{codeblock}
template<size_t Bytes, class Abi> class basic_simd_mask {
public:
  using value_type = bool;
  @\wgRem{using reference = \mbox{\seebelow};}@
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\simdsizev@<@\integerfrom@<Bytes>, Abi>> size {};

  constexpr basic_simd_mask() noexcept = default;

  // \ref{simd.mask.ctor}, \tcode{basic_simd_mask} constructors
  constexpr explicit basic_simd_mask(value_type) noexcept;
  template<size_t UBytes, class UAbi>
    constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
  template<class It, class... Flags>
    constexpr basic_simd_mask(It first, Flags = {});
  template<class It, class... Flags>
    constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});

  // \ref{simd.mask.copy}, \tcode{basic_simd_mask} copy functions
  template<class It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> = {});
  template<class It, class... Flags>
    constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;

  // \ref{simd.mask.subscr}, \tcode{basic_simd_mask} subscript operators
  @\wgRem{constexpr reference operator[](\mbox{\simdsizetype}) \&;}@
  constexpr value_type operator[](@\simdsizetype@) const@\wgRem{\&}@;

  // \ref{simd.mask.unary}, \tcode{basic_simd_mask} unary operators
  constexpr basic_simd_mask operator!() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator+() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator-() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator~() const noexcept;

  // \ref{simd.mask.conv}, \tcode{basic_simd_mask} conversion operators
  template <class U, class A>
    constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;

  // \ref{simd.mask.binary}, \tcode{basic_simd_mask} binary operators
  friend constexpr basic_simd_mask
    operator&&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator||(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator|(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator^(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cassign}, \tcode{basic_simd_mask} compound assignment
  friend constexpr basic_simd_mask&
    operator&=(basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask&
    operator|=(basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask&
    operator^=(basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.comparison}, \tcode{basic_simd_mask} comparisons
  friend constexpr basic_simd_mask
    operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator>=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator<=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator>(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator<(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cond}, \tcode{basic_simd_mask} conditional operators
  friend constexpr basic_simd_mask @\simdselect@(
    const basic_simd_mask&, const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask @\simdselect@(
    const basic_simd_mask&, same_as<bool> auto, same_as<bool> auto) noexcept;
  template <class T0, class T1>
    friend constexpr simd<@\seebelow@, size()>
      @\simdselect@(const basic_simd_mask&, const T0&, const T1&) noexcept;
};
\end{codeblock}

\pnum
The specializations of class template \tcode{basic_simd_mask} are data-parallel types with element type \tcode{bool}.

\pnum
Every specialization of \tcode{basic_simd_mask} is a complete type.
The specialization \tcode{basic_simd_mask<Bytes, Abi>} is not supported if the type \tcode{\integerfrom<Bytes>} does not exist or if it is not a vectorizable type.

It is implementation-defined whether \tcode{basic_simd_mask<T, Abi>} is supported.
\begin{note}The intent is for implementations to decide on the basis of the currently targeted system.\end{note}

If \tcode{basic_simd_mask<Bytes, Abi>} is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
Otherwise, the following are true:
\begin{itemize}
  \item \tcode{is_nothrow_move_constructible_v<basic_simd_mask<Bytes, Abi>>}, and
  \item \tcode{is_nothrow_move_assignable_v<basic_simd_mask<Bytes, Abi>>}, and
  \item \tcode{is_nothrow_default_constructible_v<basic_simd_mask<Bytes, Abi>>}.
\end{itemize}

\pnum
Default initialization performs no initialization of the elements; value-initialization initializes each element with \tcode{false}. \begin{note}Thus, default initialization leaves the elements in an indeterminate state.\end{note}

\pnum
Implementations should enable explicit conversion from and to implementation-defined types. This adds one or more of the following declarations to class \tcode{basic_simd_mask}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit basic_simd_mask(const @\impdef@& init);
\end{codeblock}

\pnum
\wgRem{The member type \tcode{reference} has the same interface as
\tcode{basic_simd<T, Abi>::reference}, except its \tcode{value_type} is
\tcode{bool}. (\mbox{\ref{simd.reference}})}

\rSec2[simd.mask.ctor]{\tcode{basic_simd_mask} constructors}

\begin{itemdecl}
constexpr explicit basic_simd_mask(value_type x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Initializes each element with \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
template<size_t UBytes, class UAbi>
  constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, UAbi> == size()}.

  \pnum\effects
  Initializes the $i^\text{th}$ element with \tcode{x[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{static_cast<bool>(gen(integral_constant<\simdsizetype, i>()))} is
  well-formed \foralli.

  \pnum\effects
  Initializes the $i^\text{th}$ element with
  \tcode{gen(integral_constant<\simdsizetype, i>())} \foralli.

  \pnum
  The calls to \tcode{gen} are unsequenced with respect to each other.
  Vectorization-unsafe standard library functions may not be invoked by \tcode{gen} (\iref{algorithms.parallel.exec}).
\end{itemdescr}

\newcommand\MaskLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is of type \tcode{bool}, and
    \item \tcode{It} models \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr basic_simd_mask(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\openrange{first, first + size()} is a valid range.}
    {Initializes the $i^\text{th}$ element with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Initializes the $i^\text{th}$ element with \tcode{mask[$i$] ? first[$i$] : false} \foralli.}
\end{itemdescr}

\rSec2[simd.mask.copy]{\tcode{basic_simd_mask} copy functions}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
  {\openrange{first, first + size()} is a valid range.}
  {Replaces the elements of the \tcode{basic_simd_mask} object such that the $i^\text{th}$ element is replaced with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd_mask} object such that the $i^\text{th}$ element is replaced with \tcode{first[$i$]} \forallmaskedi.}
\end{itemdescr}

\newcommand\MaskStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is of type \tcode{bool}, and
    \item \tcode{Out} models \tcode{contiguous_iterator}, and
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
    {\openrange{first, first + size()} is a valid range.}
    {Copies all \tcode{basic_simd_mask} elements as if \tcode{first[$i$] = operator[]($i$)} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
  {\validMaskedRange}
  {Copies the selected elements as if \tcode{first[$i$] = operator[]($i$)} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.mask.subscr]{\tcode{basic_simd_mask} subscript operator\texorpdfstring{\wgRem{s}}{s}}

\begin{wgBRem}
\begin{itemdecl}
@\wgRem{constexpr reference operator[](\mbox{\simdsizetype} i) \&;}@
\end{itemdecl}

\begin{itemdescr}
  \pnum\wgRem{\expects
  \tcode{i < size()}.}

  \pnum\wgRem{\returns
  A \tcode{reference} (see \mbox{\ref{simd.reference}}) referring to the $i^\text{th}$ element.}

  \pnum\wgRem{\throws Nothing.}
\end{itemdescr}
\end{wgBRem}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const@\wgRem{\&}@;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i >= 0 \&\& i < size()} is \tcode{true}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.mask.unary]{\tcode{basic_simd_mask} unary operators}

\begin{itemdecl}
constexpr basic_simd_mask operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The result of the element-wise application of \tcode{operator!}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator+() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator-() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  Application of the indicated unary operator to objects of type \tcode{T} is well-formed.

  \pnum\returns
  The result of applying the indicated operator to \tcode{static_cast<simd_type>(*this)}.
\end{itemdescr}

\rSec2[simd.mask.conv]{\tcode{basic_simd_mask} conversion operators}

\begin{itemdecl}
template <class U, class A>
  constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, A> == \simdsizev<T, Abi>}.

  \pnum\returns
  An object where the $i^\text{th}$ element is initialized to \tcode{static_cast<U>(operator[]($i$))}.
\end{itemdescr}

\rSec1[simd.mask.nonmembers]{Non-member operations}

\rSec2[simd.mask.binary]{\tcode{basic_simd_mask} binary operators}

\begin{itemdecl}
friend constexpr basic_simd_mask
  operator&&(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator||(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator& (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator| (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator^ (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cassign]{\tcode{basic_simd_mask} compound assignment}

\begin{itemdecl}
friend constexpr basic_simd_mask&
  operator&=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask&
  operator|=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask&
  operator^=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\rSec2[simd.mask.comparison]{\tcode{basic_simd_mask} comparisons}

\begin{itemdecl}
friend constexpr basic_simd_mask
  operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator>=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator<=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator>(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator<(const basic_simd_mask&, const basic_simd_mask&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cond]{\tcode{basic_simd_mask} conditional operators}

\begin{itemdecl}
friend constexpr basic_simd_mask @\simdselect@(
  const basic_simd_mask& mask, const basic_simd_mask& a, const basic_simd_mask& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] : b[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd_mask
@\simdselect@(const basic_simd_mask& mask, same_as<bool> auto a, same_as<bool> auto b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T0, class T1>
  friend constexpr simd<@\seebelow@, size()>
    @\simdselect@(const basic_simd_mask& mask, const T0& a, const T1& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{U} be the common type of \tcode{T0} and \tcode{T1} without
  applying integral promotions on integral types with integer conversion rank
  less than the rank of \tcode{int}.

  \pnum\constraints
  \begin{itemize}
    \item \tcode{U} is a vectorizable type, and
    \item \tcode{sizeof(U) == Bytes}, and
    \item \tcode{T0} satisfies \tcode{convertible_to<simd<U, size()>>}, and
    \item \tcode{T1} satisfies \tcode{convertible_to<simd<U, size()>>}.
  \end{itemize}

  \pnum\returns
  A \tcode{basic_simd<U, Abi>} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b} \foralli.
\end{itemdescr}

\rSec2[simd.mask.reductions]{\tcode{basic_simd_mask} reductions}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool all_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if all boolean elements in \tcode{k} are \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool any_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if at least one boolean element in \tcode{k} is \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool none_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if none of the one boolean elements in \tcode{k} is \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The number of boolean elements in \tcode{k} that are \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} is \tcode{true}.

  \pnum\returns
  The lowest element index $i$ where \tcode{k[$i$]} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} is \tcode{true}.

  \pnum\returns
  The greatest element index $i$ where \tcode{k[$i$]} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
constexpr bool all_of(same_as<bool> auto) noexcept;
constexpr bool any_of(same_as<bool> auto) noexcept;
constexpr bool none_of(same_as<bool> auto) noexcept;
constexpr @\simdsizetype@ reduce_count(same_as<bool> auto x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{all_of} and \tcode{any_of} return their arguments; \tcode{none_of}
  returns the negation of its argument; \tcode{reduce_count} returns the
  integral representation of \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
constexpr @\simdsizetype@ reduce_min_index(same_as<bool> auto y);
constexpr @\simdsizetype@ reduce_max_index(same_as<bool> auto z);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  The value of the argument is \tcode{true}.

  \pnum\returns \code{0}.
\end{itemdescr}

% vim: tw=0
