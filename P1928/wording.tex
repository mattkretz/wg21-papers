\def\rSec#1[#2]#3{%
  \ifcase#1\wgSubsection[subsection]{#3}{#2}
  \or\wgSubsubsection[subsubsection]{#3}{#2}
  \or\wgSubsubsubsection[paragraph]{#3}{#2}
  \or\error
\fi}

\renewcommand\foralli[1][]{for all $i$ in the range of \tcode{[0, #1size())}}
%\renewcommand\forallmaskedi{for all selected indices $i$}
\newcommand\validMaskedRange[1][first]{For all selected indices $i$, \tcode{[#1, #1 + $i$)} is a valid range.}
\newcommand\flagsRequires[2]{
\item If the template parameter \tcode{Flags} is \tcode{vector_aligned_tag}, \tcode{mem} shall point to storage aligned by \tcode{memory_alignment_v<#1>}.
\item If the template parameter \tcode{Flags} is \tcode{overaligned_tag<N>}, \tcode{mem} shall point to storage aligned by \tcode{N}.
\item If the template parameter \tcode{Flags} is \tcode{element_aligned_tag}, \tcode{mem} shall point to storage aligned by \tcode{alignof(#2)}.
}

\newcommand\ConstraintOperatorTWellFormed[1][the indicated operator]{%
\constraints Application of #1 to objects of type \tcode{value_type} is well-formed.
}

\rSec0[simd]{Data-Parallel Types}
\rSec1[simd.general]{General}

\pnum
The simd subclause defines data-parallel types and operations on these types. A data-parallel type consists of elements of an underlying vectorizable type, called the \defn{element type}. The number of elements is a constant for each data-parallel type and called the \defn{width} of that type.

\pnum
The term \defn{data-parallel type} refers to all \defn{supported} (\ref{simd.overview}) specializations of the \tcode{simd} and \tcode{simd_mask} class templates. A \defn{data-parallel object} is an object of \term{data-parallel type}.

\pnum
The set of \defn{vectorizable types} comprises all cv-unqualified arithmetic types other than \tcode{bool}.

\pnum
An \defn{element-wise operation} applies a specified operation to the elements of one or more data-parallel objects. Each such application is unsequenced with respect to the others. A \defn{unary element-wise operation} is an element-wise operation that applies a unary operation to each element of a data-parallel object. A \defn{binary element-wise operation} is an element-wise operation that applies a binary operation to corresponding elements of two data-parallel objects.

\pnum
Given a \tcode{simd_mask<T, Abi>} object \tcode{mask},
the \defn{selected indices} signify the integers $i \in \{j \in \mathbb{N}_0 | j < \tcode{mask.size()} \wedge \tcode{mask[}j\tcode{]}\}$.
Given an additional object \tcode{data} of type \tcode{simd<T, Abi>} or \tcode{simd_mask<T, Abi>},
the \defn{selected elements} signify the elements \tcode{data[$i$]} for all selected indices $i$.

\pnum
\begin{note}
The intent is to support acceleration through data-parallel execution resources, such as SIMD registers and instructions or execution units driven by a common instruction decoder. If such execution resources are unavailable, the interfaces support a transparent fallback to sequential execution.
\end{note}

\rSec1[simd.syn]{Header \texorpdfstring{\tcode{<simd>}}{<simd>} synopsis}

%\indexhdr{simd}
\begin{codeblock}
namespace std {
  namespace simd_abi {
    using scalar = @\seebelow@;
    template<class T, size_t N> using fixed_size = @\seebelow@;
    template<class T> inline constexpr size_t max_fixed_size = @\impdef@;
    template<class T> using native = @\impdef@;

    template<class T, size_t N, class... Abis> struct deduce { using type = @\seebelow@; };
    template<class T, size_t N, class... Abis> using deduce_t =
      typename deduce<T, N, Abis...>::type;
  }

  struct element_aligned_tag {};
  struct vector_aligned_tag {};
  template<size_t> struct overaligned_tag {};
  inline constexpr element_aligned_tag element_aligned{};
  inline constexpr vector_aligned_tag vector_aligned{};
  template<size_t N> inline constexpr overaligned_tag<N> overaligned{};

  // \ref{simd.traits}, \tcode{simd} type traits
  template<class T> struct is_abi_tag;
  template<class T> inline constexpr bool is_abi_tag_v = is_abi_tag<T>::value;

  template<class T> struct is_simd;
  template<class T> inline constexpr bool is_simd_v = is_simd<T>::value;

  template<class T> struct is_simd_mask;
  template<class T> inline constexpr bool is_simd_mask_v = is_simd_mask<T>::value;

  template<class T> struct is_simd_flag_type;
  template<class T> inline constexpr bool is_simd_flag_type_v =
    is_simd_flag_type<T>::value;

  template<class T, class Abi = simd_abi::native<T>> struct simd_size;
  template<class T, class Abi = simd_abi::native<T>>
    inline constexpr size_t simd_size_v = simd_size<T,Abi>::value;

  template<class T, class U = typename T::value_type> struct memory_alignment;
  template<class T, class U = typename T::value_type>
    inline constexpr size_t memory_alignment_v = memory_alignment<T,U>::value;

  template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
  template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
  template<size_t N, class V> struct resize_simd { using type = @\seebelow@; };
  template<size_t N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

  // \ref{simd.class}, Class template \tcode{simd}
  template<class T, class Abi = simd_abi::native<T>> class simd;
  template<class T, size_t N> using fixed_size_simd = simd<T, simd_abi::fixed_size<T, N>>;

  // \ref{simd.mask.class}, Class template \tcode{simd_mask}
  template<class T, class Abi = simd_abi::native<T>> class simd_mask;
  template<class T, size_t N> using fixed_size_simd_mask = simd_mask<T, simd_abi::fixed_size<T, N>>;

  template<size_t... Sizes, class T, class Abi>
    constexpr tuple<simd<T, simd_abi::deduce_t<T, Sizes>>...>
      split(const simd<T, Abi>&) noexcept;
  template<size_t... Sizes, class T, class Abi>
    constexpr tuple<simd_mask<T, simd_mask_abi::deduce_t<T, Sizes>>...>
      split(const simd_mask<T, Abi>&) noexcept;
  template<class V, class Abi>
    constexpr array<V, simd_size_v<typename V::value_type, Abi> / V::size()>
      split(const simd<typename V::value_type, Abi>&) noexcept;
  template<class V, class Abi>
    constexpr array<V, simd_size_v<typename V::simd_type::value_type, Abi> / V::size()>
      split(const simd_mask<typename V::simd_type::value_type, Abi>&) noexcept;

  template<size_t N, class T, class A>
    constexpr array<resize_simd_t<simd_size_v<T, A> / N, simd<T, A>>, N>
      split_by(const simd<T, A>& x) noexcept;
  template<size_t N, class T, class A>
    constexpr array<resize_simd_t<simd_size_v<T, A> / N, simd_mask<T, A>>, N>
      split_by(const simd_mask<T, A>& x) noexcept;

  template<class T, class... Abis>
    constexpr simd<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>>
      concat(const simd<T, Abis>&...) noexcept;
  template<class T, class... Abis>
    constexpr simd_mask<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>>
      concat(const simd_mask<T, Abis>&...) noexcept;

  template<class T, class Abi, size_t N>
    constexpr resize_simd_t<simd_size_v<T, Abi> * N, simd<T, Abi>>
      concat(const array<simd<T, Abi>, N>& arr) noexcept;
  template<class T, class Abi, size_t N>
    constexpr resize_simd_t<simd_size_v<T, Abi> * N, simd_mask<T, Abi>>
      concat(const array<simd_mask<T, Abi>, N>& arr) noexcept;

  // \ref{simd.mask.reductions}, \tcode{simd_mask} reductions
  template<class T, class Abi> constexpr bool all_of(const simd_mask<T, Abi>&) noexcept;
  template<class T, class Abi> constexpr bool any_of(const simd_mask<T, Abi>&) noexcept;
  template<class T, class Abi> constexpr bool none_of(const simd_mask<T, Abi>&) noexcept;
  template<class T, class Abi> constexpr int reduce_count(const simd_mask<T, Abi>&) noexcept;
  template<class T, class Abi> constexpr int reduce_min_index(const simd_mask<T, Abi>&);
  template<class T, class Abi> constexpr int reduce_max_index(const simd_mask<T, Abi>&);

  constexpr bool all_of(@\UNSP{T}@) noexcept;
  constexpr bool any_of(@\UNSP{T}@) noexcept;
  constexpr bool none_of(@\UNSP{T}@) noexcept;
  constexpr int reduce_count(@\UNSP{T}@) noexcept;
  constexpr int reduce_min_index(@\UNSP{T}@);
  constexpr int reduce_max_index(@\UNSP{T}@);

  // \ref{simd.reductions}, \tcode{simd} reductions
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(const simd<T, Abi>&, BinaryOperation = {});

  template<class T, class Abi, class BinaryOperation>
    constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                       T identity_element, BinaryOperation binary_op);
  template<class T, class Abi>
    constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                       plus<> binary_op = {}) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                       multiplies<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                       bit_and<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                       bit_or<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                       bit_xor<> binary_op) noexcept;

  template<class T, class Abi>
    constexpr T hmin(const simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T hmin(const simd<T, Abi>&, const typename simd<T, Abi>::mask_type&) noexcept;
  template<class T, class Abi>
    constexpr T hmax(const simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T hmax(const simd<T, Abi>&, const typename simd<T, Abi>::mask_type&) noexcept;

  // \ref{simd.alg}, Algorithms
  template<class T, class Abi>
    constexpr simd<T, Abi>
      min(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr simd<T, Abi>
      max(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr pair<simd<T, Abi>, simd<T, Abi>>
      minmax(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr simd<T, Abi>
      clamp(const simd<T, Abi>& v,
            const simd<T, Abi>& lo,
            const simd<T, Abi>& hi);
}
\end{codeblock}

\pnum
The header \tcode{<simd>} defines class templates, tag types, trait types, and function templates for element-wise operations on data-parallel objects.

\rSec1[simd.abi]{\tcode{simd} ABI tags}

\begin{codeblock}
namespace simd_abi {
  using scalar = @\seebelow@;
  template<class T, size_t N> using fixed_size = @\seebelow@;
  template<class T> inline constexpr size_t max_fixed_size = @\impdef@;
  template<class T> using native = @\impdef@;
}
\end{codeblock}

\pnum
An \defn{ABI tag} is a type in the \tcode{std::simd_abi} namespace that indicates a choice of size and binary representation for objects of data-parallel type. \begin{note}The intent is for the size and binary representation to depend on the target architecture.\end{note} The ABI tag, together with a given element type implies a number of elements. ABI tag types are used as the second template argument to \tcode{simd} and \tcode{simd_mask}.

\pnum
\begin{note}The ABI tag is orthogonal to selecting the machine instruction set. The selected machine instruction set limits the usable ABI tag types, though (see \ref{simd.overview}). The ABI tags enable users to safely pass objects of data-parallel type between translation unit boundaries (e.g. function calls or I/O).\end{note}

\pnum
\tcode{scalar} is an alias for an unspecified ABI tag that is different from \tcode{fixed_size<1>}.
Use of the \tcode{scalar} tag type requires data-parallel types to store a single element (i.e., \tcode{simd_size_v<T, simd_abi::scalar>} equals 1).

\pnum
The value of \tcode{max_fixed_size<T>} is at least 32.

\pnum
\tcode{fixed_size<N>} is an alias for an unspecified ABI tag.
\tcode{fixed_size} does not introduce a non-deduced context.
Use of the \tcode{simd_abi::fixed_size<N>} tag type requires data-parallel types to store \tcode{N}
elements (i.e. \tcode{simd_size_v<T, simd_abi::fixed_size<N>>\relax} equals
\tcode{N}). \tcode{simd<T, fixed_size<N>>} and \tcode{simd_mask<T,
fixed_size<N>>} with \tcode{N > 0} and \tcode{N <= max_fixed_size<T>} shall be supported.
Additionally, for every supported \tcode{simd<T, Abi>} (see \ref{simd.overview}), where \tcode{Abi}
is an ABI tag that is not a specialization of \tcode{simd_abi::fixed_size}, \tcode{N == simd<T,
Abi>::size()} shall be supported.

\pnum
\begin{note}It is unspecified whether \tcode{simd<T, fixed_size<N>>} with \tcode{N > max_fixed_size<T>} is supported. The value of \tcode{max_fixed_size<T>} can depend on compiler flags and can change between different compiler versions.\end{note}

\pnum
  The type of \tcode{fixed_size<T, N>} in TU1 differs from the type of
  \tcode{fixed_size<T, N>} in TU2 iff the type of \tcode{native<T>} in TU1 differs from
  the type of \tcode{native<T>} in TU2.

\pnum
An implementation may define additional \defn{extended ABI tag} types in the \tcode{std::simd_abi} namespace, to support other forms of data-parallel computation.

\pnum
\tcode{native<T>} is an implementation-defined alias for an ABI tag. \begin{note}The intent is to use the ABI tag producing the most efficient data-parallel execution for the element type \tcode{T} that is supported on the currently targeted system. For target architectures with ISA extensions, compiler flags may change the type of the \tcode{native<T>} alias.\end{note}
\begin{example}
  Consider a target architecture supporting the extended ABI tags \tcode{__simd128} and \tcode{__simd256}, where hardware support for \tcode{__simd256} only exists for floating-point types. The implementation therefore defines \tcode{native<T>} as an alias for
  \begin{itemize}
    \item \tcode{__simd256} if \tcode{T} is a floating-point type, and
    \item \tcode{__simd128} otherwise.
  \end{itemize}
\end{example}

\begin{itemdecl}
template<T, size_t N, class... Abis> struct deduce { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
\pnum
The member \tcode{type} shall be present if and only if
\begin{itemize}
  \item \tcode{T} is a vectorizable type, and
  \item \tcode{simd_abi::fixed_size<N>} is supported (see \ref{simd.abi}), and
  \item every type in the \tcode{Abis} pack is an ABI tag.
\end{itemize}

\pnum
Where present, the member typedef \tcode{type} shall name an ABI tag type that satisfies
\begin{itemize}
  \item \tcode{simd_size<T, type> == N}, and
  \item \tcode{simd<T, type>} is default constructible (see \ref{simd.overview}).
\end{itemize}
If \tcode{N} is \tcode{1}, the member typedef \tcode{type} is \tcode{simd_abi::scalar}.
\begin{note}
  Implementations can base the choice on \tcode{Abis}, but can also ignore the \tcode{Abis} arguments.
\end{note}

\pnum
The behavior of a program that adds specializations for \tcode{deduce} is undefined.
\end{itemdescr}

\rSec1[simd.traits]{\tcode{simd} type traits}

\begin{itemdecl}
template<class T> struct is_abi_tag { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The type \tcode{is_abi_tag<T>} is a \tcode{UnaryTypeTrait} with a base characteristic of \tcode{true_type} if \tcode{T} is a standard or extended ABI tag, and \tcode{false_type} otherwise.

\pnum
The behavior of a program that adds specializations for \tcode{is_abi_tag} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T> struct is_simd { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The type \tcode{is_simd<T>} is a \tcode{UnaryTypeTrait} with a base characteristic of \tcode{true_type} if \tcode{T} is a specialization of the \tcode{simd} class template, and \tcode{false_type} otherwise.

\pnum
The behavior of a program that adds specializations for \tcode{is_simd} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T> struct is_simd_mask { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The type \tcode{is_simd_mask<T>} is a \tcode{UnaryTypeTrait} with a base characteristic of \tcode{true_type} if \tcode{T} is a specialization of the \tcode{simd_mask} class template, and \tcode{false_type} otherwise.

\pnum
The behavior of a program that adds specializations for \tcode{is_simd_mask} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T> struct is_simd_flag_type { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
The type \tcode{is_simd_flag_type<class T>} is a \tcode{UnaryTypeTrait} with a base characteristic of \tcode{true_type} if \tcode{T} is one of
\begin{itemize}
  \item \tcode{element_aligned_tag}, or
  \item \tcode{vector_aligned_tag}, or
  \item \tcode{overaligned_tag<N>} with \tcode{N > 0} and \tcode{N} an integral power of two,
\end{itemize}
and \tcode{false_type} otherwise.

\pnum
The behavior of a program that adds specializations for \tcode{is_simd_flag_type} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi = simd_abi::native<T>> struct simd_size { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{simd_size<T, Abi>} shall have a member \tcode{value} if and only if
\begin{itemize}
  \item \tcode{T} is a vectorizable type, and
  \item \tcode{is_abi_tag_v<Abi>} is \tcode{true}.
\end{itemize}
\begin{note}
  The rules are different from those in (\ref{simd.overview}):
  The member \tcode{value} is present even if \tcode{simd<T, Abi>} is not supported for the currently targeted system.
\end{note}

\pnum
If \tcode{value} is present, the type \tcode{simd_size<T, Abi>} is a \tcode{BinaryTypeTrait} with a base characteristic of \tcode{integral_constant<size_t, N>} with \tcode{N} equal to the number of elements in a \tcode{simd<T, Abi>} object.

\pnum
The behavior of a program that adds specializations for \tcode{simd_size} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class U = typename T::value_type> struct memory_alignment { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{memory_alignment<T, U>} shall have a member \tcode{value} if and only if
\begin{itemize}
  \item \tcode{is_simd_mask_v<T>} is \tcode{true} and \tcode{U} is \tcode{bool}, or
  \item \tcode{is_simd_v<T>} is \tcode{true} and \tcode{U} is a vectorizable type.
\end{itemize}

\pnum
If \tcode{value} is present, the type \tcode{memory_alignment<T, U>} is a \tcode{BinaryTypeTrait} with a base characteristic of \tcode{integral_constant<size_t, N>} for some implementation-defined \tcode{N} (see \ref{simd.copy} and \ref{simd.mask.copy}). \begin{note}\tcode{value} identifies the alignment restrictions on pointers used for (converting) loads and stores for the give type \tcode{T} on arrays of type \tcode{U}.\end{note}

\pnum
The behavior of a program that adds specializations for \tcode{memory_alignment} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is either \tcode{simd<U, Abi0>} or \tcode{simd_mask<U, Abi0>}, where \tcode{U} and \tcode{Abi0} are deduced from \tcode{V}, and
    \item \tcode{T} is a vectorizable type, and
    \item \tcode{simd_abi::deduce<T, simd_size_v<U, Abi0>, Abi0>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote the type \tcode{deduce_t<T, simd_size_v<U, Abi0>, Abi0>}.
  Where present, the member typedef \tcode{type} names
  \tcode{simd<T, Abi1>} if \tcode V is \tcode{simd<U, Abi0>} or
  \tcode{simd_mask<T, Abi1>} if \tcode V is \tcode{simd_mask<U, Abi0>}.
\end{itemdescr}

\begin{itemdecl}
template<size_t N, class V> struct resize_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is either \tcode{simd<T, Abi0>} or \tcode{simd_mask<T, Abi0>}, where \tcode T and \tcode{Abi0} are deduced from \tcode V, and
    \item \tcode{simd_abi::deduce<T, N, Abi0>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote the type \tcode{deduce_t<T, N, Abi0>}.
  Where present, the member typedef \tcode{type} names \tcode{simd<T, Abi1>} if \tcode V is \tcode{simd<T, Abi0>} or \tcode{simd_mask<T, Abi1>} if \tcode V is \tcode{simd_mask<T, Abi0>}.
\end{itemdescr}

\rSec1[simd.class]{Class template \tcode{simd}}

\rSec2[simd.overview]{Class template \tcode{simd} overview}

\begin{codeblock}
template<class T, class Abi> class simd {
public:
  using value_type = T;
  using reference = @\seebelow@;
  using mask_type = simd_mask<T, Abi>;
  using abi_type = Abi;

  static constexpr typename simd_size<T, Abi>::type size;

  constexpr simd() noexcept = default;

  // \ref{simd.ctor}, \tcode{simd} constructors
  template<class U> constexpr simd(U&& value) noexcept;
  template<class U, class UAbi>
    constexpr explicit(@\seebelow@) simd(const simd<U, UAbi>&) noexcept;
  template<class G> constexpr explicit simd(G&& gen) noexcept;
  template<typename It, class Flags = element_aligned_tag>
    constexpr simd(It first, Flags = {});
  template<typename It, class Flags = element_aligned_tag>
    constexpr simd(It first, const mask_type& mask, Flags = {});

  // \ref{simd.copy}, \tcode{simd} copy functions
  template<typename It, class Flags = element_aligned_tag>
    constexpr void copy_from(It first, Flags f = {});
  template<typename It, class Flags = element_aligned_tag>
    constexpr void copy_from(It first, const mask_type& mask, Flags f = {});
  template<typename Out, class Flags = element_aligned_tag>
    constexpr void copy_to(Out first, Flags f = {}) const;
  template<typename Out, class Flags = element_aligned_tag>
    constexpr void copy_to(Out first, const mask_type& mask, Flags f = {}) const;

  // \ref{simd.subscr}, \tcode{simd} subscript operators
  constexpr reference operator[](size_t) &;
  constexpr value_type operator[](size_t) const&;

  // \ref{simd.unary}, \tcode{simd} unary operators
  constexpr simd& operator++() noexcept;
  constexpr simd operator++(int) noexcept;
  constexpr simd& operator--() noexcept;
  constexpr simd operator--(int) noexcept;
  constexpr mask_type operator!() const noexcept;
  constexpr simd operator~() const noexcept;
  constexpr simd operator+() const noexcept;
  constexpr simd operator-() const noexcept;

  // \ref{simd.binary}, \tcode{simd} binary operators
  friend constexpr simd operator+(const simd&, const simd&) noexcept;
  friend constexpr simd operator-(const simd&, const simd&) noexcept;
  friend constexpr simd operator*(const simd&, const simd&) noexcept;
  friend constexpr simd operator/(const simd&, const simd&) noexcept;
  friend constexpr simd operator%(const simd&, const simd&) noexcept;
  friend constexpr simd operator&(const simd&, const simd&) noexcept;
  friend constexpr simd operator|(const simd&, const simd&) noexcept;
  friend constexpr simd operator^(const simd&, const simd&) noexcept;
  friend constexpr simd operator<<(const simd&, const simd&) noexcept;
  friend constexpr simd operator>>(const simd&, const simd&) noexcept;
  friend constexpr simd operator<<(const simd&, int) noexcept;
  friend constexpr simd operator>>(const simd&, int) noexcept;

  // \ref{simd.cassign}, \tcode{simd} compound assignment
  friend constexpr simd& operator+=(simd&, const simd&) noexcept;
  friend constexpr simd& operator-=(simd&, const simd&) noexcept;
  friend constexpr simd& operator*=(simd&, const simd&) noexcept;
  friend constexpr simd& operator/=(simd&, const simd&) noexcept;
  friend constexpr simd& operator%=(simd&, const simd&) noexcept;
  friend constexpr simd& operator&=(simd&, const simd&) noexcept;
  friend constexpr simd& operator|=(simd&, const simd&) noexcept;
  friend constexpr simd& operator^=(simd&, const simd&) noexcept;
  friend constexpr simd& operator<<=(simd&, const simd&) noexcept;
  friend constexpr simd& operator>>=(simd&, const simd&) noexcept;
  friend constexpr simd& operator<<=(simd&, int) noexcept;
  friend constexpr simd& operator>>=(simd&, int) noexcept;

  // \ref{simd.comparison}, \tcode{simd} compare operators
  friend constexpr mask_type operator==(const simd&, const simd&) noexcept;
  friend constexpr mask_type operator!=(const simd&, const simd&) noexcept;
  friend constexpr mask_type operator>=(const simd&, const simd&) noexcept;
  friend constexpr mask_type operator<=(const simd&, const simd&) noexcept;
  friend constexpr mask_type operator>(const simd&, const simd&) noexcept;
  friend constexpr mask_type operator<(const simd&, const simd&) noexcept;

  // \ref{simd.cond}, \tcode{simd} conditional operators
  friend constexpr simd operator?:(const mask_type&, const simd&, const simd&) noexcept;
};
\end{codeblock}

\pnum
The class template \tcode{simd} is a data-parallel type. The width of a given \tcode{simd} specialization is a constant expression, determined by the template parameters.

\pnum
Every specialization of \tcode{simd} is a complete type. The specialization \tcode{simd<T, Abi>} is supported if \tcode{T} is a vectorizable type and
\begin{itemize}
  \item \tcode{Abi} is \tcode{simd_abi::scalar}, or
  \item \tcode{Abi} is \tcode{simd_abi::fixed_size<N>}, with \tcode{N} constrained as defined in \ref{simd.abi}.
\end{itemize}

If \tcode{Abi} is an extended ABI tag, it is implementation-defined whether \tcode{simd<T, Abi>} is supported. \begin{note}The intent is for implementations to decide on the basis of the currently targeted system.\end{note}

If \tcode{simd<T, Abi>} is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
Otherwise, the following are true:
\begin{itemize}
  \item \tcode{is_nothrow_move_constructible_v<simd<T, Abi>>}, and
  \item \tcode{is_nothrow_move_assignable_v<simd<T, Abi>>}, and
  \item \tcode{is_nothrow_default_constructible_v<simd<T, Abi>>}.
\end{itemize}

\begin{example}
  Consider an implementation that defines the extended ABI tags \tcode{__simd_x} and \tcode{__gpu_y}. When the compiler is invoked to translate to a machine that has support for the \tcode{__simd_x} ABI tag for all arithmetic types other than \tcode{long double} and no support for the \tcode{__gpu_y} ABI tag, then:
  \begin{itemize}
    \item \tcode{simd<T, simd_abi::__gpu_y>} is not supported for any \tcode{T} and has a deleted constructor.
    \item \tcode{simd<long double, simd_abi::__simd_x>} is not supported and has a deleted constructor.
    \item \tcode{simd<double, simd_abi::__simd_x>} is supported.
    \item \tcode{simd<long double, simd_abi::scalar>} is supported.
  \end{itemize}
\end{example}

\pnum
Default intialization performs no initialization of the elements; value-initialization initializes each element with \tcode{T()}. \begin{note}Thus, default initialization leaves the elements in an indeterminate state.\end{note}

\pnum
Implementations should enable explicit conversion from and to implementation-defined types. This adds one or more of the following declarations to class \tcode{simd}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit simd(const @\impdef@& init);
\end{codeblock}

\begin{example}
  Consider an implementation that supports the type \tcode{__vec4f} and the function \tcode{__vec4f _vec4f_addsub(__vec4f, __vec4f)} for the currently targeted system.
  A user may require the use of \tcode{_vec4f_addsub} for maximum performance and thus writes:
  \begin{codeblock}
    using V = simd<float, simd_abi::__simd128>;
    V addsub(V a, V b) {
      return static_cast<V>(_vec4f_addsub(static_cast<__vec4f>(a), static_cast<__vec4f>(b)));
    }
  \end{codeblock}
\end{example}

\rSec2[simd.width]{\tcode{simd} width}

\begin{itemdecl}
static constexpr typename simd_size<T, Abi>::type size;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The width of \tcode{simd<T, Abi>}.
\end{itemdescr}

\rSec2[simd.reference]{Element references}

\pnum
A \tcode{reference} is an object that refers to an element in a \tcode{simd} or \tcode{simd_mask} object. \tcode{reference::value_type} is the same type as \tcode{simd::value_type} or \tcode{simd_mask::value_type}, respectively.

\pnum
Class \tcode{reference} is for exposition only. An implementation is permitted to provide equivalent functionality without providing a class with this name.

\begin{codeblock}
class reference // \expos
{
public:
  reference() = delete;
  reference(const reference&) = delete;

  constexpr operator value_type() const noexcept;

  template<class U> constexpr reference operator=(U&& x) && noexcept;

  template<class U> constexpr reference operator+=(U&& x) && noexcept;
  template<class U> constexpr reference operator-=(U&& x) && noexcept;
  template<class U> constexpr reference operator*=(U&& x) && noexcept;
  template<class U> constexpr reference operator/=(U&& x) && noexcept;
  template<class U> constexpr reference operator%=(U&& x) && noexcept;
  template<class U> constexpr reference operator|=(U&& x) && noexcept;
  template<class U> constexpr reference operator&=(U&& x) && noexcept;
  template<class U> constexpr reference operator^=(U&& x) && noexcept;
  template<class U> constexpr reference operator<<=(U&& x) && noexcept;
  template<class U> constexpr reference operator>>=(U&& x) && noexcept;

  constexpr reference operator++() && noexcept;
  constexpr value_type operator++(int) && noexcept;
  constexpr reference operator--() && noexcept;
  constexpr value_type operator--(int) && noexcept;

  friend constexpr void swap(reference&& a, reference&& b) noexcept;
  friend constexpr void swap(value_type& a, reference&& b) noexcept;
  friend constexpr void swap(reference&& a, value_type& b) noexcept;
};
\end{codeblock}

\begin{itemdecl}
constexpr operator value_type() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The value of the element referred to by \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
template<class U> constexpr reference operator=(U&& x) && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Replaces the referred to element in \tcode{simd} or \tcode{simd_mask} with \tcode{static_cast<value_type>(std\colcol{}forward<U>(x))}.

  \pnum\returns
  A copy of \tcode{*this}.

  \pnum\remarks
  This function shall not participate in overload resolution unless \tcode{declval<value_type\&>() = std\colcol{}forward<U>(x)} is well-formed.
\end{itemdescr}

\begin{itemdecl}
template<class U> constexpr reference operator+=(U&& x) && noexcept;
template<class U> constexpr reference operator-=(U&& x) && noexcept;
template<class U> constexpr reference operator*=(U&& x) && noexcept;
template<class U> constexpr reference operator/=(U&& x) && noexcept;
template<class U> constexpr reference operator%=(U&& x) && noexcept;
template<class U> constexpr reference operator|=(U&& x) && noexcept;
template<class U> constexpr reference operator&=(U&& x) && noexcept;
template<class U> constexpr reference operator^=(U&& x) && noexcept;
template<class U> constexpr reference operator<<=(U&& x) && noexcept;
template<class U> constexpr reference operator>>=(U&& x) && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Applies the indicated compound operator to the referred to element in \tcode{simd} or \tcode{simd_mask} and \tcode{std\colcol{}forward<U>(x)}.

  \pnum\returns
  A copy of \tcode{*this}.

  \pnum\remarks
  This function shall not participate in overload resolution unless \tcode{declval<value_type\&>() @= std\colcol{}forward<U>(x)} (where \tcode{@=} denotes the indicated compound assignment operator) is well-formed.
\end{itemdescr}

\begin{itemdecl}
constexpr reference operator++() && noexcept;
constexpr reference operator--() && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Applies the indicated operator to the referred to element in \tcode{simd} or \tcode{simd_mask}.

  \pnum\returns
  A copy of \tcode{*this}.

  \pnum\remarks
  This function shall not participate in overload resolution unless the indicated operator can be applied to objects of type \tcode{value_type}.
\end{itemdescr}

\begin{itemdecl}
constexpr value_type operator++(int) && noexcept;
constexpr value_type operator--(int) && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Applies the indicated operator to the referred to element in \tcode{simd} or \tcode{simd_mask}.

  \pnum\returns
  A copy of the referred to element before applying the indicated operator.

  \pnum\remarks
  This function shall not participate in overload resolution unless the indicated operator can be applied to objects of type \tcode{value_type}.
\end{itemdescr}

\begin{itemdecl}
friend constexpr void swap(reference&& a, reference&& b) noexcept;
friend constexpr void swap(value_type& a, reference&& b) noexcept;
friend constexpr void swap(reference&& a, value_type& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Exchanges the values \tcode{a} and \tcode{b} refer to.
\end{itemdescr}

\rSec2[simd.ctor]{\tcode{simd} constructors}

\begin{itemdecl}
template<class U> constexpr simd(U&&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object with each element initialized to the value of the argument after conversion to \tcode{value_type}.

  \pnum\remarks
  Let \tcode{From} denote the type \tcode{remove_cvref_t<U>}. This constructor shall not participate in overload resolution unless:
  \begin{itemize}
    \item \tcode{From} is a vectorizable type and every possibly value of \tcode{From} can be represented with type \tcode{value_type}, or
    \item \tcode{From} is not an arithmetic type and is implicitly convertible to \tcode{value_type}, or
    \item \tcode{From} is \tcode{int}, or
    \item \tcode{From} is \tcode{unsigned int} and \tcode{is_unsigned_v<value_type>} is \tcode{true}.% unsigned integer types excludes character types
  \end{itemize}

\end{itemdescr}

\begin{itemdecl}
template<class U, class UAbi> constexpr explicit(@\seebelow@) simd(const simd<U, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object where the $i^\text{th}$ element equals \tcode{static_cast<T>(x[$i$])} \foralli.

  \pnum\remarks
  This constructor shall not participate in overload resolution unless
  \tcode{simd_size_v<U, UAbi> == size()}.

    \pnum
    The constructor is \tcode{explicit} iff
    \begin{itemize}
      \item at least one possible value of \tcode{U} cannot be represented with type \tcode{value_type}, or
      \item if both \tcode{U} and \tcode{value_type} are integral types, the integer conversion rank (\mbox{\ref{conv.rank}}) of \tcode{U} is greater than the integer conversion rank of \tcode{value_type}, or
      \item if both \tcode{U} and \tcode{value_type} are floating-point types, the floating-point conversion rank (\mbox{\ref{conv.rank}}) of \tcode{U} is greater than the floating-point conversion rank of \tcode{value_type}.
    \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr simd(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object where the $i^\text{th}$ element is initialized to \tcode{gen(integral_constant<size_t, i>())}.

  \pnum\remarks
  This constructor shall not participate in overload resolution unless \tcode{simd(gen(integral_constant<size_t, i>()))} is well-formed \foralli.

  \pnum
  The calls to \tcode{gen} are unsequenced with respect to each other. Vectorization-unsafe standard library functions may not be invoked by \tcode{gen} (\ref{algorithms.parallel.exec}).
\end{itemdescr}

\newcommand\SimdLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{is_simd_flag_type_v<Flags>} is \tcode{true}, and
    \item \tcode{iter_value_t<It>} is a vectorizable type, and
    \item \tcode{It} satisfies \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{It} models \tcode{contiguous_iterator}.
    \flagsRequires{simd, iter_value_t<It>}{iter_value_t<It>}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr simd(It first, Flags = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{static_cast<T>(first[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr simd(It first, const mask_type& mask, Flags = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{mask[$i$] ? static_cast<T>(first[$i$]) : T()} \foralli.}
\end{itemdescr}

\rSec2[simd.copy]{\tcode{simd} copy functions}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr void copy_from(It first, Flags f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Replaces the elements of the \tcode{simd} object such that the $i^\text{th}$ element is assigned with \tcode{static_cast<T>(first[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr void copy_from(It first, const mask_type& mask, Flags f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{simd} object such that the $i^\text{th}$ element is replaced with \tcode{static_cast<T>(first[$i$])} \forallmaskedi.}
\end{itemdescr}

\newcommand\SimdStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{is_simd_flag_type_v<Flags>} is \tcode{true}, and
    \item \tcode{iter_value_t<Out>} is a vectorizable type, and
    \item \tcode{Out} satisfies \tcode{contiguous_iterator}, and
    \item \tcode{Out} satisfies \tcode{output_iterator<value_type>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{Out} models \tcode{contiguous_iterator}.
    \item \tcode{Out} models \tcode{output_iterator<value_type>}.
    \flagsRequires{simd, iter_value_t<Out>}{iter_value_t<Out>}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename Out, class Flags = element_aligned_tag>
  constexpr void copy_to(Out first, Flags f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Copies all \tcode{simd} elements as if \tcode{first[$i$] = static_cast<iter_value_t<Out>>(operator[]($i$))} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename Out, class Flags = element_aligned_tag>
  constexpr void copy_to(Out first, const mask_type& mask, Flags f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\validMaskedRange}
    {Copies the selected elements as if \tcode{first[$i$] = static_cast<iter_value_t<Out>>(operator[]($i$))} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.subscr]{\tcode{simd} subscript operators}

\begin{itemdecl}
constexpr reference operator[](size_t i) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  \tcode{i < size()}.

  \pnum\returns
  A \tcode{reference} (see \ref{simd.reference}) referring to the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
constexpr value_type operator[](size_t i) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  \tcode{i < size()}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.unary]{\tcode{simd} unary operators}

\pnum
Effects in this subclause are applied as unary element-wise operations.

\begin{itemdecl}
constexpr simd& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{++}]

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr simd operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{++}]

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  A copy of \tcode{*this} before incrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr simd& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{--}]

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr simd operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{--}]

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  A copy of \tcode{*this} before decrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr mask_type operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{!}]

  \pnum\returns
  A \tcode{simd_mask} object with the $i^\text{th}$ element set to \tcode{!operator[]($i$)} \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr simd operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{\~{}}]

  \pnum\returns
  A \tcode{simd} object where each bit is the inverse of the corresponding bit in \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr simd operator+() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{+}]

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr simd operator-() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{-}]

  \pnum\returns
  A \tcode{simd} object where the $i^\text{th}$ element is initialized to \tcode{-operator[]($i$)} \foralli.
\end{itemdescr}

\rSec1[simd.nonmembers]{\tcode{simd} non-member operations}

\rSec2[simd.binary]{\tcode{simd} binary operators}

\begin{itemdecl}
friend constexpr simd operator+(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator-(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator*(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator/(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator%(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator&(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator|(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator^(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator<<(const simd& lhs, const simd& rhs) noexcept;
friend constexpr simd operator>>(const simd& lhs, const simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{simd} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\begin{itemdecl}
friend constexpr simd operator<<(const simd& v, int n) noexcept;
friend constexpr simd operator>>(const simd& v, int n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{simd} object where the $i^\text{th}$ element is initialized to the result of applying the indicated operator to \tcode{v[$i$]} and \tcode{n} \foralli.
\end{itemdescr}

\rSec2[simd.cassign]{\tcode{simd} compound assignment}

\begin{itemdecl}
friend constexpr simd& operator+=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator-=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator*=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator/=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator%=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator&=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator|=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator^=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator<<=(simd& lhs, const simd& rhs) noexcept;
friend constexpr simd& operator>>=(simd& lhs, const simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as an element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\begin{itemdecl}
friend constexpr simd& operator<<=(simd& lhs, int n) noexcept;
friend constexpr simd& operator>>=(simd& lhs, int n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  Equivalent to: \tcode{return operator@=(lhs, simd(n));}
\end{itemdescr}

\rSec2[simd.comparison]{\tcode{simd} compare operators}

\begin{itemdecl}
friend constexpr mask_type operator==(const simd& lhs, const simd& rhs) noexcept;
friend constexpr mask_type operator!=(const simd& lhs, const simd& rhs) noexcept;
friend constexpr mask_type operator>=(const simd& lhs, const simd& rhs) noexcept;
friend constexpr mask_type operator<=(const simd& lhs, const simd& rhs) noexcept;
friend constexpr mask_type operator>(const simd& lhs, const simd& rhs) noexcept;
friend constexpr mask_type operator<(const simd& lhs, const simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.cond]{\texorpdfstring{\tcode{simd}}{simd} conditional operators}

\begin{itemdecl}
friend constexpr simd operator?:(const mask_type& mask, const simd& a, const simd& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{simd} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] : b[$i$]} \foralli.
\end{itemdescr}
\rSec2[simd.reductions]{\texorpdfstring{\tcode{simd} r}{simd r}eductions}

\pnum
In this subclause, \tcode{BinaryOperation} shall be a binary element-wise operation.

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation = plus<>>
  constexpr T reduce(const simd<T, Abi>& x, BinaryOperation binary_op = {});
\end{itemdecl}

\begin{itemdescr}
  \pnum\mandates
  \tcode{binary_op} can be invoked with two arguments of type \tcode{simd<T, A1>} returning \tcode{simd<T, A1>} for every \tcode{A1} that is an ABI tag type.

  \pnum\returns
  \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x.data[$i$], ...)} \foralli (\ref{numerics.defns}).

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation>
  constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                     T identity_element, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
  \pnum\mandates
  \tcode{binary_op} can be invoked with two arguments of type \tcode{simd<T, A1>} returning \tcode{simd<T, A1>} for every \tcode{A1} that is an ABI tag type.

  \pnum\expects
  The results of \tcode{all_of(x == binary_op(simd<T, A1>(identity_element), simd<T, A1>(x)))} and \tcode{all_of(simd<T, A1>(x) == binary_op(x, simd<T, A1>(identity_element)))} shall be \tcode{true} for every \tcode{A1} that is an ABI tag type and for all finite values \tcode{x} representable by \tcode{T}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{identity_element}.
  Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                     plus<> binary_op = {}) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                     multiplies<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  If \tcode{none_of(x)}, returns \tcode{1}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                     bit_and<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{is_integral_v<T>} is \tcode{true}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{\~{}T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                     bit_or<> binary_op) noexcept;
template<class T, class Abi>
  constexpr T reduce(const simd<T, Abi>& x, const typename simd<T, Abi>::mask_type& mask,
                     bit_xor<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{is_integral_v<T>} is \tcode{true}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T hmin(const simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T hmin(const simd<T, Abi>&, const typename simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{numeric_limits<T>::max()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T hmax(const simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$j$] < x[$i$]} is \tcode{false} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T hmax(const simd<T, Abi>&, const typename simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{numeric_limits<V::value_type>::lowest()}.
  Otherwise, returns the value of a selected element \tcode{x.data[$j$]} for which \tcode{x.data[$j$] < x.data[$i$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\rSec2[simd.casts]{Casts}

\begin{itemdecl}
template<size_t... Sizes, class T, class Abi>
  constexpr tuple<simd<T, simd_abi::deduce_t<T, Sizes>>...>
    split(const simd<T, Abi>& x) noexcept;
template<size_t... Sizes, class T, class Abi>
  constexpr tuple<simd_mask<T, simd_abi::deduce_t<T, Sizes>>...>
    split(const simd_mask<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{tuple} of data-parallel objects with the $i^\text{th}$ \tcode{simd}/\tcode{simd_mask} element of the $j^\text{th}$ \tcode{tuple} element initialized to the value of the element \tcode{x} with index $i$ + sum of the first $j$ values in the \tcode{Sizes} pack.

  \pnum\remarks
  These functions shall not participate in overload resolution unless the sum of all values in the \tcode{Sizes} pack is equal to \tcode{simd_size_v<T, Abi>}.
\end{itemdescr}

\begin{itemdecl}
template<class V, class Abi>
  constexpr array<V, simd_size_v<typename V::value_type, Abi> / V::size()>
    split(const simd<typename V::value_type, Abi>& x) noexcept;
template<class V, class Abi>
  constexpr array<V, simd_size_v<typename V::simd_type::value_type, Abi> / V::size()>
    split(const simd_mask<typename V::simd_type::value_type, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  An \tcode{array} of data-parallel objects with the $i^\text{th}$ \tcode{simd}/\tcode{simd_mask} element of the $j^\text{th}$ \tcode{array} element initialized to the value of the element in \tcode{x} with index \tcode{$i$ + $j$ * V::size()}.

  \pnum\remarks
  These functions shall not participate in overload resolution unless either:
  \begin{itemize}
    \item \tcode{is_simd_v<V>} is \tcode{true} and \tcode{simd_size_v<typename V::value_type, Abi>} is an integral multiple of \tcode{V::size()}, or
    \item \tcode{is_simd_mask_v<V>} is \tcode{true} and \tcode{simd_size_v<typename V::simd_type::value_type, Abi>} is an integral multiple of \tcode{V::size()}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<size_t N, class T, class A>
  constexpr array<resize_simd<simd_size_v<T, A> / N, simd<T, A>>, N>
    split_by(const simd<T, A>& x) noexcept;
template<size_t N, class T, class A>
  constexpr array<resize_simd<simd_size_v<T, A> / N, simd_mask<T, A>>, N>
    split_by(const simd_mask<T, A>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  An array \tcode{arr}, where \tcode{arr[$i$][$j$]} is initialized by \tcode{x[$i$ * (simd_size_v<T, A> / N) + $j$]}.

  \pnum\remarks
  The functions shall not participate in overload resolution unless \tcode{simd_size_v<T, A>} is an integral multiple of \tcode N.
\end{itemdescr}

\begin{itemdecl}
template<class T, class... Abis>
  constexpr simd<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>> concat(
    const simd<T, Abis>&... xs) noexcept;
template<class T, class... Abis>
  constexpr simd_mask<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>> concat(
    const simd_mask<T, Abis>&... xs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A data-parallel object initialized with the concatenated values in the \tcode{xs} pack of data-parallel objects: The $i^\text{th}$ \tcode{simd}/\tcode{simd_mask} element of the $j^\text{th}$ parameter in the \tcode{xs} pack is copied to the return value's element with index $i$ + the sum of the width of the first $j$ parameters in the \tcode{xs} pack.
\end{itemdescr}

\begin{itemdecl}
  template<class T, class Abi, size_t N>
    constexpr resize_simd<simd_size_v<T, Abi> * N, simd<T, Abi>>
      concat(const array<simd<T, Abi>, N>& arr) noexcept;
  template<class T, class Abi, size_t N>
    constexpr resize_simd<simd_size_v<T, Abi> * N, simd_mask<T, Abi>>
      concat(const array<simd_mask<T, Abi>, N>& arr) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A data-parallel object, the $i^\text{th}$ element of which is initialized by \tcode{arr[$i$ / simd_size_v<T, Abi>][$i$ \% simd_size_v<T, Abi>]}.
\end{itemdescr}

\rSec2[simd.alg]{Algorithms}

\begin{itemdecl}
template<class T, class Abi> constexpr simd<T, Abi> min(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr simd<T, Abi> max(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr pair<simd<T, Abi>, simd<T, Abi>> minmax(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  A \tcode{pair} initialized with
  \begin{itemize}
    \item the result of element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli{} in the \tcode{first} member, and
    \item the result of element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli{} in the \tcode{second} member.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> simd<T, Abi>
  constexpr clamp(const simd<T, Abi>& v, const simd<T, Abi>& lo, const simd<T, Abi>& hi);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\requires
  No element in \tcode{lo} shall be greater than the corresponding element in \tcode{hi}.

  \pnum\returns
  The result of element-wise application of \tcode{std::clamp(v[$i$], lo[$i$], hi[$i$])} \foralli.
\end{itemdescr}

\rSec2[simd.math]{\texorpdfstring{\tcode{simd} math}{simd math} library}

\pnum
For each set of overloaded functions within \tcode{<cmath>}, there shall be additional overloads sufficient to ensure that if any argument corresponding to a \tcode{double} parameter has type \tcode{simd<T, Abi>}, where \tcode{is_floating_point_v<T>} is \tcode{true}, then:
\begin{itemize}
  \item All arguments corresponding to \tcode{double} parameters shall be convertible to \tcode{simd<T, Abi>}.
  \item All arguments corresponding to \tcode{double*} parameters shall be of type \tcode{simd<T, Abi>*}.
  \item All arguments corresponding to parameters of integral type \tcode{U} shall be convertible to \tcode{fixed_size_simd<U, simd_size_v<T, Abi>>}.
  \item All arguments corresponding to \tcode{U*}, where \tcode{U} is integral, shall be of type \tcode{fixed_size_simd<U, simd_size_v<T, Abi>>*}.
  \item If the corresponding return type is \tcode{double}, the return type of the additional overloads is \tcode{simd<T, Abi>}. Otherwise, if the corresponding return type is \tcode{bool}, the return type of the additional overload is \tcode{simd_mask<T, Abi>}. Otherwise, the return type is \tcode{fixed_size_simd<R, simd_size_v<T, Abi>>}, with \tcode{R} denoting the corresponding return type.
\end{itemize}
It is unspecified whether a call to these overloads with arguments that are all convertible to \tcode{simd<T, Abi>} but are not of type \tcode{simd<T, Abi>} is well-formed.

\pnum
Each function overload produced by the above rules applies the indicated \tcode{<cmath>} function element-wise. For the mathematical functions, the results per element only need to be approximately equal to the application of the function which is overloaded for the element type.

\pnum
The result is unspecified if a domain, pole, or range error occurs when the input argument(s) are applied to the indicated \tcode{<cmath>} function.
\begin{note}Implementations are encouraged to follow the C specification (especially Annex F).\end{note}

\pnum
TODO: Allow \tcode{abs(simd<\textrm{signed-integral}>)}.

\pnum
If \tcode{abs} is called with an argument of type \tcode{simd<X, Abi>} for which \tcode{is_unsigned_v<X>} is \tcode{true}, the program is ill-formed.

\rSec1[simd.mask.class]{Class template \tcode{simd_mask}}

\rSec2[simd.mask.overview]{Class template \tcode{simd_mask} overview}

\begin{codeblock}
template<class T, class Abi> class simd_mask {
public:
  using value_type = bool;
  using reference = @\seebelow@;
  using simd_type = simd<T, Abi>;
  using abi_type = Abi;

  static constexpr typename simd_size<T, Abi>::type size;

  constexpr simd_mask() noexcept = default;

  // \ref{simd.mask.ctor}, \tcode{simd_mask} constructors
  constexpr explicit simd_mask(value_type) noexcept;
  template<class U, class UAbi>
    constexpr explicit(sizeof(U) != sizeof(T)) simd_mask(const simd_mask<U, UAbi>&) noexcept;
  template<class G> constexpr explicit simd_mask(G&& gen) noexcept;
  template<typename It, class Flags = element_aligned_tag>
    constexpr simd_mask(It first, Flags = {});
  template<typename It, class Flags = element_aligned_tag>
    constexpr simd_mask(It first, const simd_mask& mask, Flags = {});

  // \ref{simd.mask.copy}, \tcode{simd_mask} copy functions
  template<typename It, class Flags = element_aligned_tag>
    constexpr void copy_from(It first, Flags = {});
  template<typename It, class Flags = element_aligned_tag>
    constexpr void copy_from(It first, const simd_mask& mask, Flags = {});
  template<typename Out, class Flags = element_aligned_tag>
    constexpr void copy_to(Out first, Flags = {}) const;
  template<typename Out, class Flags = element_aligned_tag>
    constexpr void copy_to(Out first, const simd_mask& mask, Flags = {}) const;

  // \ref{simd.mask.subscr}, \tcode{simd_mask} subscript operators
  constexpr reference operator[](size_t) &;
  constexpr value_type operator[](size_t) const&;

  // \ref{simd.mask.unary}, \tcode{simd_mask} unary operators
  constexpr simd_mask operator!() const noexcept;
  constexpr simd_type operator+() const noexcept;
  constexpr simd_type operator-() const noexcept;
  constexpr simd_type operator~() const noexcept;

  // \ref{simd.mask.conv}, \tcode{simd_mask} conversion operators
  template <class U, class A>
    constexpr explicit(sizeof(U) != sizeof(T)) operator simd<U, A>() const noexcept;

  // \ref{simd.mask.binary}, \tcode{simd_mask} binary operators
  friend constexpr simd_mask operator&&(const simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask operator||(const simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask operator&(const simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask operator|(const simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask operator^(const simd_mask&, const simd_mask&) noexcept;

  // \ref{simd.mask.cassign}, \tcode{simd_mask} compound assignment
  friend constexpr simd_mask& operator&=(simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask& operator|=(simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask& operator^=(simd_mask&, const simd_mask&) noexcept;

  // \ref{simd.mask.comparison}, \tcode{simd_mask} comparisons
  friend constexpr simd_mask operator==(const simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask operator!=(const simd_mask&, const simd_mask&) noexcept;

  // \ref{simd.mask.cond}, \tcode{simd_mask} conditional operators
  friend constexpr simd_mask operator?:(const simd_mask&, const simd_mask&, const simd_mask&) noexcept;
  friend constexpr simd_mask operator?:(const simd_mask&, bool, bool) noexcept;
  template <class T0, class T1>
    friend constexpr simd<common_type_t<T0, T1>, Abi>
      operator?:(const simd_mask&, const T0&, const T1&) noexcept;
};
\end{codeblock}

\pnum
The class template \tcode{simd_mask} is a data-parallel type with the element type \tcode{bool}. The width of a given \tcode{simd_mask} specialization is a constant expression, determined by the template parameters. Specifically, \tcode{simd_mask<T, Abi>::size() == simd<T, Abi>::size()}.

\pnum
Every specialization of \tcode{simd_mask} is a complete type. The specialization \tcode{simd_mask<T, Abi>} is supported if \tcode{T} is a vectorizable type and
\begin{itemize}
  \item \tcode{Abi} is \tcode{simd_abi::scalar}, or
  \item \tcode{Abi} is \tcode{simd_abi::fixed_size<N>}, with \tcode{N} constrained as defined in (\ref{simd.abi}).
\end{itemize}

If \tcode{Abi} is an extended ABI tag, it is implementation-defined whether \tcode{simd_mask<T, Abi>} is supported. \begin{note}The intent is for implementations to decide on the basis of the currently targeted system.\end{note}

If \tcode{simd_mask<T, Abi>} is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
Otherwise, the following are true:
\begin{itemize}
  \item \tcode{is_nothrow_move_constructible_v<simd_mask<T, Abi>>}, and
  \item \tcode{is_nothrow_move_assignable_v<simd_mask<T, Abi>>}, and
  \item \tcode{is_nothrow_default_constructible_v<simd_mask<T, Abi>>}.
\end{itemize}

\pnum
Default initialization performs no intialization of the elements; value-initialization initializes each element with \tcode{false}. \begin{note}Thus, default initialization leaves the elements in an indeterminate state.\end{note}

\pnum
Implementations should enable explicit conversion from and to implementation-defined types. This adds one or more of the following declarations to class \tcode{simd_mask}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit simd_mask(const @\impdef@& init) const;
\end{codeblock}

\pnum
The member type \tcode{reference} has the same interface as \tcode{simd<T, Abi>::reference}, except its \tcode{value_type} is \tcode{bool}. (\ref{simd.reference})

\rSec2[simd.mask.width]{\tcode{simd_mask} width}

\begin{itemdecl}
static constexpr typename simd_size<T, Abi>::type size;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The width of \tcode{simd<T, Abi>}.
\end{itemdescr}

\rSec2[simd.mask.ctor]{\texorpdfstring{\tcode{simd_mask} constructors}{simd_mask constructors}}

\begin{itemdecl}
constexpr explicit simd_mask(value_type x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object with each element initialized to \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
template<class U, class UAbi>
  constexpr explicit(sizeof(U) != sizeof(T)) simd_mask(const simd_mask<U, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object of type \tcode{simd_mask} where the $i^\text{th}$ element equals \tcode{x[$i$]} \foralli.

  \pnum\remarks
  This constructor shall not participate in overload resolution unless \tcode{simd_size_v<U, UAbi> == size()}.
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit simd_mask(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object where the $i^\text{th}$ element is initialized to \tcode{gen(integral_constant<size_t, i>())}.

  \pnum\remarks
  This constructor shall not participate in overload resolution unless \tcode{static_cast<bool>(gen(integral_constant<size_t, i>()))} is well-formed \foralli.

  \pnum
  The calls to \tcode{gen} are unsequenced with respect to each other.
  Vectorization-unsafe standard library functions may not be invoked by \tcode{gen} (\ref{algorithms.parallel.exec}).
\end{itemdescr}

\newcommand\MaskLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{is_simd_flag_type_v<Flags>} is \tcode{true}, and
    \item \tcode{iter_value_t<It>} is of type \tcode{bool}, and
    \item \tcode{It} satisfies \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{It} models \tcode{contiguous_iterator}.
    \flagsRequires{simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr simd_mask(It first, Flags = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr simd_mask(It first, const simd_mask& mask, Flags = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{mask[$i$] ? first[$i$] : false} \foralli.}
\end{itemdescr}

\rSec2[simd.mask.copy]{\texorpdfstring{\tcode{simd_mask} copy}{simd_mask copy} functions}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr void copy_from(It first, Flags = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
  {\tcode{[first, first + size())} is a valid range.}
  {Replaces the elements of the \tcode{simd_mask} object such that the $i^\text{th}$ element is replaced with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class Flags = element_aligned_tag>
  constexpr void copy_from(It first, const simd_mask& mask, Flags = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{simd_mask} object such that the $i^\text{th}$ element is replaced with \tcode{first[$i$]} \forallmaskedi.}
\end{itemdescr}

\newcommand\MaskStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{is_simd_flag_type_v<Flags>} is \tcode{true}, and
    \item \tcode{iter_value_t<Out>} is of type \tcode{bool}, and
    \item \tcode{Out} satisfies \tcode{contiguous_iterator}, and
    \item \tcode{Out} satisfies \tcode{output_iterator<value_type>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{Out} models \tcode{contiguous_iterator}.
    \item \tcode{Out} models \tcode{output_iterator<value_type>}.
    \flagsRequires{simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename Out, class Flags = element_aligned_tag>
  constexpr void copy_to(Out first, Flags = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Copies all \tcode{simd_mask} elements as if \tcode{first[$i$] = operator[]($i$)} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename Out, class Flags = element_aligned_tag>
  constexpr void copy_to(Out first, const simd_mask& mask, Flags = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
  {\validMaskedRange}
  {Copies the selected elements as if \tcode{first[$i$] = operator[]($i$)} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.mask.subscr]{\texorpdfstring{\tcode{simd_mask} subscript}{simd_mask subscript} operators}

\begin{itemdecl}
constexpr reference operator[](size_t i) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  \tcode{i < size()}.

  \pnum\returns
  A \tcode{reference} (see \ref{simd.reference}) referring to the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
constexpr value_type operator[](size_t i) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  \tcode{i < size()}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.mask.unary]{\texorpdfstring{\tcode{simd_mask}}{simd_mask} unary operators}

\begin{itemdecl}
constexpr simd_mask operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The result of the element-wise appliation of \tcode{operator!}.
\end{itemdescr}

\begin{itemdecl}
constexpr simd_type operator+() const noexcept;
constexpr simd_type operator-() const noexcept;
constexpr simd_type operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  Application of the indicated unary operator to objects of type \tcode{T} is well-formed.

  \pnum\returns
  The result of applying the indicated operator to \tcode{static_cast<simd_type>(*this)}.
\end{itemdescr}

\rSec2[simd.mask.conv]{\texorpdfstring{\tcode{simd_mask}}{simd_mask} conversion operators}

\begin{itemdecl}
template <class U, class A>
  constexpr explicit(sizeof(U) != sizeof(T)) operator simd<U, A>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{simd_size_v<U, A> == simd_size_v<T, Abi>}.

  \pnum\returns
  An object where the $i^\text{th}$ element is initialized to \tcode{static_cast<U>(operator[]($i$))}.
\end{itemdescr}

\rSec1[simd.mask.nonmembers]{Non-member operations}

\rSec2[simd.mask.binary]{\texorpdfstring{\tcode{simd_mask} binary}{simd_mask binary} operators}

\begin{itemdecl}
friend constexpr simd_mask operator&&(const simd_mask& lhs, const simd_mask& rhs) noexcept;
friend constexpr simd_mask operator||(const simd_mask& lhs, const simd_mask& rhs) noexcept;
friend constexpr simd_mask operator& (const simd_mask& lhs, const simd_mask& rhs) noexcept;
friend constexpr simd_mask operator| (const simd_mask& lhs, const simd_mask& rhs) noexcept;
friend constexpr simd_mask operator^ (const simd_mask& lhs, const simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cassign]{\texorpdfstring{\tcode{simd_mask} compound}{simd_mask compound} assignment}

\begin{itemdecl}
friend constexpr simd_mask& operator&=(simd_mask& lhs, const simd_mask& rhs) noexcept;
friend constexpr simd_mask& operator|=(simd_mask& lhs, const simd_mask& rhs) noexcept;
friend constexpr simd_mask& operator^=(simd_mask& lhs, const simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\rSec2[simd.mask.comparison]{\texorpdfstring{\tcode{simd_mask} comparisons}{simd_mask comparisons}}

\begin{itemdecl}
friend constexpr simd_mask operator==(const simd_mask&, const simd_mask&) noexcept;
friend constexpr simd_mask operator!=(const simd_mask&, const simd_mask&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cond]{\texorpdfstring{\tcode{simd_mask}}{simd_mask} conditional operators}

\begin{itemdecl}
friend constexpr simd operator?:(const simd_mask& mask, const simd_mask& a, const simd_mask& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] : b[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
friend constexpr simd_mask operator?:(const simd_mask& mask, bool a, bool b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T0, class T1>
  friend constexpr simd<common_type_t<T0, T1>, Abi>
    operator?:(const simd_mask& mask, const T0& a, const T1& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{U} be the type \tcode{common_type_t<T0, T1>}.
  \pnum\constraints
  \begin{itemize}
    \item \tcode{U} is a vectorizable type, and
    \item \tcode{sizeof(U) == sizeof(T)}, and
    \item \tcode{T0} satisfies \tcode{convertible_to<simd<U, Abi>>}, and
    \item \tcode{T1} satisfies \tcode{convertible_to<simd<U, Abi>>}.
  \end{itemize}

  \pnum\returns
  A \tcode{simd} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b} \foralli.
\end{itemdescr}

\rSec2[simd.mask.reductions]{\texorpdfstring{\tcode{simd_mask} reductions}{simd_mask reductions}}

\begin{itemdecl}
template<class T, class Abi> constexpr bool all_of(const simd_mask<T, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if all boolean elements in \tcode{k} are \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr bool any_of(const simd_mask<T, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if at least one boolean element in \tcode{k} is \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr bool none_of(const simd_mask<T, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if none of the one boolean elements in \tcode{k} is \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr int reduce_count(const simd_mask<T, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The number of boolean elements in \tcode{k} that are \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr int reduce_min_index(const simd_mask<T, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  \tcode{any_of(k)} returns \tcode{true}.

  \pnum\returns
  The lowest element index $i$ where \tcode{k[$i$]} is \tcode{true}.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr int reduce_max_index(const simd_mask<T, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  \tcode{any_of(k)} returns \tcode{true}.

  \pnum\returns
  The greatest element index $i$ where \tcode{k[$i$]} is \tcode{true}.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
constexpr bool all_of(@\UNSP{T}@) noexcept;
constexpr bool any_of(@\UNSP{T}@) noexcept;
constexpr bool none_of(@\UNSP{T}@) noexcept;
constexpr int reduce_count(@\UNSP{T}@) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{all_of} and \tcode{any_of} return their arguments; \tcode{none_of} returns the negation of its argument; \tcode{reduce_count} returns the integral representation of its argument.

  \pnum\remarks
  The parameter type \tcode{T} is an unspecified type that is only constructible via implicit conversion from \tcode{bool}.
\end{itemdescr}

\begin{itemdecl}
constexpr int reduce_min_index(@\UNSP{T}@);
constexpr int reduce_max_index(@\UNSP{T}@);
\end{itemdecl}

\begin{itemdescr}
  \pnum\requires
  The value of the argument is \tcode{true}.

  \pnum\returns
  \tcode{0}.

  \pnum\throws Nothing.

  \pnum\remarks
  The parameter type \tcode{T} is an unspecified type that is only constructible via implicit conversion from \tcode{bool}.
\end{itemdescr}

% vim: tw=0
