\def\rSec#1[#2]#3{%
  \ifcase#1\wgSubsection[subsection]{#3}{#2}
  \or\wgSubsubsection[subsubsection]{#3}{#2}
  \or\wgSubsubsubsection[paragraph]{#3}{#2}
  \or\error
\fi}

\renewcommand\foralli[1][]{for all $i$ in the range of \tcode{[0, #1size())}}
%\renewcommand\forallmaskedi{for all selected indices $i$}

\newcommand\validMaskedRange[1][first]{For all selected indices $i$,
\tcode{[#1, #1 + $i$)} is a valid range.}

\newcommand\flagsRequires[2]{
\item If the template parameter pack \tcode{Flags} contains the type
  identifying \tcode{simd_flag_aligned}, \tcode{addressof(*first)} shall
  point to storage aligned by \tcode{simd_alignment_v<#1>}.
\item If the template parameter pack \tcode{Flags} contains the type
  identifying \tcode{simd_flag_overaligned<N>}, \tcode{addressof(*first)}
  shall point to storage aligned by \tcode{N}.
}

\newcommand\conversionFlagsMandate[2]{
  If the template parameter pack \tcode{Flags} does not contain the type
  identifying \tcode{simd_flag_convert}, then the conversion from \tcode{#1} to
  \tcode{#2} is value-preserving.
}

\newcommand\ConstraintOperatorTWellFormed[1][the indicated operator]{%
\constraints Application of #1 to objects of type \tcode{value_type} is well-formed.
}

\rSec0[simd]{Data-Parallel Types}
\rSec1[simd.general]{General}

\pnum
The simd subclause defines data-parallel types and operations on these types. A data-parallel type consists of elements of an underlying vectorizable type, called the \defn{element type}. The number of elements is a constant for each data-parallel type and called the \defn{width} of that type.

\pnum
The term \defn{data-parallel type} refers to all \defn{supported} (\ref{simd.overview}) specializations of the \tcode{basic_simd} and \tcode{basic_simd_mask} class templates. A \defn{data-parallel object} is an object of \term{data-parallel type}.

\pnum
The set of \defn{vectorizable types} comprises all cv-unqualified arithmetic types other than \tcode{bool} and \tcode{long double}.

\pnum
An \defn{element-wise operation} applies a specified operation to the elements of one or more data-parallel objects. Each such application is unsequenced with respect to the others. A \defn{unary element-wise operation} is an element-wise operation that applies a unary operation to each element of a data-parallel object. A \defn{binary element-wise operation} is an element-wise operation that applies a binary operation to corresponding elements of two data-parallel objects.

\pnum
Given a \tcode{basic_simd_mask<Bytes, Abi>} object \tcode{mask},
the \defn{selected indices} signify the integers $i \in \{j \in \mathbb{N}_0 | j < \tcode{mask.size()} \wedge \tcode{mask[}j\tcode{]}\}$.
Given an additional object \tcode{data} of type \tcode{basic_simd<T, Abi>} or \tcode{basic_simd_mask<Bytes, Abi>},
the \defn{selected elements} signify the elements \tcode{data[$i$]} for all selected indices $i$.

\pnum
The conversion from vectorizable type \tcode{U} to vectorizable type \tcode{T} is \defn{value-preserving} if
all possible values of \tcode{U} can be represented with type \tcode{T}.

\pnum
\begin{note}
The intent is to support acceleration through data-parallel execution resources, such as SIMD registers and instructions or execution units driven by a common instruction decoder. If such execution resources are unavailable, the interfaces support a transparent fallback to sequential execution.
\end{note}

\rSec1[simd.syn]{Header \texorpdfstring{\tcode{<simd>}}{<simd>} synopsis}

\newcommand\nativeabi{\UNSP{native-abi}}
\newcommand\deducet{\UNSP{deduce-t}}
\newcommand\simdsizetype{\UNSP{simd-size-type}}
\newcommand\simdselect{\UNSP{simd-select-impl}}
\newcommand\maskelementsize{\UNSP{mask-element-size}}
\newcommand\integerfrom{\UNSP{integer-from}}

%\indexhdr{simd}
\begin{codeblock}
namespace std {
  using @\simdsizetype@ = @\seebelow@; // \expos
  template <typename T> constexpr size_t @\maskelementsize@ = @\seebelow@; // \expos
  template <size_t Bytes> using @\integerfrom@ = @\seebelow@; // \expos

  // \ref{simd.abi}, \tcode{simd} ABI tags
  template<class T> using @\nativeabi@ = @\seebelow@; // \expos
  template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@; // \expos

  // \ref{simd.traits}, \tcode{simd} type traits
  template<class T, class U = typename T::value_type> struct simd_alignment;
  template<class T, class U = typename T::value_type>
    inline constexpr size_t simd_alignment_v = simd_alignment<T,U>::value;

  template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
  template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
  template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
  template<@\simdsizetype@ N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

  // \ref{simd.flags}, Load and store flags
  template <class... Flags> struct simd_flags;
  inline constexpr simd_flags<> simd_flag_default{};
  inline constexpr simd_flags<@\seebelow@> simd_flag_convert{};
  inline constexpr simd_flags<@\seebelow@> simd_flag_aligned{};
  template<size_t N> requires (has_single_bit(N))
    inline constexpr simd_flags<@\seebelow@> simd_flag_overaligned{};

  // \ref{simd.class}, Class template \tcode{basic_simd}
  template<class T, class Abi = @\nativeabi@<T>> class basic_simd;
  template<class T, @\simdsizetype@ N = basic_simd<T>::size()>
    using simd = basic_simd<T, @\deducet@<T, N>>;

  // \ref{simd.mask.class}, Class template \tcode{basic_simd_mask}
  template<size_t Bytes, class Abi = @\nativeabi@<T>> class basic_simd_mask;
  template<class T, @\simdsizetype@ N = basic_simd_mask<sizeof(T)>::size()>
    using simd_mask = basic_simd_mask<sizeof(T), @\deducet@<T, N>>;

  // \ref{simd.creation}, \tcode{basic_simd} and \tcode{basic_simd_mask} creation
  template<class V, class Abi>
    constexpr auto
      simd_split(const basic_simd<typename V::value_type, Abi>& x) noexcept;
  template<class M, class Abi>
    constexpr auto
      simd_split(const basic_simd_mask<@\maskelementsize@<M>, Abi>& x) noexcept;

  template<class T, class... Abis>
    constexpr basic_simd<T, @\deducet@<T, (basic_simd<T, Abis>::size + ...)>>
      simd_cat(const basic_simd<T, Abis>&...) noexcept;
  template<size_t Bytes, class... Abis>
    constexpr constexpr basic_simd_mask<Bytes, @\deducet@<@\integerfrom@<Bytes>, (basic_simd_mask<Bytes, Abis>::size() + ...)>>
      simd_cat(const basic_simd_mask<Bytes, Abis>&...) noexcept;

  // \ref{simd.mask.reductions}, \tcode{basic_simd_mask} reductions
  template<size_t Bytes, class Abi> constexpr bool all_of(const basic_simd_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi> constexpr bool any_of(const basic_simd_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi> constexpr bool none_of(const basic_simd_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi> constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bytes, Abi>&) noexcept;
  template<size_t Bytes, class Abi> constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bytes, Abi>&);
  template<size_t Bytes, class Abi> constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bytes, Abi>&);

  constexpr bool all_of(@\UNSP{T}@) noexcept;
  constexpr bool any_of(@\UNSP{T}@) noexcept;
  constexpr bool none_of(@\UNSP{T}@) noexcept;
  constexpr @\simdsizetype@ reduce_count(@\UNSP{T}@) noexcept;
  constexpr @\simdsizetype@ reduce_min_index(@\UNSP{T}@);
  constexpr @\simdsizetype@ reduce_max_index(@\UNSP{T}@);

  // \ref{simd.reductions}, \tcode{basic_simd} reductions
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(const basic_simd<T, Abi>&, BinaryOperation = {});

  template<class T, class Abi, class BinaryOperation>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       T identity_element, BinaryOperation binary_op);
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       plus<> binary_op = {}) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       multiplies<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       bit_and<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       bit_or<> binary_op) noexcept;
  template<class T, class Abi>
    constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                       bit_xor<> binary_op) noexcept;

  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;

  // \ref{simd.alg}, Algorithms
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
      minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      clamp(const basic_simd<T, Abi>& v,
            const basic_simd<T, Abi>& lo,
            const basic_simd<T, Abi>& hi);

  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b) -> remove_cvref_t<decltype(c ? a : b)>;
  template<size_t Bytes, class Abi, typename T, typename U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b);
}
\end{codeblock}

\pnum
The header \tcode{<simd>} defines class templates, tag types, trait types, and function templates for element-wise operations on data-parallel objects.

\pnum
\simdsizetype is an exposition-only alias for a signed integer type.

\pnum
\tcode{\maskelementsize<basic_simd_mask<Bytes, Abi>>} has the value \tcode{Bytes}.

\pnum
\tcode{\integerfrom<Bytes>} is an alias for a signed integer type \tcode{T} so that \tcode{sizeof(T) == Bytes}.

\rSec1[simd.abi]{\tcode{simd} ABI tags}

\begin{codeblock}
template<class T> using @\nativeabi@ = @\seebelow@; // \expos
template<class T, size_t N> using @\deducet@ = @\seebelow@; // \expos
\end{codeblock}

\pnum
An \defn{ABI tag} is a type that indicates a choice of size and binary
representation for objects of data-parallel type.
\begin{note}
  The intent is for the size and binary representation to depend on the target
  architecture.
\end{note}
The ABI tag, together with a given element type implies a number of elements.
ABI tag types are used as the second template argument to \tcode{basic_simd}
and \tcode{basic_simd_mask}.

\pnum
\begin{note}
The ABI tag is orthogonal to selecting the machine instruction set.
The selected machine instruction set limits the usable ABI tag types, though
(see \ref{simd.overview}).
The ABI tags enable users to safely pass objects of data-parallel type between
translation unit boundaries (e.g. function calls or I/O).
\end{note}

\pnum
An implementation defines ABI tag types as necessary for the following
exposition-only aliases.

\pnum
The exposition-only alias \tcode{\deducet<T, N>} results in a substitution
failure if
\begin{itemize}
  \item \tcode{T} is not a vectorizable type, or
  \item \tcode{N} is larger than an implementation-defined maximum.
\end{itemize}
The implementation-defined maximum for \tcode{N} is no smaller than 64.

\pnum
Where present, the exposition-only alias \tcode{\deducet<T, N>} names an ABI
tag type that satisfies
\begin{itemize}
  \item \tcode{basic_simd<T, \deducet<T, N>>::size == N}, and
  \item \tcode{basic_simd<T, \deducet<T, N>>} is default constructible (see \ref{simd.overview}).
\end{itemize}

%\pnum TODO???
%\begin{note}
%The value of \tcode{max_fixed_size<T>} can depend on compiler flags and can
%change between different compiler versions.
%\end{note}

\pnum
\tcode{\nativeabi<T>} is an implementation-defined alias for an ABI tag.
\begin{note}
The intent is to use the ABI tag producing the most efficient data-parallel
execution for the element type \tcode{T} that is supported on the currently
targeted system.
For target architectures with ISA extensions, compiler flags may change the
type of the \tcode{\nativeabi<T>} alias.
\end{note}
\begin{example}
  Consider a target architecture supporting the ABI tags
  \tcode{__simd128} and \tcode{__simd256}, where hardware support for
  \tcode{__simd256} only exists for floating-point types.
  The implementation therefore defines \tcode{\nativeabi<T>} as an alias for
  \begin{itemize}
    \item \tcode{__simd256} if \tcode{T} is a floating-point type, and
    \item \tcode{__simd128} otherwise.
  \end{itemize}
\end{example}

\pnum
The type of \tcode{\deducet<T, N>} in TU1 differs from the type of
\tcode{\deducet<T, N>} in TU2 iff the type of \tcode{\nativeabi<T>} in TU1
differs from the type of \tcode{\nativeabi<T>} in TU2.

\rSec1[simd.traits]{\tcode{simd} type traits}

\begin{itemdecl}
template<class T, class U = typename T::value_type> struct simd_alignment { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{simd_alignment<T, U>} shall have a member \tcode{value} if and only if
\begin{itemize}
  \item \tcode{T} is a specialization of \tcode{basic_simd_mask} and \tcode{U} is \tcode{bool}, or
  \item \tcode{T} is a specialization of \tcode{basic_simd} and \tcode{U} is a vectorizable type.
\end{itemize}

\pnum
If \tcode{value} is present, the type \tcode{simd_alignment<T, U>} is a \tcode{BinaryTypeTrait} with a base characteristic of \tcode{integral_constant<size_t, N>} for some implementation-defined \tcode{N} (see \ref{simd.copy} and \ref{simd.mask.copy}). \begin{note}\tcode{value} identifies the alignment restrictions on pointers used for (converting) loads and stores for the give type \tcode{T} on arrays of type \tcode{U}.\end{note}

\pnum
The behavior of a program that adds specializations for \tcode{simd_alignment} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is either \tcode{basic_simd<U, Abi0>} or \tcode{basic_simd_mask<UBytes, Abi0>}, where \tcode{U}, \tcode{UBytes}, and \tcode{Abi0} are deduced from \tcode{V}, and
    \item \tcode{T} is a vectorizable type, and
    \item \tcode{simd_abi::deduce<T, basic_simd<U, Abi0>::size, Abi0>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote the type \tcode{deduce_t<T, basic_simd<U, Abi0>::size, Abi0>}.
  Where present, the member typedef \tcode{type} names
  \tcode{basic_simd<T, Abi1>} if \tcode V is \tcode{basic_simd<U, Abi0>} or
  \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is \tcode{basic_simd_mask<UBytes, Abi0>}.
\end{itemdescr}

\begin{itemdecl}
template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is either \tcode{basic_simd<T, Abi0>} or \tcode{basic_simd_mask<Bytes, Abi0>}, where \tcode T, \tcode{Bytes}, and \tcode{Abi0} are deduced from \tcode V, and
    \item \tcode{simd_abi::deduce<T, N, Abi0>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  Let \tcode{Abi1} denote the type \tcode{deduce_t<T, N, Abi0>}.
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T, Abi1>} if \tcode V is \tcode{basic_simd<T, Abi0>} or \tcode{basic_simd_mask<Bytes, Abi1>} if \tcode V is \tcode{basic_simd_mask<Bytes, Abi0>}.
\end{itemdescr}

\rSec1[simd.flags]{Load and store flags}

\begin{itemdecl}
inline constexpr simd_flags<@\seebelow@> simd_flag_convert{};
inline constexpr simd_flags<@\seebelow@> simd_flag_aligned{};
template<size_t N> requires (has_single_bit(N))
  inline constexpr simd_flags<@\seebelow@> simd_flag_overaligned{};
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The template arguments to \tcode{simd_flags} are unspecified types used
  by the implementation to identify the different load and store flags.

  \pnum
  There may be additional implementation-defined load and store flags.
\end{itemdescr}

\rSec2[simd.flags.overview]{Class template \tcode{simd_flags} overview}

\begin{codeblock}
template <class... Flags> struct simd_flags {
  // \ref{simd.flags.oper}, \tcode{simd_flags} operators
  template <class... Other>
    friend consteval auto operator|(simd_flags, simd_flags<Other...>);
};
\end{codeblock}

\pnum
The class template \tcode{simd_flags} acts like a integer bit-flag for types.

\pnum\constraints
Every type in \code{Flags} is a valid template argument to one of
\code{simd_flag_convert}, \tcode{simd_flag_aligned},
\tcode{simd_flag_overaligned}, or to one of the implementation-defined load and
store flags.

\rSec2[simd.flags.oper]{\tcode{simd_flags} operators}

\begin{itemdecl}
template <class... Other>
  friend consteval auto operator|(simd_flags a, simd_flags<Other...> b);
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A specialization of \tcode{simd_flags} identifying all load and
  store flags identified either by \tcode{a} or \tcode{b}.
\end{itemdescr}

\rSec1[simd.class]{Class template \tcode{basic_simd}}

\rSec2[simd.overview]{Class template \tcode{basic_simd} overview}

\begin{codeblock}
template<class T, class Abi> class basic_simd {
public:
  using value_type = T;
  using reference = @\seebelow@;
  using mask_type = basic_simd_mask<sizeof(T), Abi>;
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\seebelow@> size;

  constexpr basic_simd() noexcept = default;

  // \ref{simd.ctor}, \tcode{basic_simd} constructors
  template<class U> constexpr basic_simd(U&& value) noexcept;
  template<class U, class UAbi>
    constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
  template<typename It, class... Flags>
    constexpr basic_simd(It first, simd_flags<Flags...> = {});
  template<typename It, class... Flags>
    constexpr basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});

  // \ref{simd.copy}, \tcode{basic_simd} copy functions
  template<typename It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> f = {});
  template<typename It, class... Flags>
    constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
  template<typename Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
  template<typename Out, class... Flags>
    constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;

  // \ref{simd.subscr}, \tcode{basic_simd} subscript operators
  constexpr reference operator[](@\simdsizetype@) &;
  constexpr value_type operator[](@\simdsizetype@) const&;

  // \ref{simd.unary}, \tcode{basic_simd} unary operators
  constexpr basic_simd& operator++() noexcept;
  constexpr basic_simd operator++(int) noexcept;
  constexpr basic_simd& operator--() noexcept;
  constexpr basic_simd operator--(int) noexcept;
  constexpr mask_type operator!() const noexcept;
  constexpr basic_simd operator~() const noexcept;
  constexpr basic_simd operator+() const noexcept;
  constexpr basic_simd operator-() const noexcept;

  // \ref{simd.binary}, \tcode{basic_simd} binary operators
  friend constexpr basic_simd operator+(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator-(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator*(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator/(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator%(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator&(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator|(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator^(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.cassign}, \tcode{basic_simd} compound assignment
  friend constexpr basic_simd& operator+=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator-=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator*=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator/=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator%=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator&=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator|=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator^=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator<<=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator>>=(basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd& operator<<=(basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd& operator>>=(basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.comparison}, \tcode{basic_simd} compare operators
  friend constexpr mask_type operator==(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator!=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<(const basic_simd&, const basic_simd&) noexcept;

  // \ref{simd.cond}, \tcode{basic_simd} conditional operators
  friend constexpr basic_simd @\simdselect@(const mask_type&, const basic_simd&, const basic_simd&) noexcept;
};
\end{codeblock}

\pnum
The class template \tcode{basic_simd} is a data-parallel type. The width of a given \tcode{basic_simd} specialization is a constant expression, determined by the template parameters.

\pnum
Every specialization of \tcode{basic_simd} is a complete type. The specialization \tcode{basic_simd<T, Abi>} is supported if \tcode{T} is a vectorizable type and
\begin{itemize}
  \item \tcode{Abi} is \tcode{simd_abi::scalar}, or
  \item \tcode{Abi} is \tcode{simd_abi::fixed_size<N>}, with \tcode{N} constrained as defined in \ref{simd.abi}.
\end{itemize}

It is implementation-defined whether \tcode{basic_simd<T, Abi>} is supported.
\begin{note}
The intent is for implementations to decide on the basis of the currently
targeted system.
\end{note}

If \tcode{basic_simd<T, Abi>} is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
Otherwise, the following are true:
\begin{itemize}
  \item \tcode{is_nothrow_move_constructible_v<basic_simd<T, Abi>>}, and
  \item \tcode{is_nothrow_move_assignable_v<basic_simd<T, Abi>>}, and
  \item \tcode{is_nothrow_default_constructible_v<basic_simd<T, Abi>>}.
\end{itemize}

\begin{example}
  Consider an implementation that defines the ABI tags \tcode{__simd_x} and \tcode{__gpu_y}. When the compiler is invoked to translate to a machine that has support for the \tcode{__simd_x} ABI tag for all arithmetic types other than \tcode{long double} and no support for the \tcode{__gpu_y} ABI tag, then:
  \begin{itemize}
    \item \tcode{basic_simd<T, simd_abi::__gpu_y>} is not supported for any \tcode{T} and has a deleted constructor.
    \item \tcode{basic_simd<long double, simd_abi::__simd_x>} is not supported and has a deleted constructor.
    \item \tcode{basic_simd<double, simd_abi::__simd_x>} is supported.
    \item \tcode{basic_simd<long double, simd_abi::scalar>} is supported.
  \end{itemize}
\end{example}

\pnum
Default initialization performs no initialization of the elements;
value-initialization initializes each element with \tcode{T()}.
\begin{note}Thus, default initialization leaves the elements in an indeterminate state.\end{note}

\pnum
Implementations should enable explicit conversion from and to implementation-defined types. This adds one or more of the following declarations to class \tcode{basic_simd}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit basic_simd(const @\impdef@& init);
\end{codeblock}

\begin{example}
  Consider an implementation that supports the type \tcode{__vec4f} and the function \tcode{__vec4f _vec4f_addsub(__vec4f, __vec4f)} for the currently targeted system.
  A user may require the use of \tcode{_vec4f_addsub} for maximum performance and thus writes:
  \begin{codeblock}
    using V = basic_simd<float, simd_abi::__simd128>;
    V addsub(V a, V b) {
      return static_cast<V>(_vec4f_addsub(static_cast<__vec4f>(a), static_cast<__vec4f>(b)));
    }
  \end{codeblock}
\end{example}

\rSec2[simd.width]{\tcode{basic_simd} width}

\begin{itemdecl}
static constexpr integral_constant<@\simdsizetype@, @\seebelow@> size;
\end{itemdecl}

\begin{itemdescr}
    \pnum \tcode{size} is an \tcode{integral_constant<@\simdsizetype@, N>} with \tcode{N} equal to the number of elements in a \tcode{basic_simd} object.
    \pnum \begin{note}This member is present even if the particular \tcode{basic_simd} specialization is not supported.\end{note}
\end{itemdescr}

\rSec2[simd.reference]{Element references}

\pnum
A \tcode{reference} is an object that refers to an element in a \tcode{basic_simd} or \tcode{basic_simd_mask} object. \tcode{reference::value_type} is the same type as \tcode{simd::value_type} or \tcode{simd_mask::value_type}, respectively.

\pnum
Class \tcode{reference} is for exposition only. An implementation is permitted to provide equivalent functionality without providing a class with this name.

\begin{codeblock}
class reference // \expos
{
public:
  reference() = delete;
  reference(const reference&) = delete;

  constexpr operator value_type() const noexcept;

  template<class U> constexpr reference operator=(U&& x) && noexcept;

  template<class U> constexpr reference operator+=(U&& x) && noexcept;
  template<class U> constexpr reference operator-=(U&& x) && noexcept;
  template<class U> constexpr reference operator*=(U&& x) && noexcept;
  template<class U> constexpr reference operator/=(U&& x) && noexcept;
  template<class U> constexpr reference operator%=(U&& x) && noexcept;
  template<class U> constexpr reference operator|=(U&& x) && noexcept;
  template<class U> constexpr reference operator&=(U&& x) && noexcept;
  template<class U> constexpr reference operator^=(U&& x) && noexcept;
  template<class U> constexpr reference operator<<=(U&& x) && noexcept;
  template<class U> constexpr reference operator>>=(U&& x) && noexcept;

  constexpr reference operator++() && noexcept;
  constexpr value_type operator++(int) && noexcept;
  constexpr reference operator--() && noexcept;
  constexpr value_type operator--(int) && noexcept;

  friend constexpr void swap(reference&& a, reference&& b) noexcept;
  friend constexpr void swap(value_type& a, reference&& b) noexcept;
  friend constexpr void swap(reference&& a, value_type& b) noexcept;
};
\end{codeblock}

\begin{itemdecl}
constexpr operator value_type() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The value of the element referred to by \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
template<class U> constexpr reference operator=(U&& x) && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{declval<value_type\&>() = std\colcol{}forward<U>(x)} is well-formed.

  \pnum\effects
  Replaces the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask} with \tcode{static_cast<value_type>(std\colcol{}forward<U>(x))}.

  \pnum\returns
  A copy of \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
template<class U> constexpr reference operator+=(U&& x) && noexcept;
template<class U> constexpr reference operator-=(U&& x) && noexcept;
template<class U> constexpr reference operator*=(U&& x) && noexcept;
template<class U> constexpr reference operator/=(U&& x) && noexcept;
template<class U> constexpr reference operator%=(U&& x) && noexcept;
template<class U> constexpr reference operator|=(U&& x) && noexcept;
template<class U> constexpr reference operator&=(U&& x) && noexcept;
template<class U> constexpr reference operator^=(U&& x) && noexcept;
template<class U> constexpr reference operator<<=(U&& x) && noexcept;
template<class U> constexpr reference operator>>=(U&& x) && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{declval<value_type\&>() @= std\colcol{}forward<U>(x)} (where \tcode{@=} denotes the indicated compound assignment operator) is well-formed.

  \pnum\effects
  Applies the indicated compound operator to the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask} and \tcode{std\colcol{}forward<U>(x)}.

  \pnum\returns
  A copy of \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr reference operator++() && noexcept;
constexpr reference operator--() && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  The indicated operator can be applied to objects of type \tcode{value_type}.

  \pnum\effects
  Applies the indicated operator to the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask}.

  \pnum\returns
  A copy of \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr value_type operator++(int) && noexcept;
constexpr value_type operator--(int) && noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\remarks
  The indicated operator can be applied to objects of type \tcode{value_type}.

  \pnum\effects
  Applies the indicated operator to the referred to element in \tcode{basic_simd} or \tcode{basic_simd_mask}.

  \pnum\returns
  A copy of the referred to element before applying the indicated operator.
\end{itemdescr}

\begin{itemdecl}
friend constexpr void swap(reference&& a, reference&& b) noexcept;
friend constexpr void swap(value_type& a, reference&& b) noexcept;
friend constexpr void swap(reference&& a, value_type& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Exchanges the values \tcode{a} and \tcode{b} refer to.
\end{itemdescr}

\rSec2[simd.ctor]{\tcode{basic_simd} constructors}

\begin{itemdecl}
template<class U> constexpr basic_simd(U&&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{From} denote the type \code{remove_cvref_t<U>}.

  \pnum\constraints
  \begin{itemize}
    \item \tcode{From} is a vectorizable type and the conversion from
      \tcode{From} to \tcode{value_type} is value-preserving, or

    \item \tcode{From} is not an arithmetic type and is implicitly convertible
      to \tcode{value_type}.
  \end{itemize}

  \pnum\effects
  Constructs an object with each element initialized to the value of the argument after conversion to \tcode{value_type}.
\end{itemdescr}

\begin{itemdecl}
template<class U, class UAbi> constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{basic_simd<U, UAbi>::size == size()}.

  \pnum\effects
  Constructs an object where the $i^\text{th}$ element equals \tcode{static_cast<T>(x[$i$])} \foralli.

  \pnum\remarks
  The constructor is \tcode{explicit}
  \begin{itemize}
    \item if the conversion from \tcode{U} to \tcode{value_type} is not
      value-preserving, or

    \item if both \tcode{U} and \tcode{value_type} are integral types and the
      integer conversion rank (\iref{conv.rank}) of \tcode{U} is greater than
      the integer conversion rank of \tcode{value_type}, or

    \item if both \tcode{U} and \tcode{value_type} are floating-point types and
      the floating-point conversion rank (\iref{conv.rank}) of \tcode{U} is
      greater than the floating-point conversion rank of \tcode{value_type}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr basic_simd(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{basic_simd(gen(integral_constant<size_t, i>()))} is well-formed \foralli.

  \pnum\effects
  Constructs an object where the $i^\text{th}$ element is initialized to \tcode{gen(integral_constant<size_t, i>())}.

  \pnum
    The calls to \tcode{gen} are unsequenced with respect to each other. Vectorization-unsafe standard library functions may not be invoked by \tcode{gen} (\iref{algorithms.parallel.exec}). \tcode{gen} is invoked exactly once for each $i$.
\end{itemdescr}

\newcommand\SimdLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is a vectorizable type, and
    \item \tcode{It} satisfies \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{iter_value_t<It>}{value_type}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{It} models \tcode{contiguous_iterator}.
    \flagsRequires{basic_simd, iter_value_t<It>}{iter_value_t<It>}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr basic_simd(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{static_cast<T>(first[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{mask[$i$] ? static_cast<T>(first[$i$]) : T()} \foralli.}
\end{itemdescr}

\rSec2[simd.copy]{\tcode{basic_simd} copy functions}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Replaces the elements of the \tcode{basic_simd} object such that the $i^\text{th}$ element is assigned with \tcode{static_cast<T>(first[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd} object such that the $i^\text{th}$ element is replaced with \tcode{static_cast<T>(first[$i$])} \forallmaskedi.}
\end{itemdescr}

\newcommand\SimdStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is a vectorizable type, and
    \item \tcode{Out} satisfies \tcode{contiguous_iterator}, and
    \item \tcode{Out} satisfies \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{value_type}{iter_value_t<Out>}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{Out} models \tcode{contiguous_iterator}.
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
    \flagsRequires{basic_simd, iter_value_t<Out>}{iter_value_t<Out>}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Copies all \tcode{basic_simd} elements as if \tcode{first[$i$] = static_cast<iter_value_t<Out>>(operator[]($i$))} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename Out, class... Flags>
  constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\validMaskedRange}
    {Copies the selected elements as if \tcode{first[$i$] = static_cast<iter_value_t<Out>>(operator[]($i$))} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.subscr]{\tcode{basic_simd} subscript operators}

\begin{itemdecl}
constexpr reference operator[](@\simdsizetype@ i) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i < size()}.

  \pnum\returns
  A \tcode{reference} (see \ref{simd.reference}) referring to the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i < size()}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.unary]{\tcode{basic_simd} unary operators}

\pnum
Effects in this subclause are applied as unary element-wise operations.

\begin{itemdecl}
constexpr basic_simd& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{++}]

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{++}]

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  A copy of \tcode{*this} before incrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{--}]

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{--}]

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  A copy of \tcode{*this} before decrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr mask_type operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{!}]

  \pnum\returns
  A \tcode{basic_simd_mask} object with the $i^\text{th}$ element set to \tcode{!operator[]($i$)} \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{\~{}}]

  \pnum\returns
  A \tcode{basic_simd} object where each bit is the inverse of the corresponding bit in \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator+() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{+}]

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator-() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed[unary \tcode{-}]

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to \tcode{-operator[]($i$)} \foralli.
\end{itemdescr}

\rSec1[simd.nonmembers]{\tcode{basic_simd} non-member operations}

\rSec2[simd.binary]{\tcode{basic_simd} binary operators}

\begin{itemdecl}
friend constexpr basic_simd operator+(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator-(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator*(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator/(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator%(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator&(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator|(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator^(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator<<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd operator<<(const basic_simd& v, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& v, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to the result of applying the indicated operator to \tcode{v[$i$]} and \tcode{n} \foralli.
\end{itemdescr}

\rSec2[simd.cassign]{\tcode{basic_simd} compound assignment}

\begin{itemdecl}
friend constexpr basic_simd& operator+=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator-=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator*=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator/=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator%=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator&=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator|=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator^=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator<<=(basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd& operator>>=(basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as an element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd& operator<<=(basic_simd& lhs, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd& operator>>=(basic_simd& lhs, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  Equivalent to: \tcode{return operator@=(lhs, basic_simd(n));}
\end{itemdescr}

\rSec2[simd.comparison]{\tcode{basic_simd} compare operators}

\begin{itemdecl}
friend constexpr mask_type operator==(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator!=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.cond]{\tcode{basic_simd} conditional operators}

\begin{itemdecl}
friend constexpr basic_simd @\simdselect@(const mask_type& mask, const basic_simd& a, const basic_simd& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] : b[$i$]} \foralli.
\end{itemdescr}

\rSec2[simd.reductions]{\tcode{basic_simd} reductions}

\pnum
In this subclause, \tcode{BinaryOperation} shall be a binary element-wise operation.

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation = plus<>>
  constexpr T reduce(const basic_simd<T, Abi>& x, BinaryOperation binary_op = {});
\end{itemdecl}

\begin{itemdescr}
  \pnum\mandates
  \tcode{binary_op} can be invoked with two arguments of type \tcode{basic_simd<T, A1>} returning \tcode{basic_simd<T, A1>} for every \tcode{A1} that is an ABI tag type.

  \pnum\returns
  \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x.data[$i$], ...)} \foralli (\iref{numerics.defns}).

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     T identity_element, BinaryOperation binary_op);
\end{itemdecl}

\begin{itemdescr}
  \pnum\mandates
  \tcode{binary_op} can be invoked with two arguments of type \tcode{basic_simd<T, A1>} returning \tcode{basic_simd<T, A1>} for every \tcode{A1} that is an ABI tag type.

  \pnum\expects
  The results of \tcode{all_of(x == binary_op(basic_simd<T, A1>(identity_element), basic_simd<T, A1>(x)))} and \tcode{all_of(basic_simd<T, A1>(x) == binary_op(x, basic_simd<T, A1>(identity_element)))} shall be \tcode{true} for every \tcode{A1} that is an ABI tag type and for all finite values \tcode{x} representable by \tcode{T}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{identity_element}.
  Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     plus<> binary_op = {}) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     multiplies<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  If \tcode{none_of(x)}, returns \tcode{1}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     bit_and<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{is_integral_v<T>} is \tcode{true}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{\~{}T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     bit_or<> binary_op) noexcept;
template<class T, class Abi>
  constexpr T reduce(const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
                     bit_xor<> binary_op) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{is_integral_v<T>} is \tcode{true}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{T()}. Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, x[$i$], ...)} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_min(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_min(const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{numeric_limits<T>::max()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_max(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$j$] < x[$i$]} is \tcode{false} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_max(const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)}, returns \tcode{numeric_limits<V::value_type>::lowest()}.
  Otherwise, returns the value of a selected element \tcode{x.data[$j$]} for which \tcode{x.data[$j$] < x.data[$i$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\rSec2[simd.creation]{\tcode{basic_simd} and \tcode{basic_simd_mask} creation}

\begin{itemdecl}
template<class V, class Abi>
  constexpr auto simd_split(const basic_simd<typename V::value_type, Abi>& x) noexcept;
template<class M, class Abi>
  constexpr auto simd_split(const basic_simd_mask<@\maskelementsize@<M>, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  % probably not necessary/helpful:
  %\pnum\mandates \tcode{V::size() <= basic_simd<V::value_type, Abi>::size}.

  \pnum\constraints
  \begin{itemize}
    \item \tcode{V} is a specialization of \tcode{basic_simd}.
    \item \tcode{M} is a specialization of \tcode{basic_simd_mask}.
  \end{itemize}

  \pnum Let $N$ be \tcode{x.size() / V::size()}.

    \pnum\returns
    \begin{itemize}
      \item If \tcode{x.size() \% V::size() == 0}, an \tcode{array<V, $N$>} with
        the $i^\text{th}$ \simd element of the $j^\text{th}$ \tcode{array}
        element initialized to the value of the element in \tcode{x} with index
        \tcode{$i$ + $j$ * V::size()}.

      \item Otherwise, a \tcode{tuple} of $N$ objects of type \tcode{V} and one
        or more objects of types \tcode{resize_simd_t<Sizes, V>...} such that
        \tcode{(Sizes + ...)} is equal to \tcode{x.size() \% V::size()}.
        The $i^\text{th}$ \tcode{simd} element of the $j^\text{th}$ \tcode{tuple}
        element of type \tcode{V} is initialized to the value of the element in
        \tcode{x} with index \tcode{$i$ + $j$ * V::size()}.
        The $i^\text{th}$ \tcode{simd} element of the $j^\text{th}$ \tcode{tuple}
        with $j \ge N$ is initialized to the value of the element in \tcode{x}
        with index \tcode{$i$ + $N$ * V::size() +} sum of the first $j - N$
        values in the \tcode{Sizes} pack.
    \end{itemize}
  \end{itemdescr}

\begin{itemdecl}
template<class T, class... Abis>
  constexpr basic_simd<T, @\seebelow@<T, (basic_simd<T, Abis>::size + ...)>>
    simd_cat(const basic_simd<T, Abis>&... xs) noexcept;
template<size_t Bytes, class... Abis>
  constexpr basic_simd_mask<Bytes, @\deducet@<@\integerfrom@<Bytes>, (basic_simd_mask<Bytes, Abis>::size() + ...)>>
    simd_cat(const basic_simd_mask<Bytes, Abis>&... xs) noexcept;

\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A data-parallel object initialized with the concatenated values in the \tcode{xs} pack of data-parallel objects: The $i^\text{th}$ \tcode{basic_simd}/\tcode{basic_simd_mask} element of the $j^\text{th}$ parameter in the \tcode{xs} pack is copied to the return value's element with index $i$ + the sum of the width of the first $j$ parameters in the \tcode{xs} pack.
\end{itemdescr}

\rSec2[simd.alg]{Algorithms}

\begin{itemdecl}
template<class T, class Abi> constexpr basic_simd<T, Abi> min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr basic_simd<T, Abi> max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>> minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  A \tcode{pair} initialized with
  \begin{itemize}
    \item the result of element-wise application of \tcode{std::min(a[$i$], b[$i$])} \foralli{} in the \tcode{first} member, and
    \item the result of element-wise application of \tcode{std::max(a[$i$], b[$i$])} \foralli{} in the \tcode{second} member.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> basic_simd<T, Abi>
  constexpr clamp(const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo, const basic_simd<T, Abi>& hi);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} satisfies \tcode{totally_ordered}.

  \pnum\expects
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\expects
  No element in \tcode{lo} shall be greater than the corresponding element in \tcode{hi}.

  \pnum\returns
  The result of element-wise application of \tcode{std::clamp(v[$i$], lo[$i$], hi[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b) -> remove_cvref_t<decltype(c ? a : b)>;
\end{itemdecl}

\begin{itemdescr}
    \pnum\returns As-if \tcode{c ? a : b}.
\end{itemdescr}

\begin{itemdecl}
  template<size_t Bytes, class Abi, typename T, typename U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b);
\end{itemdecl}

\begin{itemdescr}
    \pnum\returns As-if \tcode{\simdselect(c, a, b)}.
\end{itemdescr}

\rSec2[simd.math]{\tcode{basic_simd} math library}

\pnum
For each set of overloaded functions within \tcode{<cmath>}, there shall be additional overloads sufficient to ensure that if any argument corresponding to a \tcode{double} parameter has type \tcode{basic_simd<T, Abi>}, where \tcode{is_floating_point_v<T>} is \tcode{true}, then:
\begin{itemize}
  \item All arguments corresponding to \tcode{double} parameters shall be convertible to \tcode{basic_simd<T, Abi>}.
  \item All arguments corresponding to \tcode{double*} parameters shall be of type \tcode{basic_simd<T, Abi>*}.
  \item All arguments corresponding to parameters of integral type \tcode{U} shall be convertible to \tcode{simd<U, basic_simd<T, Abi>::size>}.
  \item All arguments corresponding to \tcode{U*}, where \tcode{U} is integral, shall be of type \tcode{simd<U, basic_simd<T, Abi>::size>*}.
  \item If the corresponding return type is \tcode{double}, the return type of the additional overloads is \tcode{basic_simd<T, Abi>}. Otherwise, if the corresponding return type is \tcode{bool}, the return type of the additional overload is \tcode{basic_simd_mask<T, Abi>}. Otherwise, the return type is \tcode{simd<R, basic_simd<T, Abi>::size>}, with \tcode{R} denoting the corresponding return type.
\end{itemize}
It is unspecified whether a call to these overloads with arguments that are all convertible to \tcode{basic_simd<T, Abi>} but are not of type \tcode{basic_simd<T, Abi>} is well-formed.

\pnum
Each function overload produced by the above rules applies the indicated \tcode{<cmath>} function element-wise. For the mathematical functions, the results per element only need to be approximately equal to the application of the function which is overloaded for the element type.

\pnum
The result is unspecified if a domain, pole, or range error occurs when the input argument(s) are applied to the indicated \tcode{<cmath>} function.
\begin{note}Implementations are encouraged to follow the C specification (especially Annex F).\end{note}

\pnum
TODO: Allow \tcode{abs(basic_simd<\textrm{signed-integral}>)}.

\pnum
If \tcode{abs} is called with an argument of type \tcode{basic_simd<X, Abi>} for which \tcode{is_unsigned_v<X>} is \tcode{true}, the program is ill-formed.

\rSec1[simd.mask.class]{Class template \tcode{basic_simd_mask}}

\rSec2[simd.mask.overview]{Class template \tcode{basic_simd_mask} overview}

\begin{codeblock}
template<size_t Bytes, class Abi> class basic_simd_mask {
public:
  using value_type = bool;
  using reference = @\seebelow@;
  using abi_type = Abi;

  static constexpr auto size = basic_simd<@\integerfrom@<Bytes>, Abi>::size;

  constexpr basic_simd_mask() noexcept = default;

  // \ref{simd.mask.ctor}, \tcode{basic_simd_mask} constructors
  constexpr explicit basic_simd_mask(value_type) noexcept;
  template<size_t UBytes, class UAbi>
    constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
  template<typename It, class... Flags>
    constexpr basic_simd_mask(It first, Flags = {});
  template<typename It, class... Flags>
    constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});

  // \ref{simd.mask.copy}, \tcode{basic_simd_mask} copy functions
  template<typename It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> = {});
  template<typename It, class... Flags>
    constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
  template<typename Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
  template<typename Out, class... Flags>
    constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;

  // \ref{simd.mask.subscr}, \tcode{basic_simd_mask} subscript operators
  constexpr reference operator[](@\simdsizetype@) &;
  constexpr value_type operator[](@\simdsizetype@) const&;

  // \ref{simd.mask.unary}, \tcode{basic_simd_mask} unary operators
  constexpr basic_simd_mask operator!() const noexcept;
  constexpr simd_type operator+() const noexcept;
  constexpr simd_type operator-() const noexcept;
  constexpr simd_type operator~() const noexcept;

  // \ref{simd.mask.conv}, \tcode{basic_simd_mask} conversion operators
  template <class U, class A>
    constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;

  // \ref{simd.mask.binary}, \tcode{basic_simd_mask} binary operators
  friend constexpr basic_simd_mask operator&&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask operator||(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask operator&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask operator|(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask operator^(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cassign}, \tcode{basic_simd_mask} compound assignment
  friend constexpr basic_simd_mask& operator&=(basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask& operator|=(basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask& operator^=(basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.comparison}, \tcode{basic_simd_mask} comparisons
  friend constexpr basic_simd_mask operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cond}, \tcode{basic_simd_mask} conditional operators
  friend constexpr basic_simd_mask @\simdselect@(const basic_simd_mask&, const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask @\simdselect@(const basic_simd_mask&, bool, bool) noexcept;
  template <class T0, class T1>
    friend constexpr basic_simd<@\seebelow@, Abi>
      @\simdselect@(const basic_simd_mask&, const T0&, const T1&) noexcept;
};
\end{codeblock}

\pnum
The class template \tcode{basic_simd_mask} is a data-parallel type with the element type \tcode{bool}. The width of a given \tcode{basic_simd_mask} specialization is a constant expression, determined by the template parameters. Specifically, \tcode{basic_simd_mask<T, Abi>::size() == basic_simd<T, Abi>::size()}.

\pnum
Every specialization of \tcode{basic_simd_mask} is a complete type. The specialization \tcode{basic_simd_mask<T, Abi>} is supported if \tcode{T} is a vectorizable type and
\begin{itemize}
  \item \tcode{Abi} is \tcode{simd_abi::scalar}, or
  \item \tcode{Abi} is \tcode{simd_abi::fixed_size<N>}, with \tcode{N} constrained as defined in (\ref{simd.abi}).
\end{itemize}

It is implementation-defined whether \tcode{basic_simd_mask<T, Abi>} is supported.
\begin{note}The intent is for implementations to decide on the basis of the currently targeted system.\end{note}

If \tcode{basic_simd_mask<Bytes, Abi>} is not supported, the specialization shall have a deleted default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
Otherwise, the following are true:
\begin{itemize}
  \item \tcode{is_nothrow_move_constructible_v<basic_simd_mask<Bytes, Abi>>}, and
  \item \tcode{is_nothrow_move_assignable_v<basic_simd_mask<Bytes, Abi>>}, and
  \item \tcode{is_nothrow_default_constructible_v<basic_simd_mask<Bytes, Abi>>}.
\end{itemize}

\pnum
Default initialization performs no initialization of the elements; value-initialization initializes each element with \tcode{false}. \begin{note}Thus, default initialization leaves the elements in an indeterminate state.\end{note}

\pnum
Implementations should enable explicit conversion from and to implementation-defined types. This adds one or more of the following declarations to class \tcode{basic_simd_mask}:

\begin{codeblock}
constexpr explicit operator @\impdef@() const;
constexpr explicit basic_simd_mask(const @\impdef@& init) const;
\end{codeblock}

\pnum
The member type \tcode{reference} has the same interface as \tcode{basic_simd<T, Abi>::reference}, except its \tcode{value_type} is \tcode{bool}. (\ref{simd.reference})

\rSec2[simd.mask.ctor]{\tcode{basic_simd_mask} constructors}

\begin{itemdecl}
constexpr explicit basic_simd_mask(value_type x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Constructs an object with each element initialized to \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
template<size_t UBytes, class UAbi>
  constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{simd_size_v<U, UAbi> == size()}.

  \pnum\effects
  Constructs an object of type \tcode{basic_simd_mask} where the $i^\text{th}$ element equals \tcode{x[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{static_cast<bool>(gen(integral_constant<size_t, i>()))} is well-formed \foralli.

  \pnum\effects
  Constructs an object where the $i^\text{th}$ element is initialized to \tcode{gen(integral_constant<size_t, i>())}.

  \pnum
  The calls to \tcode{gen} are unsequenced with respect to each other.
  Vectorization-unsafe standard library functions may not be invoked by \tcode{gen} (\iref{algorithms.parallel.exec}).
\end{itemdescr}

\newcommand\MaskLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is of type \tcode{bool}, and
    \item \tcode{It} satisfies \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{It} models \tcode{contiguous_iterator}.
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr basic_simd_mask(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Constructs an object where the $i^\text{th}$ element is initialized to \tcode{mask[$i$] ? first[$i$] : false} \foralli.}
\end{itemdescr}

\rSec2[simd.mask.copy]{\tcode{basic_simd_mask} copy functions}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
  {\tcode{[first, first + size())} is a valid range.}
  {Replaces the elements of the \tcode{basic_simd_mask} object such that the $i^\text{th}$ element is replaced with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename It, class... Flags>
  constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd_mask} object such that the $i^\text{th}$ element is replaced with \tcode{first[$i$]} \forallmaskedi.}
\end{itemdescr}

\newcommand\MaskStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is of type \tcode{bool}, and
    \item \tcode{Out} satisfies \tcode{contiguous_iterator}, and
    \item \tcode{Out} satisfies \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \item \tcode{Out} models \tcode{contiguous_iterator}.
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<typename Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
    {\tcode{[first, first + size())} is a valid range.}
    {Copies all \tcode{basic_simd_mask} elements as if \tcode{first[$i$] = operator[]($i$)} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<typename Out, class... Flags>
  constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
  {\validMaskedRange}
  {Copies the selected elements as if \tcode{first[$i$] = operator[]($i$)} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.mask.subscr]{\tcode{basic_simd_mask} subscript operators}

\begin{itemdecl}
constexpr reference operator[](@\simdsizetype@ i) &;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i < size()}.

  \pnum\returns
  A \tcode{reference} (see \ref{simd.reference}) referring to the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const&;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i < size()}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.mask.unary]{\tcode{basic_simd_mask} unary operators}

\begin{itemdecl}
constexpr basic_simd_mask operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The result of the element-wise application of \tcode{operator!}.
\end{itemdescr}

\begin{itemdecl}
constexpr simd_type operator+() const noexcept;
constexpr simd_type operator-() const noexcept;
constexpr simd_type operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  Application of the indicated unary operator to objects of type \tcode{T} is well-formed.

  \pnum\returns
  The result of applying the indicated operator to \tcode{static_cast<simd_type>(*this)}.
\end{itemdescr}

\rSec2[simd.mask.conv]{\tcode{basic_simd_mask} conversion operators}

\begin{itemdecl}
template <class U, class A>
  constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{simd_size_v<U, A> == simd_size_v<T, Abi>}.

  \pnum\returns
  An object where the $i^\text{th}$ element is initialized to \tcode{static_cast<U>(operator[]($i$))}.
\end{itemdescr}

\rSec1[simd.mask.nonmembers]{Non-member operations}

\rSec2[simd.mask.binary]{\tcode{basic_simd_mask} binary operators}

\begin{itemdecl}
friend constexpr basic_simd_mask operator&&(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask operator||(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask operator& (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask operator| (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask operator^ (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cassign]{\tcode{basic_simd_mask} compound assignment}

\begin{itemdecl}
friend constexpr basic_simd_mask& operator&=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask& operator|=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask& operator^=(basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  These operators apply the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.

  \pnum\returns
  \tcode{lhs}.
\end{itemdescr}

\rSec2[simd.mask.comparison]{\tcode{basic_simd_mask} comparisons}

\begin{itemdecl}
friend constexpr basic_simd_mask operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying the indicated operator to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cond]{\tcode{basic_simd_mask} conditional operators}

\begin{itemdecl}
friend constexpr basic_simd @\simdselect@(const basic_simd_mask& mask, const basic_simd_mask& a, const basic_simd_mask& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] : b[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd_mask @\simdselect@(const basic_simd_mask& mask, bool a, bool b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T0, class T1>
  friend constexpr basic_simd<@\seebelow@, Abi>
    @\simdselect@(const basic_simd_mask& mask, const T0& a, const T1& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{U} be the common type of \tcode{T0} and \tcode{T1} without
  applying integral promotions on integral types with integer conversion rank
  less than the rank of \tcode{int}.

  \pnum\constraints
  \begin{itemize}
    \item \tcode{U} is a vectorizable type, and
    \item \tcode{sizeof(U) == sizeof(T)}, and
    \item \tcode{T0} satisfies \tcode{convertible_to<basic_simd<U, Abi>>}, and
    \item \tcode{T1} satisfies \tcode{convertible_to<basic_simd<U, Abi>>}.
  \end{itemize}

  \pnum\returns
  A \tcode{basic_simd<U, Abi>} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b} \foralli.
\end{itemdescr}

\rSec2[simd.mask.reductions]{\tcode{basic_simd_mask} reductions}

\begin{itemdecl}
template<size_t Bytes, class Abi> constexpr bool all_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if all boolean elements in \tcode{k} are \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi> constexpr bool any_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if at least one boolean element in \tcode{k} is \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi> constexpr bool none_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if none of the one boolean elements in \tcode{k} is \tcode{true}, \tcode{false} otherwise.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi> constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The number of boolean elements in \tcode{k} that are \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi> constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} returns \tcode{true}.

  \pnum\returns
  The lowest element index $i$ where \tcode{k[$i$]} is \tcode{true}.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi> constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} returns \tcode{true}.

  \pnum\returns
  The greatest element index $i$ where \tcode{k[$i$]} is \tcode{true}.

  \pnum\throws Nothing.
\end{itemdescr}

\begin{itemdecl}
constexpr bool all_of(@\UNSP{T}@) noexcept;
constexpr bool any_of(@\UNSP{T}@) noexcept;
constexpr bool none_of(@\UNSP{T}@) noexcept;
constexpr @\simdsizetype@ reduce_count(@\UNSP{T}@) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{all_of} and \tcode{any_of} return their arguments; \tcode{none_of} returns the negation of its argument; \tcode{reduce_count} returns the integral representation of its argument.

  \pnum\remarks
  The parameter type \tcode{T} is an unspecified type that is only constructible via implicit conversion from \tcode{bool}.
\end{itemdescr}

\begin{itemdecl}
constexpr @\simdsizetype@ reduce_min_index(@\UNSP{T}@);
constexpr @\simdsizetype@ reduce_max_index(@\UNSP{T}@);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  The value of the argument is \tcode{true}.

  \pnum\returns
  \tcode{0}.

  \pnum\throws Nothing.

  \pnum\remarks
  The parameter type \tcode{T} is an unspecified type that is only constructible via implicit conversion from \tcode{bool}.
\end{itemdescr}

% vim: tw=0
