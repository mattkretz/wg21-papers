\def\rSec#1[#2]#3{%
  \ifcase#1\wgSubsection[subsection]{#3}{#2}
  \or\wgSubsubsection[subsubsection]{#3}{#2}
  \or\wgSubsubsubsection[paragraph]{#3}{#2}
  \or\error
\fi}

\renewcommand\foralli[1][]{for all $i$ in the range of \range{0}{#1size()}}
\renewcommand\forallmaskedi{for all selected indices $i$ of \tcode{mask}}

\newcommand\validMaskedRange[1][first]{For all selected indices $i$,
\range{#1}{#1 + $i$ + 1} is a valid range.}

\newcommand\flagsRequires[2]{
\item If the template parameter pack \tcode{Flags} contains
  \tcode{\alignedflag}, \tcode{to_address(first)} points to storage
  aligned by \tcode{simd_alignment_v<#1>}.
\item If the template parameter pack \tcode{Flags} contains
  \tcode{\overalignedflag<N>}, \tcode{to_address(first)}
  points to storage aligned by \tcode{N}.
}

\newcommand\conversionFlagsMandate[2]{
  If the template parameter pack \tcode{Flags} does not contain
  \tcode{\convertflag}, then the conversion from \tcode{#1} to
  \tcode{#2} is value-preserving.
}

\newcommand\op{\textrm{\textit{op}}}

\newcommand\ConstraintUnaryOperatorWellFormed[2][const ]{%
  \constraints \tcode{requires (#1value_type a) \{ #2; \}} is \tcode{true}.
}

\newcommand\ConstraintOperatorTWellFormed{%
  \constraints \tcode{requires (value_type a, value_type b) \{ a \op{} b; \}} is \tcode{true}.
}

\newcommand\ConversionsToIntrinsics{
\recommended
Implementations should support explicit conversions between specializations of basic_simd_mask and
appropriate implementation-defined types.
\begin{note}
  The appropriate vector types which are available in the implementation.
\end{note}

%\begin{example}
  %Consider an implementation that supports the type \tcode{__vec4f} and the function \tcode{__vec4f
  %_vec4f_addsub(__vec4f, __vec4f)} for the architecture of the execution environment.
  %A user may require the use of \tcode{_vec4f_addsub} for maximum performance and thus writes:
  %\begin{codeblock}
    %using V = basic_simd<float, simd_abi::__simd128>;
    %V addsub(V a, V b) {
      %return static_cast<V>(_vec4f_addsub(static_cast<__vec4f>(a), static_cast<__vec4f>(b)));
    %}
  %\end{codeblock}
%\end{example}
}

\rSec0[simd]{Data-parallel types}
\rSec1[simd.general]{General}

\pnum
[simd] defines data-parallel types and operations on these types.
\begin{note}
The intent is to support acceleration through data-parallel execution resources
where available, such as SIMD registers and instructions or execution units
driven by a common instruction decoder.
%If such execution resources are unavailable, the interfaces support a
%transparent fallback to sequential execution.
\end{note}

\pnum\label{wording.vectorizable.types}%
The set of \defn{vectorizable types} comprises all standard integer types,
character types, and the types \tcode{float} and \tcode{double}
([basic.fundamental]).
In addition, \tcode{std::float16_t}, \tcode{std::float32_t}, and
\tcode{std::float64_t} are vectorizable types if defined ([basic.extended.fp]).

\pnum
The term \defn{data-parallel type} refers to all enabled specializations of
the \tcode{basic_simd} and \tcode{basic_simd_mask} class templates. A \defn{data-parallel object} is
an object of \term{data-parallel type}.

\pnum
Each specialization of \tcode{basic_simd} or \tcode{basic_simd_mask} is either enabled or disabled,
as described in \ref{simd.overview} and \ref{simd.mask.overview}.

\pnum
A data-parallel type consists of one or more elements of an underlying vectorizable type,
called the \defn{element type}.
The number of elements is a constant for each data-parallel type and called the
\defn{width} of that type.
The elements in a data-parallel type are indexed from 0 to $\textrm{width} - 1$.

\pnum
An \defn{element-wise operation} applies a specified operation to the elements of one or more
data-parallel objects. Each such application is unsequenced with respect to the others. A
\defn{unary element-wise operation} is an element-wise operation that applies a unary operation to
each element of a data-parallel object. A \defn{binary element-wise operation} is an element-wise
operation that applies a binary operation to corresponding elements of two data-parallel objects.

\pnum\label{wording.selected.indices}%
Given a \tcode{basic_simd_mask<Bytes, Abi>} object \tcode{mask}, the
\defn{selected indices} signify the integers $i$ in the range
\range{0}{mask.size()} for which \tcode{mask[$i$]} is \tcode{true}.
Given a data-parallel object \tcode{data}, the \defn{selected elements} signify the elements
\tcode{data[$i$]} for all selected indices $i$.

\pnum
The conversion from an arithmetic type \tcode{U} to a vectorizable type \tcode{T} is
\defn{value-preserving} if
all possible values of \tcode{U} can be represented with type \tcode{T}.

\rSec1[simd.expos]{Exposition only types, variables, and concepts}

\begin{codeblock}
using @\simdsizetype@ = @\seebelow@;                                 // \expos
template<size_t Bytes> using @\integerfrom@ = @\seebelow@;            // \expos

template<class T, class Abi>
  constexpr @\simdsizetype\ \simdsizev@ = @\seebelow@;               // \expos
template<class T> constexpr size_t @\maskelementsize@ = @\seebelow@; // \expos

template<class T>
  concept @\constexprwrapperlike@ =                                // \expos
    convertible_to<T, decltype(T::value)> &&
    equality_comparable_with<T, decltype(T::value)> &&
    bool_constant<T() == T::value>::value &&
    bool_constant<static_cast<decltype(T::value)>(T()) == T::value>::value;

template<class T> using @\deducedsimd@ = @\seebelow@;               // \expos

template<class V, class T> using @\makecompatiblesimdt@ = @\seebelow@; // \expos

template<class V>
  concept @\simdfloatingpoint@ =                                   // \expos
    same_as<V, basic_simd<typename V::value_type, typename V::abi_type>> &&
    is_default_constructible_v<V> && floating_point<typename V::value_type>;

template<class... Ts>
  concept @\mathfloatingpoint@ =                                   // \expos
    = (@\simdfloatingpoint@<@\deducedsimd@<Ts>> or ...);

template<class... Ts>
  requires @\mathfloatingpoint@<Ts...>
    using @\mathcommonsimd@ = @\seebelow@;                         // \expos

template<class BinaryOperation, class T>
  concept @\reductionoperation@ = @\seebelow@;                     // \expos

// \ref{simd.expos.abi}, \tcode{simd} ABI tags
template<class T> using @\nativeabi@ = @\seebelow@;                   // \expos
template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@;   // \expos

// \ref{simd.flags}, Load and store flags
struct @\convertflag@;                                              // \expos
struct @\alignedflag@;                                              // \expos
template<size_t N> struct @\overalignedflag@;                       // \expos
\end{codeblock}

\begin{itemdecl}
using @\simdsizetype@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \simdsizetype{} is an alias for a signed integer type.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes> using @\integerfrom@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \tcode{\integerfrom<Bytes>} is an alias for a signed integer type \tcode{T} so that
  \tcode{sizeof(T) == Bytes}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr @\simdsizetype\ \simdsizev@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \tcode{\simdsizev<T, Abi>} denotes the width of \tcode{basic_simd<T, Abi>} if
  the specialization \tcode{basic_simd<T, Abi>} is enabled, or \tcode{0} otherwise.
  \begin{note}
    \tcode{\simdsizev<T, Abi>} does not require instantiation of \tcode{basic_simd<T, Abi>}.
  \end{note}
  \FIXME{drop the note?}
\end{itemdescr}

\begin{itemdecl}
template<class T> constexpr size_t @\maskelementsize@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \tcode{\maskelementsize<basic_simd_mask<Bytes, Abi>>} has the value \tcode{Bytes}.
\end{itemdescr}

\begin{itemdecl}
template<class T> using @\deducedsimd@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum Let \tcode{x} denote an lvalue of type \tcode{const T}.

  \pnum \tcode{\deducedsimd<T>} is an alias for
  \begin{itemize}
    %\item \tcode{decltype(basic_simd(x))}, if \tcode{basic_simd(x)} is well-formed and
      %\tcode{is_convertible_v<const T\&, decltype(basic_simd(x))>} is true; otherwise

    \item \tcode{decltype(x + x)},
      if the type of \tcode{x + x} is an enabled specialization of \tcode{basic_simd};
      %if \tcode{decltype(x + x)} satisfies \tcode{\simdfloatingpoint};
      otherwise

    \item \tcode{void}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class V, class T> using @\makecompatiblesimdt@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{x} denote an lvalue of type \tcode{const T}.

  \pnum \tcode{\makecompatiblesimdt<V, T>} is an alias for
  \begin{itemize}
    \item \tcode{\deducedsimd<T>}, if that type is not \tcode{void}, otherwise
    \item \tcode{simd<decltype(x + x), V::size()>}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class... Ts>
  requires @\mathfloatingpoint@<Ts...>
    using @\mathcommonsimd@ = @\seebelow@; // \expos
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{T0} denote \tcode{Ts...[0]}.
  Let \tcode{T1} denote \tcode{Ts...[1]}.
  Let \tcode{TRest} denote a pack such that \tcode{T0, T1, TRest...} is equivalent to \tcode{Ts...}.

  \pnum
  Let \tcode{\mathcommonsimd<Ts...>} be an alias for
  \begin{itemize}
    \item \tcode{\deducedsimd<T0>}, if \tcode{sizeof...(Ts)} equals $1$; otherwise

    \item \tcode{common_type_t<\deducedsimd<T0>, \deducedsimd<T1>>}, if \tcode{sizeof...(Ts)}
      equals $2$ and \tcode{\mathfloatingpoint<T0> \&\& \mathfloatingpoint<T1>} is \tcode{true};
      otherwise

    \item \tcode{common_type_t<\deducedsimd<T0>, T1>}, if \tcode{sizeof...(Ts)}
      equals $2$ and \tcode{\mathfloatingpoint<T0>} is \tcode{true}; otherwise

    \item \tcode{common_type_t<T0, \deducedsimd<T1>>}, if \tcode{sizeof...(Ts)}
      equals $2$; otherwise

    \item \tcode{common_type_t<\mathcommonsimd<T0, T1>, TRest...>}, if \tcode{\mathcommonsimd<T0,
      T1>} is valid and denotes a type; otherwise

    \item \tcode{common_type_t<\mathcommonsimd<TRest...>, T0, T1>}.
  \end{itemize}
\end{itemdescr}


\begin{itemdecl}
template<class BinaryOperation, class T>
  concept @\reductionoperation@ =  // \expos
    requires (const BinaryOperation binary_op, const simd<T, 1> v) {
      { binary_op(v, v) } -> same_as<simd<T, 1>>;
    };
\end{itemdecl}
\begin{itemdescr}
\pnum
Types \tcode{BinaryOperation} and \tcode{T} model \tcode{\reductionoperation<BinaryOperation, T>}
only if:
\begin{itemize}
  \item \tcode{BinaryOperation} is a binary element-wise operation and the operation is commutative.

  \item An object of type \tcode{BinaryOperation} can be invoked with two arguments of type
    \code{basic_simd<T, Abi>}, with unspecified ABI tag \code{Abi}, returning a \code{basic_simd<T,
    Abi>}.
\end{itemize}
\end{itemdescr}

\rSec2[simd.expos.abi]{\tcode{simd} ABI tags}

\begin{itemdecl}
template<class T> using @\nativeabi@ = @\seebelow@; // \expos
template<class T, @\simdsizetype@ N> using @\deducet@ = @\seebelow@; // \expos
\end{itemdecl}

\begin{itemdescr}
\pnum\label{wording.ABI.tag}
An \defn{ABI tag} is a type that indicates a choice of size and binary
representation for objects of data-parallel type.
\begin{note}
  The intent is for the size and binary representation to depend on the target
  architecture and compiler flags.
\end{note}
The ABI tag, together with a given element type, implies the width.

\pnum
\begin{note}
The ABI tag is orthogonal to selecting the machine instruction set.
The selected machine instruction set limits the usable ABI tag types, though
(see \ref{simd.overview}).
The ABI tags enable users to safely pass objects of data-parallel type between
translation unit boundaries (e.g. function calls or I/O).
\end{note}

\pnum
An implementation defines ABI tag types as necessary for the following aliases.

\pnum\label{wording.deducet}
\tcode{\deducet<T, N>} is defined if
\begin{itemize}
  \item \tcode{T} is a vectorizable type,
  \item \tcode{N} is greater than zero, and
  \item \tcode{N} is not larger than an implementation-defined maximum.
\end{itemize}
The implementation-defined maximum for \tcode{N} is not smaller than 64
and can differ depending on \tcode{T}.

\pnum
Where present, \tcode{\deducet<T, N>} names an ABI tag type that satisfies
\begin{itemize}
  \item \tcode{\simdsizev<T, \deducet<T, N>> == N}, and
  \item \tcode{basic_simd<T, \deducet<T, N>>} is enabled (see \ref{simd.overview}).
\end{itemize}

% TODO: If we really want the Abis... pack back this needs a paper to LEWG.
%       The pack allows e.g. to stay with ymm registers even when zmm is available,
%         or to implement an MMX ABI that doesn't get used unless explicitly called for.
%       Also one can imagine a target with multiple different SIMD execution facilities
%         where moving between them has a high cost and shouldn't happen without a request.

\pnum
\tcode{\nativeabi<T>} is an implementation-defined alias for an ABI tag.
\tcode{basic_simd<T, \nativeabi<T>} is an enabled specialization.
\begin{note}
The intent is to use the ABI tag producing the most efficient data-parallel
execution for the element type \tcode{T} on the currently
targeted system.
For target architectures with ISA extensions, compiler flags can change the
type of the \tcode{\nativeabi<T>} alias.
\end{note}\\
\begin{example}
  Consider a target architecture supporting the ABI tags
  \tcode{__simd128} and \tcode{__simd256}, where hardware support for
  \tcode{__simd256} exists only for floating-point types.
  The implementation therefore defines \tcode{\nativeabi<T>} as an alias for
  \begin{itemize}
    \item \tcode{__simd256} if \tcode{T} is a floating-point type, and
    \item \tcode{__simd128} otherwise.
  \end{itemize}
\end{example}
\end{itemdescr}

\rSec1[simd.syn]{Header \texorpdfstring{\tcode{<simd>}}{<simd>} synopsis}

%\indexhdr{simd}
\begin{codeblock}
namespace std {
  // \ref{simd.traits}, \tcode{simd} type traits
  template<class T, class U = typename T::value_type> struct simd_alignment;
  template<class T, class U = typename T::value_type>
    inline constexpr size_t simd_alignment_v = simd_alignment<T, U>::value;

  template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
  template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
  template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
  template<@\simdsizetype@ N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

  // \ref{simd.flags}, Load and store flags
  template<class... Flags> struct simd_flags;
  inline constexpr simd_flags<> simd_flag_default{};
  inline constexpr simd_flags<@\convertflag@> simd_flag_convert{};
  inline constexpr simd_flags<@\alignedflag@> simd_flag_aligned{};
  template<size_t N> requires (has_single_bit(N))
    inline constexpr simd_flags<@\overalignedflag<N>@> simd_flag_overaligned{};

  // \ref{simd.class}, Class template \tcode{basic_simd}
  template<class T, class Abi = @\nativeabi@<T>> class basic_simd;
  template<class T, @\simdsizetype@ N = @\simdsizev@<T, @\nativeabi@<T>>>
    using simd = basic_simd<T, @\deducet@<T, N>>;

  // \ref{simd.mask.class}, Class template \tcode{basic_simd_mask}
  template<size_t Bytes, class Abi = @\nativeabi@<@\integerfrom@<Bytes>>> class basic_simd_mask;
  template<class T, @\simdsizetype@ N = @\simdsizev@<T, @\nativeabi@<T>>>
    using simd_mask = basic_simd_mask<sizeof(T), @\deducet@<T, N>>;

  // \ref{simd.creation}, \tcode{basic_simd} and \tcode{basic_simd_mask} creation
  template<class T, class Abi>
    constexpr auto
      simd_split(const basic_simd<typename T::value_type, Abi>& x) noexcept;
  template<class T, class Abi>
    constexpr auto
      simd_split(const basic_simd_mask<@\maskelementsize@<T>, Abi>& x) noexcept;

  template<class T, class... Abis>
    constexpr basic_simd<T, @\deducet@<T, (basic_simd<T, Abis>::size() + ...)>>
      simd_cat(const basic_simd<T, Abis>&...) noexcept;
  template<size_t Bs, class... Abis>
    constexpr basic_simd_mask<Bs, @\deducet@<@\integerfrom@<Bs>,
                              (basic_simd_mask<Bs, Abis>::size() + ...)>>
      simd_cat(const basic_simd_mask<Bs, Abis>&...) noexcept;

  // \ref{simd.mask.reductions}, \tcode{basic_simd_mask} reductions
  template<size_t Bs, class Abi>
    constexpr bool all_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr bool any_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr bool none_of(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bs, Abi>&) noexcept;
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bs, Abi>&);
  template<size_t Bs, class Abi>
    constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bs, Abi>&);

  constexpr bool all_of(same_as<bool> auto) noexcept;
  constexpr bool any_of(same_as<bool> auto) noexcept;
  constexpr bool none_of(same_as<bool> auto) noexcept;
  constexpr @\simdsizetype@ reduce_count(same_as<bool> auto) noexcept;
  constexpr @\simdsizetype@ reduce_min_index(same_as<bool> auto);
  constexpr @\simdsizetype@ reduce_max_index(same_as<bool> auto);

  // \ref{simd.reductions}, \tcode{basic_simd} reductions
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(const basic_simd<T, Abi>&, BinaryOperation = {});
  template<class T, class Abi, class BinaryOperation = plus<>>
    constexpr T reduce(
      const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
      BinaryOperation binary_op = {}, type_identity_t<T> identity_element = @\seebelow@);

  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_min(const basic_simd<T, Abi>&,
                           const typename basic_simd<T, Abi>::mask_type&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&) noexcept;
  template<class T, class Abi>
    constexpr T reduce_max(const basic_simd<T, Abi>&,
                           const typename basic_simd<T, Abi>::mask_type&) noexcept;

  // \ref{simd.alg}, Algorithms
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      min(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      max(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
      minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
  template<class T, class Abi>
    constexpr basic_simd<T, Abi>
      clamp(const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo,
            const basic_simd<T, Abi>& hi);

  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype(@\simdselect@(c, a, b));

  // \ref{simd.math}, Mathematical functions
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> acos(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> asin(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> atan(const V& x);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> atan2(const V0& y, const V1& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> cos(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> sin(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> tan(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> acosh(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> asinh(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> atanh(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> cosh(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> sinh(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> tanh(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> exp(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> exp2(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> expm1(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> frexp(const V& value,
  rebind_simd_t<int, @\deducedsimd@<V>>* exp);
  template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<int, @\deducedsimd@<V>> ilogb(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> ldexp(const V& x, const
  rebind_simd_t<int, @\deducedsimd@<V>>& exp);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log10(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log1p(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log2(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> logb(const V& x);
  template<class T, class Abi>
    constexpr basic_simd<T, Abi> modf(const type_identity_t<basic_simd<T, Abi>>& value,
                                      basic_simd<T, Abi>* iptr);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> scalbn(const V& x, const
  rebind_simd_t<int, @\deducedsimd@<V>>& n);
  template<@\mathfloatingpoint@ V>
    constexpr @\deducedsimd@<V> scalbln(const V& x, const rebind_simd_t<long int, @\deducedsimd@<V>>& n);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> cbrt(const V& x);
  template<signed_integral T, class Abi>
    constexpr basic_simd<T, Abi> abs(const basic_simd<T, Abi>& j);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> abs(const V& j);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> fabs(const V& x);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> hypot(const V0& x, const V1& y);
  template<class V0, class V1, class V2>
    constexpr @\mathcommonsimd@<V0, V1, V2> hypot(const V0& x, const V1& y, const V2& z);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> pow(const V0& x, const V1& y);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> sqrt(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> erf(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> erfc(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> lgamma(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> tgamma(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> ceil(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> floor(const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> nearbyint(const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> rint(const V& x);
  template<@\mathfloatingpoint@ V> rebind_simd_t<long int, @\deducedsimd@<V>> lrint(const V& x);
  template<@\mathfloatingpoint@ V> rebind_simd_t<long long int, V> llrint(const @\deducedsimd@<V>& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> round(const V& x);
  template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<long int, @\deducedsimd@<V>> lround(const V& x);
  template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<long long int, @\deducedsimd@<V>> llround(const V& x);
  template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> trunc(const V& x);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> fmod(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> remainder(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> remquo(const V0& x, const V1& y,
                                           rebind_simd_t<int, @\mathcommonsimd@<V0, V1>>* quo);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> copysign(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> nextafter(const V0& x, const V1& y);
    @\textrm{\INFO{\code{nexttoward} is intentionally missing (because it needs a \code{long double}
    \ argument). We expect \code{nextup} and \code{nextdown} to provide a better replacement.}}@
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> fdim(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> fmax(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr @\mathcommonsimd@<V0, V1> fmin(const V0& x, const V1& y);
  template<class V0, class V1, class V2>
    constexpr @\mathcommonsimd@<V0, V1, V2> fma(const V0& x, const V1& y, const V2& z);
  template<class V0, class V1, class V2>
    constexpr @\mathcommonsimd@<V0, V1, V2> lerp(const V0& a, const V1& b, const V2& t) noexcept;
  template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<int, @\deducedsimd@<V>> fpclassify(const V& x);
  template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isfinite(const V& x);
  template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isinf(const V& x);
  template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isnan(const V& x);
  template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isnormal(const V& x);
  template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type signbit(const V& x);
  template<class V0, class V1>
    constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isgreater(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isgreaterequal(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isless(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename @\mathcommonsimd@<V0, V1>::mask_type islessequal(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename @\mathcommonsimd@<V0, V1>::mask_type islessgreater(const V0& x, const V1& y);
  template<class V0, class V1>
    constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isunordered(const V0& x, const V1& y);
  template<@\mathfloatingpoint@ V>
    @\deducedsimd@<V> assoc_laguerre(const rebind_simd_t<unsigned, @\deducedsimd@<V>>& n, const
      rebind_simd_t<unsigned, @\deducedsimd@<V>>& m,
                     const V& x);
  template<@\mathfloatingpoint@ V>
    @\deducedsimd@<V> assoc_legendre(const rebind_simd_t<unsigned, @\deducedsimd@<V>>& l, const
      rebind_simd_t<unsigned, @\deducedsimd@<V>>& m,
                     const V& x);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> beta(const V0& x, const V1& y);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> comp_ellint_1(const V& k);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> comp_ellint_2(const V& k);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> comp_ellint_3(const V0& k, const V1& nu);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> cyl_bessel_i(const V0& nu, const V1& x);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> cyl_bessel_j(const V0& nu, const V1& x);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> cyl_bessel_k(const V0& nu, const V1& x);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> cyl_neumann(const V0& nu, const V1& x);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> ellint_1(const V0& k, const V1& phi);
  template<class V0, class V1>
    @\mathcommonsimd@<V0, V1> ellint_2(const V0& k, const V1& phi);
  template<class V0, class V1, class V2>
    @\mathcommonsimd@<V0, V1, V2> ellint_3(const V0& k, const V1& nu, const V2& phi);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> expint(const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> hermite(const rebind_simd_t<unsigned,
  @\deducedsimd@<V>>& n, const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> laguerre(const rebind_simd_t<unsigned,
  @\deducedsimd@<V>>& n, const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> legendre(const rebind_simd_t<unsigned,
  @\deducedsimd@<V>>& l, const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> riemann_zeta(const V& x);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> sph_bessel(const rebind_simd_t<unsigned,
  @\deducedsimd@<V>>& n, const V& x);
  template<@\mathfloatingpoint@ V>
    @\deducedsimd@<V> sph_legendre(const rebind_simd_t<unsigned, @\deducedsimd@<V>>& l, const
      rebind_simd_t<unsigned, @\deducedsimd@<V>>& m,
                   const V& theta);
  template<@\mathfloatingpoint@ V> @\deducedsimd@<V> sph_neumann(const rebind_simd_t<unsigned,
  @\deducedsimd@<V>>& n, const V& x);
}
\end{codeblock}

\rSec1[simd.traits]{\tcode{simd} type traits}

\begin{itemdecl}
template<class T, class U = typename T::value_type> struct simd_alignment { @\seebelow@ };
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{simd_alignment<T, U>} has a member \tcode{value} if and only if
\begin{itemize}
  \item \tcode{T} is a specialization of \tcode{basic_simd_mask} and \tcode{U} is \tcode{bool}, or
  \item \tcode{T} is a specialization of \tcode{basic_simd} and \tcode{U} is a vectorizable type.
\end{itemize}

\pnum
If \tcode{value} is present, the type \tcode{simd_alignment<T, U>} is a \tcode{BinaryTypeTrait} with
a base characteristic of \tcode{integral_constant<size_t, N>} for some unspecified
\tcode{N} (see \ref{simd.copy} and \ref{simd.mask.copy}). \begin{note}\tcode{value} identifies the
alignment restrictions on pointers used for (converting) loads and stores for the given type
\tcode{T} on arrays of type \tcode{U}.\end{note}

\pnum
The behavior of a program that adds specializations for \tcode{simd_alignment} is undefined.
\end{itemdescr}

\begin{itemdecl}
template<class T, class V> struct rebind_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is a data-parallel type,
    \item \tcode{T} is a vectorizable type, and
    \item \tcode{\deducet<T, V::size()>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  If \tcode V is a specialization of \tcode{basic_simd} let \tcode{Abi1} denote an ABI tag such that
  \tcode{basic_simd<T, Abi1>::size()} equals \tcode{V::size()}.
  If \tcode V is a specialization of \tcode{basic_simd_mask} let \tcode{Abi1} denote an ABI tag such
  that \tcode{basic_simd_mask<sizeof(T), Abi1>::size()} equals \tcode{V::size()}.

  \pnum
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T, Abi1>} if \tcode V is a
  specialization of \tcode{basic_simd} or \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is a
  specialization of \tcode{basic_simd_mask}.
\end{itemdescr}

\begin{itemdecl}
template<@\simdsizetype@ N, class V> struct resize_simd { using type = @\seebelow@; };
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{T} denote
  \begin{itemize}
    \item \tcode{typename V::value_type} if \tcode{V} is a specialization of
      \tcode{basic_simd} or
    \item \tcode{\integerfrom<\maskelementsize<V>>} if \tcode{V} is a
      specialization of \tcode{basic_simd_mask}.
  \end{itemize}

  \pnum
  The member \tcode{type} is present if and only if
  \begin{itemize}
    \item \tcode{V} is a data-parallel type,
    \item \tcode{\deducet<T, N>} has a member type \tcode{type}.
  \end{itemize}

  \pnum
  If \tcode V is a specialization of \tcode{basic_simd} let \tcode{Abi1} denote an ABI tag such that
  \tcode{basic_simd<T, Abi1>::size()} equals \tcode{V::size()}.
  If \tcode V is a specialization of \tcode{basic_simd_mask} let \tcode{Abi1} denote an ABI tag such
  that \tcode{basic_simd_mask<sizeof(T), Abi1>::size()} equals \tcode{V::size()}.

  \pnum
  Where present, the member typedef \tcode{type} names \tcode{basic_simd<T,
  Abi1>} if \tcode V is a specialization of \tcode{basic_simd} or
  \tcode{basic_simd_mask<sizeof(T), Abi1>} if \tcode V is a specialization of
  \tcode{basic_simd_mask}.
\end{itemdescr}

\rSec1[simd.flags]{Load and store flags}

\rSec2[simd.flags.overview]{Class template \tcode{simd_flags} overview}

\begin{codeblock}
template<class... Flags> struct simd_flags {
  // \ref{simd.flags.oper}, \tcode{simd_flags} operators
  template<class... Other>
    friend consteval auto operator|(simd_flags, simd_flags<Other...>);
};
\end{codeblock}

\pnum
\begin{note}
The class template \tcode{simd_flags} acts like an integer bit-flag for types.
\end{note}

\pnum\constraints
Every type in \tcode{Flags} is one of \tcode{\convertflag},
\tcode{\alignedflag}, or \tcode{\overalignedflag<N>}.

\rSec2[simd.flags.oper]{\tcode{simd_flags} operators}

\begin{itemdecl}
template<class... Other>
  friend consteval auto operator|(simd_flags a, simd_flags<Other...> b);
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A default-initialized object of type \tcode{simd_flags<Flags2...>} where
  every type in pack \tcode{Flags2} is present either in pack \tcode{Flags} or
  pack \tcode{Other} and every type in packs \tcode{Flags} and \tcode{Other} is
  present in \tcode{Flags2}.
  If the packs \tcode{Flags} and \tcode{Other} contain two
  different specializations \tcode{\overalignedflag<N1>} and
  \tcode{\overalignedflag<N2>}, \tcode{Flags2} is not required to contain the
  specialization \tcode{\overalignedflag<std\colcol{}min(N1, N2)>}.
\end{itemdescr}

\rSec1[simd.class]{Class template \tcode{basic_simd}}

\rSec2[simd.overview]{Class template \tcode{basic_simd} overview}

\begin{codeblock}
template<class T, class Abi> class basic_simd {
public:
  using value_type = T;
  using mask_type = basic_simd_mask<sizeof(T), Abi>;
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\simdsizev@<T, Abi>> size {};

  constexpr basic_simd() noexcept = default;

  // \ref{simd.ctor}, \tcode{basic_simd} constructors
  template<class U> constexpr basic_simd(U&& value) noexcept;
  template<class U, class UAbi>
    constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
  template<class It, class... Flags>
    constexpr explicit basic_simd(It first, simd_flags<Flags...> = {});
  template<class It, class... Flags>
    constexpr explicit basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});

  // \ref{simd.copy}, \tcode{basic_simd} copy functions
  template<class It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> f = {});
  template<class It, class... Flags>
    constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;

  // \ref{simd.subscr}, \tcode{basic_simd} subscript operators
  constexpr value_type operator[](@\simdsizetype@) const;

  // \ref{simd.unary}, \tcode{basic_simd} unary operators
  constexpr basic_simd& operator++() noexcept;
  constexpr basic_simd operator++(int) noexcept;
  constexpr basic_simd& operator--() noexcept;
  constexpr basic_simd operator--(int) noexcept;
  constexpr mask_type operator!() const noexcept;
  constexpr basic_simd operator~() const noexcept;
  constexpr basic_simd operator+() const noexcept;
  constexpr basic_simd operator-() const noexcept;

  // \ref{simd.cassign}, \tcode{basic_simd} compound assignment
  constexpr basic_simd& operator+=(const basic_simd&) noexcept;
  constexpr basic_simd& operator-=(const basic_simd&) noexcept;
  constexpr basic_simd& operator*=(const basic_simd&) noexcept;
  constexpr basic_simd& operator/=(const basic_simd&) noexcept;
  constexpr basic_simd& operator%=(const basic_simd&) noexcept;
  constexpr basic_simd& operator&=(const basic_simd&) noexcept;
  constexpr basic_simd& operator|=(const basic_simd&) noexcept;
  constexpr basic_simd& operator^=(const basic_simd&) noexcept;
  constexpr basic_simd& operator<<=(const basic_simd&) noexcept;
  constexpr basic_simd& operator>>=(const basic_simd&) noexcept;
  constexpr basic_simd& operator<<=(@\simdsizetype@) noexcept;
  constexpr basic_simd& operator>>=(@\simdsizetype@) noexcept;

  // \ref{simd.binary}, \tcode{basic_simd} binary operators
  friend constexpr basic_simd operator+(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator-(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator*(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator/(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator%(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator&(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator|(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator^(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr basic_simd operator<<(const basic_simd&, @\simdsizetype@) noexcept;
  friend constexpr basic_simd operator>>(const basic_simd&, @\simdsizetype@) noexcept;

  // \ref{simd.comparison}, \tcode{basic_simd} compare operators
  friend constexpr mask_type operator==(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator!=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<=(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator>(const basic_simd&, const basic_simd&) noexcept;
  friend constexpr mask_type operator<(const basic_simd&, const basic_simd&) noexcept;

  // \ref{simd.cond}, \tcode{basic_simd} exposition only conditional operators
  friend constexpr basic_simd @\simdselect@(
    const mask_type&, const basic_simd&, const basic_simd&) noexcept;
};
\end{codeblock}

\pnum
Every specialization of \tcode{basic_simd} is a complete type.
The specialization of \tcode{basic_simd<T, Abi>} is
\begin{itemize}
  \item enabled, if \tcode{T} is a vectorizable type, and there exists value \tcode{N} in the range
    \crange{1}{64}, such that \tcode{Abi} is \tcode{\deducet<T, N>},
  \item otherwise, disabled, if \tcode{T} is not a vectorizable type,
  \item otherwise, it is implementation-defined if such a specialization is enabled.
\end{itemize}

If \tcode{basic_simd<T, Abi>} is disabled, the specialization has a
deleted default constructor, deleted destructor, deleted copy constructor, and
deleted copy assignment.
In addition only the \tcode{value_type}, \tcode{abi_type}, and
\tcode{mask_type} members are present.

If \tcode{basic_simd<T, Abi>} is enabled, \tcode{basic_simd<T, Abi>} is
trivially copyable.

\pnum\ConversionsToIntrinsics

\rSec2[simd.ctor]{\tcode{basic_simd} constructors}

\begin{itemdecl}
template<class U> constexpr basic_simd(U&&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{From} denote the type \tcode{remove_cvref_t<U>}.

  \pnum\constraints
  \tcode{From} satisfies \tcode{convertible_to<value_type>}, and either
  \begin{itemize}
    \item \tcode{From} is an arithmetic type and the conversion from
      \tcode{From} to \tcode{value_type} is value-preserving
      (\ref{simd.general}), or

    \item \tcode{From} is not an arithmetic type and does not satisfy
      \tcode{\constexprwrapperlike}, or

    \item \tcode{From} satisfies \tcode{\constexprwrapperlike} (\ref{simd.syn}),
      \tcode{remove_const_t<decltype(From::value)>} is an arithmetic type, and \tcode{From::value}
      is representable by \tcode{value_type}.
  \end{itemize}

  \pnum\effects
  Initializes each element to the value of the argument after conversion to \tcode{value_type}.
\end{itemdescr}

\begin{itemdecl}
template<class U, class UAbi>
  constexpr explicit(@\seebelow@) basic_simd(const basic_simd<U, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, UAbi> == size()} is \tcode{true}.

  \pnum\effects
  Initializes the $i^\text{th}$ element with \tcode{static_cast<T>(x[$i$])} \foralli.

  \pnum\remarks
  %The constructor is \tcode{explicit} if
  The expression inside \tcode{explicit} evaluates to \tcode{true} if either
  \begin{itemize}
    \item the conversion from \tcode{U} to \tcode{value_type} is not
      value-preserving, or

    \item both \tcode{U} and \tcode{value_type} are integral types and the
      integer conversion rank (\iref{conv.rank}) of \tcode{U} is greater than
      the integer conversion rank of \tcode{value_type}, or

    \item both \tcode{U} and \tcode{value_type} are floating-point types and
      the floating-point conversion rank (\iref{conv.rank}) of \tcode{U} is
      greater than the floating-point conversion rank of \tcode{value_type}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \tcode{From}$_i$ denote the type
  \tcode{decltype(gen(integral_constant<\simdsizetype, $i$>()))}.

  \pnum\constraints
  \tcode{From}$_i$ satisfies \tcode{convertible_to<value_type>} \foralli.
  In addition, \foralli, if \tcode{From}$_i$ is an arithmetic type, conversion from
  \tcode{From}$_i$ to \tcode{value_type} is value-preserving.

  \pnum\effects
  Initializes the $i^\text{th}$ element with
  \tcode{static_cast<value_type>(gen(integral_constant<\simdsizetype, i>()))} \foralli.

  \pnum\remarks
    The calls to \tcode{gen} are unsequenced with respect to each other.
    Vectorization-unsafe (\iref{algorithms.parallel.defns}) standard library
    functions may not be invoked by \tcode{gen}.
    \tcode{gen} is invoked exactly once for each $i$.

  \FIXME{Do we need to specify the order in which \code{gen} is called (increasing $i$)? (same
    change for \code{basic_simd_mask}} \NOTE{P3430R0 asks for striking 'unsequenced'.}
\end{itemdescr}

\newcommand\SimdLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is a vectorizable type, and
    \item \tcode{It} models \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{iter_value_t<It>}{value_type}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd, iter_value_t<It>}{iter_value_t<It>}
  \end{itemize}

  \pnum\effects #2
}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr explicit basic_simd(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\range{first}{first + size()} is a valid range.}
    {Initializes the $i^\text{th}$ element with \tcode{static_cast<T>(to_address(first)[$i$])}
    \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr explicit basic_simd(It first, const mask_type& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Initializes the $i^\text{th}$ element with \tcode{mask[$i$] ?
      static_cast<T>(to_address(first)[$i$]) : T()}
    \foralli.}
\end{itemdescr}

\rSec2[simd.copy]{\tcode{basic_simd} copy functions}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\range{first}{first + size()} is a valid range.}
    {Replaces the elements of the \tcode{basic_simd} object such that the $i^\text{th}$ element is
    assigned with \tcode{static_cast<T>(to_address(first)[$i$])} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, const mask_type& mask, simd_flags<Flags...> f = {});
\end{itemdecl}

\begin{itemdescr}
  \SimdLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd} object such that the $i^\text{th}$
    element is replaced with \tcode{static_cast<T>(to_address(first)[$i$])} \forallmaskedi.}
\end{itemdescr}

\newcommand\SimdStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is a vectorizable type, and
    \item \tcode{Out} models \tcode{contiguous_iterator}, and
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\mandates
  \conversionFlagsMandate{value_type}{iter_value_t<Out>}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd, iter_value_t<Out>}{iter_value_t<Out>}
  \end{itemize}

  \pnum\effects #2
}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\range{first}{first + size()} is a valid range.}
    {Copies all \tcode{basic_simd} elements as if \tcode{to_address(first)[$i$] =
    static_cast<iter_value_t<Out>>(operator[]($i$))} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, const mask_type& mask, simd_flags<Flags...> f = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \SimdStoreDescr
    {\validMaskedRange}
    {Copies the selected elements as if \tcode{to_address(first)[$i$] =
    static_cast<iter_value_t<Out>>(operator[]($i$))} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.subscr]{\tcode{basic_simd} subscript operator}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i >= 0 \&\& i < size()} is \tcode{true}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.unary]{\tcode{basic_simd} unary operators}

\pnum
Effects in [simd.unary] are applied as unary element-wise operations.

\begin{itemdecl}
constexpr basic_simd& operator++() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{++a}

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator++(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{a++}

  \pnum\effects
  Increments every element by one.

  \pnum\returns
  A copy of \tcode{*this} before incrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd& operator--() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{--a}

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator--(int) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed[]{a--}

  \pnum\effects
  Decrements every element by one.

  \pnum\returns
  A copy of \tcode{*this} before decrementing.
\end{itemdescr}

\begin{itemdecl}
constexpr mask_type operator!() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{!a}

  \pnum\returns
  A \tcode{basic_simd_mask} object with the $i^\text{th}$ element set to \tcode{!operator[]($i$)}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{\~{}a}

  \pnum\returns
  A \tcode{basic_simd} object with the $i^\text{th}$ element set to \tcode{\~{}operator[]($i$)}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator+() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{+a}

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd operator-() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\ConstraintUnaryOperatorWellFormed{-a}

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to
  \tcode{-operator[]($i$)} \foralli.
\end{itemdescr}

\rSec2[simd.cassign]{\tcode{basic_simd} compound assignment}

\begin{itemdecl}
constexpr basic_simd& operator+=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator-=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator*=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator/=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator%=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator&=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator|=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator^=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator<<=(const basic_simd& rhs) noexcept;
constexpr basic_simd& operator>>=(const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\effects
  These operators apply the indicated operator to \tcode{*this} and \tcode{rhs} as an element-wise
  operation.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
constexpr basic_simd& operator<<=(@\simdsizetype@ n) noexcept;
constexpr basic_simd& operator>>=(@\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\constraints
  \tcode{requires (value_type a, \simdsizetype{} b) \{ a \op{} b; \}} is \tcode{true}.

  \pnum\effects
  Equivalent to: \tcode{return operator \textit{op} (*this, basic_simd(n));}
\end{itemdescr}

\rSec1[simd.nonmembers]{\tcode{basic_simd} non-member operations}

\rSec2[simd.binary]{\tcode{basic_simd} binary operators}

\begin{itemdecl}
friend constexpr basic_simd operator+(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator-(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator*(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator/(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator%(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator&(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator|(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator^(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator<<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd} object initialized with the results of applying \op{} to \tcode{lhs} and
  \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd operator<<(const basic_simd& v, @\simdsizetype@ n) noexcept;
friend constexpr basic_simd operator>>(const basic_simd& v, @\simdsizetype@ n) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\constraints
  \tcode{requires (value_type a, \simdsizetype{} b) \{ a \op{} b; \}} is \tcode{true}.

  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element is initialized to the result of
  applying \op{} to \tcode{v[$i$]} and \tcode{n} \foralli.
\end{itemdescr}

\rSec2[simd.comparison]{\tcode{basic_simd} compare operators}

\begin{itemdecl}
friend constexpr mask_type operator==(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator!=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<=(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator>(const basic_simd& lhs, const basic_simd& rhs) noexcept;
friend constexpr mask_type operator<(const basic_simd& lhs, const basic_simd& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \textit{op} be the operator.

  \pnum\ConstraintOperatorTWellFormed

  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying \op{} to \tcode{lhs} and
  \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.cond]{\tcode{basic_simd} exposition only conditional operators}

\begin{itemdecl}
friend constexpr basic_simd
@\simdselect@(const mask_type& mask, const basic_simd& a, const basic_simd& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$] :
  b[$i$]} \foralli.
\end{itemdescr}

\rSec2[simd.reductions]{\tcode{basic_simd} reductions}

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation = plus<>>
  constexpr T reduce(const basic_simd<T, Abi>& x, BinaryOperation binary_op = {});
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{BinaryOperation} models \tcode{\reductionoperation<T>}.

  \pnum\expects
  \tcode{binary_op} does not modify \tcode{x}.

  \pnum\returns
  \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, simd<T, 1>(x[0]), $\ldots$, simd<T, 1>(x[x.size() - 1])[0]}
  (\iref{numerics.defns}).

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi, class BinaryOperation = plus<>>
  constexpr T reduce(
    const basic_simd<T, Abi>& x, const typename basic_simd<T, Abi>::mask_type& mask,
    BinaryOperation binary_op = {}, type_identity_t<T> identity_element = @\seebelow@);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \begin{itemize}
    \item \tcode{BinaryOperation} models \tcode{\reductionoperation<T>}.

    \item An argument for \tcode{identity_element} is provided for the invocation, unless
      \tcode{BinaryOperation} is one of \code{plus<>}, \code{multiplies<>}, \code{bit_and<>},
      \code{bit_or<>}, or \code{bit_xor<>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item \tcode{binary_op} does not modify \tcode{x}.

    \item For all finite values \tcode{y} representable by \tcode{T}, the results of
      \tcode{y == binary_op(simd<T, 1>(identity_element), simd<T, 1>(y))[0]} and
      \tcode{y == binary_op(simd<T, 1>(y), simd<T, 1>(identity_element))[0]} are \tcode{true}.
  \end{itemize}

  \pnum\returns
  If \tcode{none_of(mask)} is \tcode{true}, returns \tcode{identity_element}.
  Otherwise, returns \tcode{\placeholdernc{GENERALIZED_SUM}(binary_op, simd<T, 1>(x[$k_0$]),
  $\ldots$, simd<T, 1>(x[$k_n$]))[0]} where $k_0, \ldots, k_n$ are the selected indices of
  \tcode{mask}.

  \pnum\throws
  Any exception thrown from \tcode{binary_op}.

  \pnum\remarks
  The default argument for \code{identity_element} is equal to
  \begin{itemize}
    \item \tcode{T()} if \code{BinaryOperation} is \code{plus<>},
    \item \tcode{T(1)} if \code{BinaryOperation} is \code{multiplies<>},
    \item \tcode{T(\~{}T())} if \code{BinaryOperation} is \code{bit_and<>},
    \item \tcode{T()} if \code{BinaryOperation} is \code{bit_or<>}, or
    \item \tcode{T()} if \code{BinaryOperation} is \code{bit_xor<>}.
  \end{itemize}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_min(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$i$] < x[$j$]} is \tcode{false}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_min(
    const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)} is \tcode{true}, returns \tcode{numeric_limits<T>::max()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$i$] <
  x[$j$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi> constexpr T reduce_max(const basic_simd<T, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The value of an element \tcode{x[$j$]} for which \tcode{x[$j$] < x[$i$]} is \tcode{false}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr T reduce_max(
    const basic_simd<T, Abi>&, const typename basic_simd<T, Abi>::mask_type&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  If \tcode{none_of(mask)} is \tcode{true}, returns \tcode{numeric_limits<V::value_type>::lowest()}.
  Otherwise, returns the value of a selected element \tcode{x[$j$]} for which \tcode{x[$j$] <
  x[$i$]} is \tcode{false} \forallmaskedi.
\end{itemdescr}

\rSec2[simd.creation]{\tcode{basic_simd} and \tcode{basic_simd_mask} creation}

\begin{itemdecl}
template<class T, class Abi>
  constexpr auto simd_split(const basic_simd<typename T::value_type, Abi>& x) noexcept;
template<class T, class Abi>
  constexpr auto simd_split(const basic_simd_mask<@\maskelementsize@<T>, Abi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  % probably not necessary/helpful:
  %\pnum\mandates \tcode{T::size() <= \simdsizev<V::value_type, Abi>}.

  \pnum\constraints
  \begin{itemize}
    \item For the first overload \tcode{T} is an enabled specialization of \tcode{basic_simd}. If
      \tcode{basic_simd<typename T\colcol{}value_type, Abi>\colcol{}size() \% T\colcol{}size()} is
      not \tcode{0} then \tcode{resize_simd_t<basic_simd<typename T\colcol{}value_type,
      Abi>\colcol{}size() \% T\colcol{}size(), T>} is valid and denotes a type.

    \item For the second overload \tcode{T} is an enabled specialization of \tcode{basic_simd_mask}.
      If \tcode{basic_simd_mask<\maskelementsize<T>, Abi>\colcol{}size() \% T\colcol{}size()} is not
      \tcode{0} then \tcode{resize_simd_t<basic_simd_mask<\MayBreak{}\maskelementsize<T>,
      Abi>\colcol{}size() \% T\colcol{}size(), T>} is valid and denotes a type.
  \end{itemize}

  \pnum Let $N$ be \tcode{x.size() / T::size()}.

    \pnum\returns
    \begin{itemize}
      \item If \tcode{x.size() \% T::size() == 0} is \tcode{true}, an \tcode{array<T, $N$>} with
        the $i^\text{th}$ \simd or \mask element of the $j^\text{th}$ \tcode{array}
        element initialized to the value of the element in \tcode{x} with index
        \tcode{$i$ + $j$ * T::size()}.

      \item Otherwise, a \tcode{tuple} of $N$ objects of type \tcode{T} and one
        object of type \tcode{resize_simd_t<x.size() \% T::size(), T>}.
        The $i^\text{th}$ \simd or \mask element of the $j^\text{th}$
        \tcode{tuple} element of type \tcode{T} is initialized to the value of
        the element in \tcode{x} with index \tcode{$i$ + $j$ * T::size()}.
        The $i^\text{th}$ \simd or \mask element of the $N^\text{th}$
        \tcode{tuple} element is initialized to the value of the element in
        \tcode{x} with index \tcode{$i$ + $N$ * T::size()}.
    \end{itemize}
  \end{itemdescr}

\begin{itemdecl}
template<class T, class... Abis>
  constexpr simd<T, (basic_simd<T, Abis>::size() + ...)>
    simd_cat(const basic_simd<T, Abis>&... xs) noexcept;
template<size_t Bytes, class... Abis>
  constexpr simd_mask<@\deducet@<@\integerfrom@<Bytes>, (basic_simd_mask<Bytes, Abis>::size() + ...)>
    simd_cat(const basic_simd_mask<Bytes, Abis>&... xs) noexcept;

\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \begin{itemize}
    \item For the first overload \tcode{simd<T, (basic_simd<T, Abis>\colcol{}size() + ...)>} is enabled.

    \item For the second overload \tcode{simd_mask<\deducet<\integerfrom<Bytes>,
      (basic_simd_mask<Bytes, Abis>\colcol{}size() + ...)>} is enabled.
  \end{itemize}

  \pnum\returns
  A data-parallel object initialized with the concatenated values in the \tcode{xs} pack of
  data-parallel objects: The $i^\text{th}$ \tcode{basic_simd}/\tcode{basic_simd_mask} element of the
  $j^\text{th}$ parameter in the \tcode{xs} pack is copied to the return value's element with index
  $i$ + the sum of the width of the first $j$ parameters in the \tcode{xs} pack.
\end{itemdescr}

\rSec2[simd.alg]{Algorithms}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> min(const basic_simd<T, Abi>& a,
                                   const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{min(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> max(const basic_simd<T, Abi>& a,
                                   const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\returns
  The result of the element-wise application of \tcode{max(a[$i$], b[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr pair<basic_simd<T, Abi>, basic_simd<T, Abi>>
  minmax(const basic_simd<T, Abi>& a, const basic_simd<T, Abi>& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Equivalent to: \tcode{return pair\{min(a, b), max(a, b)\};}
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> clamp(
    const basic_simd<T, Abi>& v, const basic_simd<T, Abi>& lo, const basic_simd<T, Abi>& hi);
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{T} models \tcode{totally_ordered}.

  \pnum\expects
  No element in \tcode{lo} shall be greater than the corresponding element in \tcode{hi}.

  \pnum\returns
  The result of element-wise application of \tcode{clamp(v[$i$], lo[$i$], hi[$i$])} \foralli.
\end{itemdescr}

\begin{itemdecl}
  template<class T, class U>
    constexpr auto simd_select(bool c, const T& a, const U& b)
    -> remove_cvref_t<decltype(c ? a : b)>;
\end{itemdecl}

\begin{itemdescr}
    \pnum\effects
    Equivalent to: \tcode{return c ? a : b;}
\end{itemdescr}

\begin{itemdecl}
  template<size_t Bytes, class Abi, class T, class U>
    constexpr auto simd_select(const basic_simd_mask<Bytes, Abi>& c, const T& a, const U& b)
    noexcept -> decltype(@\simdselect@(c, a, b));
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Equivalent to:
  \begin{codeblock}
return @\simdselect@(c, a, b);
  \end{codeblock}
  where \tcode{\simdselect} is found by argument-dependent lookup \iref{basic.lookup.argdep}
  contrary to \iref{contents}.
  \FIXME{Should this exception be listed in \iref{contents} instead?}
\end{itemdescr}

\rSec2[simd.math]{Mathematical functions}

\begin{itemdecl}
template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<int, @\deducedsimd@<V>> ilogb(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> ldexp(const V& x, const
rebind_simd_t<int, @\deducedsimd@<V>>& exp);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> scalbn(const V& x, const
rebind_simd_t<int, @\deducedsimd@<V>>& n);
template<@\mathfloatingpoint@ V>
  constexpr @\deducedsimd@<V> scalbln(const V& x, const rebind_simd_t<long int, @\deducedsimd@<V>>& n);
template<signed_integral T, class Abi>
  constexpr basic_simd<T, Abi> abs(const basic_simd<T, Abi>& j);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> abs(const V& j);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> fabs(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> ceil(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> floor(const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> nearbyint(const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> rint(const V& x);
template<@\mathfloatingpoint@ V> rebind_simd_t<long int, @\deducedsimd@<V>> lrint(const V& x);
template<@\mathfloatingpoint@ V> rebind_simd_t<long long int, @\deducedsimd@<V>> llrint(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> round(const V& x);
template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<long int, @\deducedsimd@<V>> lround(const V& x);
template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<long long int, @\deducedsimd@<V>> llround(const V& x);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> fmod(const V0& x, const V1& y);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> trunc(const V& x);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> remainder(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> copysign(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> nextafter(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> fdim(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> fmax(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> fmin(const V0& x, const V1& y);
template<class V0, class V1, class V2>
  constexpr @\mathcommonsimd@<V0, V1, V2> fma(const V0& x, const V1& y, const V2& z);
template<@\mathfloatingpoint@ V> constexpr rebind_simd_t<int, @\deducedsimd@<V>> fpclassify(const V& x);
template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isfinite(const V& x);
template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isinf(const V& x);
template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isnan(const V& x);
template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type isnormal(const V& x);
template<@\mathfloatingpoint@ V> constexpr typename @\deducedsimd@<V>::mask_type signbit(const V& x);
template<class V0, class V1>
  constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isgreater(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isgreaterequal(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isless(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr typename @\mathcommonsimd@<V0, V1>::mask_type islessequal(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr typename @\mathcommonsimd@<V0, V1>::mask_type islessgreater(const V0& x, const V1& y);
template<class V0, class V1>
  constexpr typename @\mathcommonsimd@<V0, V1>::mask_type isunordered(const V0& x, const V1& y);
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{Ret} denote the return type of the specialization of a function template with the name
  \textit{math-func}.
  Let \textit{math-func-simd} denote:
  \begin{codeblock}
template<class... Args>
Ret @\textit{math-func-simd}@(Args... args) {
  return Ret([&](@\simdsizetype@ i) {
      @\textit{math-func}@(@\makecompatiblesimdt@<Ret, Args>(args)[i]...);
  });
}
  \end{codeblock}

  \pnum\returns
  A value \tcode{ret} of type \tcode{Ret}, that is element-wise equal to the result of calling
  \textit{math-func-simd} with the arguments of the above functions.
  If in an invocation of a scalar overload of \textit{math-func} for index \tcode{i} in
  \textit{math-func-simd} a domain, pole, or range error would occur, the value of \tcode{ret[i]} is
  unspecified.

  \pnum\remarks
  It is unspecified whether \tcode{errno} (\iref{errno}) is accessed.
\end{itemdescr}

\begin{itemdecl}
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> acos(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> asin(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> atan(const V& x);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> atan2(const V0& y, const V1& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> cos(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> sin(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> tan(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> acosh(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> asinh(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> atanh(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> cosh(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> sinh(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> tanh(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> exp(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> exp2(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> expm1(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log10(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log1p(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> log2(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> logb(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> cbrt(const V& x);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> hypot(const V0& x, const V1& y);
template<class V0, class V1, class V2>
  constexpr @\mathcommonsimd@<V0, V1, V2> hypot(const V0& x, const V1& y, const V2& z);
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> pow(const V0& x, const V1& y);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> sqrt(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> erf(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> erfc(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> lgamma(const V& x);
template<@\mathfloatingpoint@ V> constexpr @\deducedsimd@<V> tgamma(const V& x);
template<class V0, class V1, class V2>
  constexpr @\mathcommonsimd@<V0, V1, V2> lerp(const V0& a, const V1& b, const V2& t) noexcept;
template<@\mathfloatingpoint@ V>
  @\deducedsimd@<V> assoc_laguerre(const rebind_simd_t<unsigned, @\deducedsimd@<V>>& n, const
    rebind_simd_t<unsigned, @\deducedsimd@<V>>& m,
                   const V& x);
template<@\mathfloatingpoint@ V>
  @\deducedsimd@<V> assoc_legendre(const rebind_simd_t<unsigned, @\deducedsimd@<V>>& l, const
    rebind_simd_t<unsigned, @\deducedsimd@<V>>& m,
                   const V& x);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> beta(const V0& x, const V1& y);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> comp_ellint_1(const V& k);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> comp_ellint_2(const V& k);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> comp_ellint_3(const V0& k, const V1& nu);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> cyl_bessel_i(const V0& nu, const V1& x);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> cyl_bessel_j(const V0& nu, const V1& x);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> cyl_bessel_k(const V0& nu, const V1& x);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> cyl_neumann(const V0& nu, const V1& x);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> ellint_1(const V0& k, const V1& phi);
template<class V0, class V1>
  @\mathcommonsimd@<V0, V1> ellint_2(const V0& k, const V1& phi);
template<class V0, class V1, class V2>
  @\mathcommonsimd@<V0, V1, V2> ellint_3(const V0& k, const V1& nu, const V2& phi);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> expint(const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> hermite(const rebind_simd_t<unsigned,
@\deducedsimd@<V>>& n, const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> laguerre(const rebind_simd_t<unsigned,
@\deducedsimd@<V>>& n, const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> legendre(const rebind_simd_t<unsigned,
@\deducedsimd@<V>>& l, const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> riemann_zeta(const V& x);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> sph_bessel(const rebind_simd_t<unsigned,
@\deducedsimd@<V>>& n, const V& x);
template<@\mathfloatingpoint@ V>
  @\deducedsimd@<V> sph_legendre(const rebind_simd_t<unsigned, @\deducedsimd@<V>>& l,
                                 const rebind_simd_t<unsigned, @\deducedsimd@<V>>& m,
                                 const V& theta);
template<@\mathfloatingpoint@ V> @\deducedsimd@<V> sph_neumann(const rebind_simd_t<unsigned,
@\deducedsimd@<V>>& n, const V& x);
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{Ret} denote the return type of the specialization of a function template with the name
  \textit{math-func}.
  Let \textit{math-func-simd} denote:
  \begin{codeblock}
template<class... Args>
Ret @\textit{math-func-simd}@(Args... args) {
  return Ret([&](@\simdsizetype@ i) {
      @\textit{math-func}@(@\makecompatiblesimdt@<Ret, Args>(args)[i]...);
  });
}
  \end{codeblock}

  \pnum\returns
  A value \tcode{ret} of type \tcode{Ret}, that is element-wise approximately equal to the result of
  calling \textit{math-func-simd} with the arguments of the above functions.
  If in an invocation of a scalar overload of \textit{math-func} for index \tcode{i} in
  \textit{math-func-simd} a domain, pole, or range error would occur, the value of \tcode{ret[i]} is
  unspecified.

  \pnum\remarks
  It is unspecified whether \tcode{errno} (\iref{errno}) is accessed.
\end{itemdescr}

\begin{itemdecl}
template<@\mathfloatingpoint@ V>
  constexpr @\deducedsimd@<V> frexp(const V& value, rebind_simd_t<int, @\deducedsimd@<V>>* exp);
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{Ret} be \tcode{\deducedsimd<V>}.
  Let \textit{frexp-simd} denote:
  \begin{codeblock}
template<class V>
  pair<Ret, rebind_simd_t<int, Ret>> @\textit{frexp-simd}@(const V& x) {
    int r1[Ret::size()];
    Ret r0([&](@\simdsizetype@ i) {
      frexp(@\makecompatiblesimdt@<Ret, V>(x)[i], &r1[i]);
    });
    return {r0, rebind_simd_t<int, Ret>(r1)};
  }
  \end{codeblock}
  Let \tcode{ret} be a value of type \tcode{pair<Ret, rebind_simd_t<int, Ret>>} that is the same
  value as the result of calling \textit{frexp-simd}\tcode{(x)}.

  \pnum\effects
  Sets \tcode{*exp} to \tcode{ret.second}.

  \pnum\returns \tcode{ret.first}.
\end{itemdescr}

\begin{itemdecl}
template<class V0, class V1>
  constexpr @\mathcommonsimd@<V0, V1> remquo(const V0& x, const V1& y,
                                              rebind_simd_t<int, @\mathcommonsimd@<V0, V1>>* quo);
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{Ret} be \tcode{\mathcommonsimd<V0, V1>}.
  Let \textit{remquo-simd} denote:
  \begin{codeblock}
template<class V0, class V1>
  pair<Ret, rebind_simd_t<int, Ret>> @\textit{remquo-simd}@(const V0& x, const V1& y) {
    int r1[Ret::size()];
    Ret r0([&](@\simdsizetype@ i) {
      remquo(@\makecompatiblesimdt@<Ret, V0>(x)[i],
             @\makecompatiblesimdt@<Ret, V1>(y)[i], &r1[i]);
    });
    return {r0, rebind_simd_t<int, Ret>(r1)};
  }
  \end{codeblock}
  Let \tcode{ret} be a value of type \tcode{pair<Ret, rebind_simd_t<int, Ret>>} that is the same
  value as the result of calling \textit{remquo-simd}\tcode{(x, y)}.
  If in an invocation of a scalar overload of \tcode{remquo} for index \tcode{i} in
  \textit{remquo-simd} a domain, pole, or range error would occur, the value of \tcode{ret[i]} is
  unspecified.

  \pnum\effects
  Sets \tcode{*quo} to \tcode{ret.second}.

  \pnum\returns \tcode{ret.first}.

  \pnum\remarks
  It is unspecified whether \tcode{errno} (\iref{errno}) is accessed.
\end{itemdescr}

\begin{itemdecl}
template<class T, class Abi>
  constexpr basic_simd<T, Abi> modf(const type_identity_t<basic_simd<T, Abi>>& value,
                                    basic_simd<T, Abi>* iptr);
\end{itemdecl}
\begin{itemdescr}
  \pnum
  Let \tcode{V} be \tcode{basic_simd<T, Abi>}.
  Let \textit{modf-simd} denote:
  \begin{codeblock}
pair<V, V> @\textit{modf-simd}@(const V& x) {
  T r1[Ret::size()];
  V r0([&](@\simdsizetype@ i) {
    modf(V(x)[i], &r1[i]);
  });
  return {r0, V(r1)};
}
  \end{codeblock}
  Let \tcode{ret} be a value of type \tcode{pair<V, V>} that is the same value as the result of
  calling \textit{modf-simd}\tcode{(value)}.

  \pnum\effects
  Sets \tcode{*iptr} to \tcode{ret.second}.

  \pnum\returns \tcode{ret.first}.
\end{itemdescr}

\rSec1[simd.mask.class]{Class template \tcode{basic_simd_mask}}

\rSec2[simd.mask.overview]{Class template \tcode{basic_simd_mask} overview}

\begin{codeblock}
template<size_t Bytes, class Abi> class basic_simd_mask {
public:
  using value_type = bool;
  using abi_type = Abi;

  static constexpr integral_constant<@\simdsizetype@, @\simdsizev@<@\integerfrom@<Bytes>, Abi>>
    size {};

  constexpr basic_simd_mask() noexcept = default;

  // \ref{simd.mask.ctor}, \tcode{basic_simd_mask} constructors
  constexpr explicit basic_simd_mask(value_type) noexcept;
  template<size_t UBytes, class UAbi>
    constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>&) noexcept;
  template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
  template<class It, class... Flags>
    constexpr basic_simd_mask(It first, Flags = {});
  template<class It, class... Flags>
    constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});

  // \ref{simd.mask.copy}, \tcode{basic_simd_mask} copy functions
  template<class It, class... Flags>
    constexpr void copy_from(It first, simd_flags<Flags...> = {});
  template<class It, class... Flags>
    constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
  template<class Out, class... Flags>
    constexpr void copy_to(Out first, const basic_simd_mask& mask,
                           simd_flags<Flags...> = {}) const;

  // \ref{simd.mask.subscr}, \tcode{basic_simd_mask} subscript operators
  constexpr value_type operator[](@\simdsizetype@) const;

  // \ref{simd.mask.unary}, \tcode{basic_simd_mask} unary operators
  constexpr basic_simd_mask operator!() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator+() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator-() const noexcept;
  constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator~() const noexcept;

  // \ref{simd.mask.conv}, \tcode{basic_simd_mask} conversion operators
  template<class U, class A>
    constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;

  // \ref{simd.mask.cassign}, \tcode{basic_simd_mask} compound assignment
  constexpr basic_simd_mask& operator&=(const basic_simd_mask&) noexcept;
  constexpr basic_simd_mask& operator|=(const basic_simd_mask&) noexcept;
  constexpr basic_simd_mask& operator^=(const basic_simd_mask&) noexcept;

  // \ref{simd.mask.binary}, \tcode{basic_simd_mask} binary operators
  friend constexpr basic_simd_mask
    operator&&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator||(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator&(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator|(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator^(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.comparison}, \tcode{basic_simd_mask} comparisons
  friend constexpr basic_simd_mask
    operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator>=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator<=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator>(const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask
    operator<(const basic_simd_mask&, const basic_simd_mask&) noexcept;

  // \ref{simd.mask.cond}, \tcode{basic_simd_mask} exposition only conditional operators
  friend constexpr basic_simd_mask @\simdselect@(
    const basic_simd_mask&, const basic_simd_mask&, const basic_simd_mask&) noexcept;
  friend constexpr basic_simd_mask @\simdselect@(
    const basic_simd_mask&, same_as<bool> auto, same_as<bool> auto) noexcept;
  template<class T0, class T1>
    friend constexpr simd<@\seebelow@, size()>
      @\simdselect@(const basic_simd_mask&, const T0&, const T1&) noexcept;
};
\end{codeblock}

\pnum
Every specialization of \tcode{basic_simd_mask} is a complete type.
The specialization of \tcode{basic_simd_mask<Bytes, Abi>} is:
\begin{itemize}
  \item disabled, if there is no vectorizable type \tcode{T} such that \tcode{Bytes} is
    equal to \tcode{sizeof(T)},
  \item otherwise, enabled, if there exists a vectorizable type \tcode{T} and a value \tcode{N} in
    the range \crange{1}{64} such that \tcode{Bytes} is equal to \tcode{sizeof(T)} and \tcode{Abi}
    is \tcode{\deducet<T, N>},
  \item otherwise, it is implementation-defined if such a specialization is enabled.
\end{itemize}

If \tcode{basic_simd_mask<Bytes, Abi>} is disabled, the specialization has a deleted
default constructor, deleted destructor, deleted copy constructor, and deleted copy assignment.
In addition only the \tcode{value_type} and \tcode{abi_type} members are present.

If \tcode{basic_simd_mask<Bytes, Abi>} is enabled, \tcode{basic_simd_mask<Bytes, Abi>} is
trivially copyable.

\pnum\ConversionsToIntrinsics

\rSec2[simd.mask.ctor]{\tcode{basic_simd_mask} constructors}

\begin{itemdecl}
constexpr explicit basic_simd_mask(value_type x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\effects
  Initializes each element with \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
template<size_t UBytes, class UAbi>
  constexpr explicit basic_simd_mask(const basic_simd_mask<UBytes, UAbi>& x) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{basic_simd_mask<UBytes, UAbi>::size() == size()} is \tcode{true}.

  \pnum\effects
  Initializes the $i^\text{th}$ element with \tcode{x[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class G> constexpr explicit basic_simd_mask(G&& gen) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  The expression \tcode{gen(integral_constant<\simdsizetype, i>())} is well-formed and its type is
  \tcode{bool} \foralli.

  \pnum\effects
  Initializes the $i^\text{th}$ element with
  \tcode{gen(integral_constant<\simdsizetype, i>())} \foralli.

  \pnum\remarks
    The calls to \tcode{gen} are unsequenced with respect to each other.
    Vectorization-unsafe (\iref{algorithms.parallel.defns}) standard library
    functions may not be invoked by \tcode{gen}.
    \tcode{gen} is invoked exactly once for each $i$.
\end{itemdescr}

\newcommand\MaskLoadDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<It>} is of type \tcode{bool}, and
    \item \tcode{It} models \tcode{contiguous_iterator}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr basic_simd_mask(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\range{first}{first + size()} is a valid range.}
    {Initializes the $i^\text{th}$ element with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr basic_simd_mask(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Initializes the $i^\text{th}$ element with \tcode{mask[$i$] ? first[$i$] : false} \foralli.}
\end{itemdescr}

\rSec2[simd.mask.copy]{\tcode{basic_simd_mask} copy functions}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
  {\range{first}{first + size()} is a valid range.}
  {Replaces the elements of the \tcode{basic_simd_mask} object such that the $i^\text{th}$ element
  is replaced with \tcode{first[$i$]} \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class It, class... Flags>
  constexpr void copy_from(It first, const basic_simd_mask& mask, simd_flags<Flags...> = {});
\end{itemdecl}

\begin{itemdescr}
  \MaskLoadDescr
    {\validMaskedRange}
    {Replaces the selected elements of the \tcode{basic_simd_mask} object such that the
    $i^\text{th}$ element is replaced with \tcode{first[$i$]} \forallmaskedi.}
\end{itemdescr}

\newcommand\MaskStoreDescr[2]{
  \pnum\constraints
  \begin{itemize}
    \item \tcode{iter_value_t<Out>} is of type \tcode{bool}, and
    \item \tcode{Out} models \tcode{contiguous_iterator}, and
    \item \tcode{Out} models \tcode{indirectly_writable<value_type>}.
  \end{itemize}

  \pnum\expects
  \begin{itemize}
    \item #1
    \flagsRequires{basic_simd_mask}{value_type}
  \end{itemize}

  \pnum\effects #2

  \pnum\throws Nothing.
}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
    {\range{first}{first + size()} is a valid range.}
    {Copies all \tcode{basic_simd_mask} elements as if \tcode{first[$i$] = operator[]($i$)}
    \foralli.}
\end{itemdescr}

\begin{itemdecl}
template<class Out, class... Flags>
  constexpr void copy_to(Out first, const basic_simd_mask& mask, simd_flags<Flags...> = {}) const;
\end{itemdecl}

\begin{itemdescr}
  \MaskStoreDescr
  {\validMaskedRange}
  {Copies the selected elements as if \tcode{first[$i$] = operator[]($i$)} \forallmaskedi.}
\end{itemdescr}

\rSec2[simd.mask.subscr]{\tcode{basic_simd_mask} subscript operator}

\begin{itemdecl}
constexpr value_type operator[](@\simdsizetype@ i) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{i >= 0 \&\& i < size()} is \tcode{true}.

  \pnum\returns
  The value of the $i^\text{th}$ element.

  \pnum\throws Nothing.
\end{itemdescr}

\rSec2[simd.mask.unary]{\tcode{basic_simd_mask} unary operators}

\begin{itemdecl}
constexpr basic_simd_mask operator!() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator+() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator-() const noexcept;
constexpr basic_simd<@\integerfrom@<Bytes>, Abi> operator~() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\returns
  A data-parallel object where the $i^\text{th}$ element is initialized to the results of applying
  \op{} to \tcode{operator[]($i$)} \foralli.
\end{itemdescr}

\rSec2[simd.mask.conv]{\tcode{basic_simd_mask} conversion operators}

\begin{itemdecl}
template<class U, class A>
  constexpr explicit(sizeof(U) != Bytes) operator basic_simd<U, A>() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \tcode{\simdsizev<U, A> == \simdsizev<T, Abi>}.

  \pnum\returns
  A data-parallel object where the $i^\text{th}$ element is initialized to
  \tcode{static_cast<U>(operator[]($i$))}.
\end{itemdescr}

\rSec2[simd.mask.cassign]{\tcode{basic_simd_mask} compound assignment}

\begin{itemdecl}
constexpr basic_simd_mask& operator&=(const basic_simd_mask& rhs) noexcept;
constexpr basic_simd_mask& operator|=(const basic_simd_mask& rhs) noexcept;
constexpr basic_simd_mask& operator^=(const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\effects
  These operators apply \op{} to \tcode{*this} and \tcode{rhs} as a binary
  element-wise operation.

  \pnum\returns
  \tcode{*this}.
\end{itemdescr}

\rSec1[simd.mask.nonmembers]{Non-member operations}

\rSec2[simd.mask.binary]{\tcode{basic_simd_mask} binary operators}

\begin{itemdecl}
friend constexpr basic_simd_mask
  operator&&(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator||(const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator& (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator| (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
friend constexpr basic_simd_mask
  operator^ (const basic_simd_mask& lhs, const basic_simd_mask& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying \op{}
  to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.comparison]{\tcode{basic_simd_mask} comparisons}

\begin{itemdecl}
friend constexpr basic_simd_mask
  operator==(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator!=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator>=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator<=(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator>(const basic_simd_mask&, const basic_simd_mask&) noexcept;
friend constexpr basic_simd_mask
  operator<(const basic_simd_mask&, const basic_simd_mask&) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum Let \op{} be the operator.

  \pnum\returns
  A \tcode{basic_simd_mask} object initialized with the results of applying \op{}
  to \tcode{lhs} and \tcode{rhs} as a binary element-wise operation.
\end{itemdescr}

\rSec2[simd.mask.cond]{\tcode{basic_simd_mask} exposition only conditional operators}

\begin{itemdecl}
friend constexpr basic_simd_mask @\simdselect@(
  const basic_simd_mask& mask, const basic_simd_mask& a, const basic_simd_mask& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a[$i$]
  : b[$i$]} \foralli.
\end{itemdescr}

\begin{itemdecl}
friend constexpr basic_simd_mask
@\simdselect@(const basic_simd_mask& mask, same_as<bool> auto a, same_as<bool> auto b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  A \tcode{basic_simd_mask} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a : b}
  \foralli.
\end{itemdescr}

\begin{itemdecl}
template<class T0, class T1>
  friend constexpr simd<@\seebelow@, size()>
    @\simdselect@(const basic_simd_mask& mask, const T0& a, const T1& b) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\constraints
  \begin{itemize}
    \item \tcode{same_as<T0, T1>} is \tcode{true}, and
    \item \tcode{T0} is a vectorizable type, and
    \item \tcode{sizeof(T0) == Bytes}.
  \end{itemize}

  \pnum\returns
  A \tcode{simd<T0, size()>} object where the $i^\text{th}$ element equals \tcode{mask[$i$] ? a :
  b} \foralli.
\end{itemdescr}

\rSec2[simd.mask.reductions]{\tcode{basic_simd_mask} reductions}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool all_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if all boolean elements in \tcode{k} are \tcode{true}, otherwise \tcode{false}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool any_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  \tcode{true} if at least one boolean element in \tcode{k} is \tcode{true}, otherwise
  \tcode{false}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr bool none_of(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns \tcode{!any_of(k)}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_count(const basic_simd_mask<Bytes, Abi>& k) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum\returns
  The number of boolean elements in \tcode{k} that are \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_min_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} is \tcode{true}.

  \pnum\returns
  The lowest element index $i$ where \tcode{k[$i$]} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template<size_t Bytes, class Abi>
  constexpr @\simdsizetype@ reduce_max_index(const basic_simd_mask<Bytes, Abi>& k);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects
  \tcode{any_of(k)} is \tcode{true}.

  \pnum\returns
  The greatest element index $i$ where \tcode{k[$i$]} is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
constexpr bool all_of(same_as<bool> auto x) noexcept;
constexpr bool any_of(same_as<bool> auto x) noexcept;
constexpr @\simdsizetype@ reduce_count(same_as<bool> auto x) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{x}.
\end{itemdescr}

\begin{itemdecl}
constexpr bool none_of(same_as<bool> auto x) noexcept;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \tcode{!x}.
\end{itemdescr}

\begin{itemdecl}
constexpr @\simdsizetype@ reduce_min_index(same_as<bool> auto x);
constexpr @\simdsizetype@ reduce_max_index(same_as<bool> auto x);
\end{itemdecl}

\begin{itemdescr}
  \pnum\expects \tcode{x} is \tcode{true}.

  \pnum\returns \tcode{0}.
\end{itemdescr}

% vim: tw=100 cc=99
