\wgSubsection{Class template \type{datapar}}{datapar}
\wgSubsubsection{Class template \datapar overview}{datapar.overview}
\lstinputlisting[]{datapar.cpp}

\pnum The class template \datapar{}\type{<T, Abi>} is a one-dimensional smart array.
In contrast to \type{valarray} (26.6), the number of elements in the array is determined at compile time, according to the \type{Abi} template parameter.

\pnum The first template argument \type T must be an integral or floating-point fundamental type.
The type \bool is not allowed.

\pnum The second template argument \type{Abi} must be a tag type from the \code{datapar_abi} namespace.

\begin{itemdecl}
static constexpr size_type size();
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns the number of elements stored in objects of the given \datapar[<T, Abi>] type.
\end{itemdescr}

\pnum\realnote Implementations are encouraged to enable \code{static_cast}ing from/to (an) implementation-defined SIMD type(s).
This would add one or more of the following declarations to class \datapar:
\begin{itemdecl}
explicit operator implementation_defined() const;
explicit datapar(const implementation_defined &init);
\end{itemdecl}

\wgSubsubsection{\datapar constructors}{datapar.ctor}
\begin{itemdecl}
datapar() = default;
\end{itemdecl}
\begin{itemdescr}
  \pnum
  \effects
  Constructs an object with all elements initialized to \code{T()}.
  \wgNote{This zero-initializes the object.}
\end{itemdescr}

\begin{itemdecl}
template <class U> datapar(const U &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks This constructor shall not participate in overload resolution unless either:
  \begin{itemize}
    \item \type U is a fundamental arithmetic type and every possible value of type \type U can be represented with type \valuetype,
    \item or \type U is not a fundamental arithmetic type and is implicitly convertible to \valuetype,
    \item or \type U is \intt,
    \item or \type U is \uint and \valuetype is an unsigned integral type.
  \end{itemize}
  \pnum\effects Constructs an object with each element initialized to the value of the argument.
\end{itemdescr}

\begin{itemdecl}
template <class U> datapar(const datapar<U, datapar_abi::fixed_size<size()>> &x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks This constructor shall not participate in overload resolution unless
  \begin{itemize}
    \item \type{abi_type} equals \fixedsizescoped{}\code{<size()>}
    \item and every possible value of \type U can be represented with type \valuetype.
  \end{itemize}
  \pnum\effects Constructs an object where the $i$-th element equals \code{static_cast<T>(x[i])} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class G> datapar(G &&gen);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks This constructor shall not participate in overload resolution unless either \code{gen()} or \code{gen(declval<integral_constant<size_t, 0>>())} are well-formed with a return type of \valuetype.
  \pnum\effects Constructs an object where the $i$-th element is initialized to
  \begin{itemize}
    \item \code{gen()}, if \code{gen()} is well-formed,
    \item otherwise \code{gen(integral_constant<size_t, i>())}.
  \end{itemize}
  \pnum\remarks The order of calls to \code{gen} is unspecified.%
  \comment{Is there an implementation that can make use of this? For users a well-defined order can be useful.}
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> datapar(const U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{static_cast<T>(mem[i])} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> datapar(const U *mem, mask_type k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Constructs an object where the $i$-th element is initialized to \code{k[i] ? static_cast<T>(mem[i]) : 0} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\datapar load functions}{datapar.load}
\begin{itemdecl}
template <class U, class Flags> void copy_from(const U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces the elements of the \datapar object such that the $i$-th element is assigned with \code{static_cast<T>(mem[i])} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by the first argument, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> void copy_from(const U *mem, mask_type k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Replaces all elements of the \datapar object where $k[i]$ is \true such that the $i$-th element is assigned with \code{static_cast<T>(mem[i])} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by the first argument, the behavior is undefined.
  \wgNote{
    Masked loads only access the bytes in memory selected by the \code k argument.
    This prohibits implementations that load the complete vector before blending with the previous values.
  }
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\datapar store functions}{datapar.store}
\begin{itemdecl}
template <class U, class Flags> void copy_to(U *mem, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies all \datapar elements as if \code{mem[i] = static_cast<U>(operator[](i))} \foralli.
  \pnum\remarks If \code{size()} returns a value greater than the number of values pointed to by \code{mem}, the behavior is undefined.
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\begin{itemdecl}
template <class U, class Flags> void copy_to(U *mem, mask_type k, Flags);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Copies each \datapar element $i$ where \code{k[i]} is \true as if \code{mem[i] = static_cast<U>(operator[](i))} \foralli.
  \pnum\remarks If the largest $i$ where \code{k[i]} is \true is greater than the number of values pointed to by \code{mem}, the behavior is undefined.
  \wgNote{
    Masked stores only write to the bytes in memory selected by the \code k argument.
    This prohibits implementations that load, blend, and store the complete vector.
  }
  \pnum\remarks If the \type{Flags} template parameter is of type \type{flags::vector_aligned_tag} and the pointer value is not a multiple of \code{memory_alignment<\datapar, \type U>}, the behavior is undefined.
\end{itemdescr}

\wgSubsubsection{\datapar subscript operators}{datapar.subscr}
\newcommand{\dataparElementReference}{
  \pnum\returns A temporary object with the following properties:
  \begin{itemize}
    \item \remarks The object is neither \textit{DefaultConstructible}, \textit{CopyConstructible}, \textit{MoveConstructible}, \textit{CopyAssignable}, nor \textit{MoveAssignable}.

    \item \remarks Assignment, compound assignment, increment, and decrement operators only participate in overload resolution if
      called in rvalue context and the corresponding operator of type \valuetype is usable.

    \item \effects The assignment, compound assignment, increment, and decrement operators execute the indicated operation on the $i$-th element in the \datapar object.

    \item \effects Conversion to \valuetype returns a copy of the $i$-th element.
  \end{itemize}
}
\begin{itemdecl}
reference operator[](size_type i);
\end{itemdecl}
\begin{itemdescr}
  \dataparElementReference
\end{itemdescr}

\begin{itemdecl}
value_type operator[](size_type) const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A copy of the $i$-th element.
\end{itemdescr}

\wgSubsubsection{\datapar unary operators}{datapar.unary}
\begin{itemdecl}
datapar &operator++();
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Increments every element of \code{*this} by one.
  \pnum\returns An lvalue reference to \code{*this} after incrementing.
  \pnum\remarks Overflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
datapar operator++(int);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Increments every element of \code{*this} by one.
  \pnum\returns A copy of \code{*this} before incrementing.
  \pnum\remarks Overflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
datapar &operator--();
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Decrements every element of \code{*this} by one.
  \pnum\returns An lvalue reference to \code{*this} after decrementing.
  \pnum\remarks Underflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
datapar operator--(int);
\end{itemdecl}
\begin{itemdescr}
  \pnum\effects Decrements every element of \code{*this} by one.
  \pnum\returns A copy of \code{*this} before decrementing.
  \pnum\remarks Underflow semantics follow the same semantics as for \type T.
\end{itemdescr}

\begin{itemdecl}
mask_type operator!() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A mask object with the $i$-th element set to \code{!operator[](i)} \foralli.
\end{itemdescr}

\begin{itemdecl}
datapar operator~() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires The first template argument \type T to \datapar must be an integral type.
  \pnum\returns A \datapar object where each bit is the inverse of the corresponding bit in \code{*this}.
  \pnum\remarks \datapar{}\code{::operator\textasciitilde{}()} shall not participate in overload resolution if \type T is a floating-point type.
\end{itemdescr}

\begin{itemdecl}
datapar operator+() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum \returns A copy of \code{*this}
\end{itemdescr}

\begin{itemdecl}
datapar operator-() const;
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \datapar object where the $i$-th element is initialized to \code{-operator[](i)} \foralli.
\end{itemdescr}

\wgSubsection{\type{datapar} non-member operations}{datapar.nonmembers}

\wgSubsubsection{\datapar binary operators}{datapar.binary}
\begin{itemdecl}
friend datapar operator+ (const datapar &, const datapar &);
friend datapar operator- (const datapar &, const datapar &);
friend datapar operator* (const datapar &, const datapar &);
friend datapar operator/ (const datapar &, const datapar &);
friend datapar operator% (const datapar &, const datapar &);
friend datapar operator& (const datapar &, const datapar &);
friend datapar operator| (const datapar &, const datapar &);
friend datapar operator^ (const datapar &, const datapar &);
friend datapar operator<<(const datapar &, const datapar &);
friend datapar operator>>(const datapar &, const datapar &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks Each of these operators only participate in overload resolution if the indicated operator can be applied to objects of type \type{value_type}.

  \pnum\returns A \datapar object initialized with the results of the component-wise application of the indicated operator.
\end{itemdescr}

\wgSubsubsection{\datapar compound assignment}{datapar.cassign}
\begin{itemdecl}
friend datapar &operator+= (datapar &, const datapar &);
friend datapar &operator-= (datapar &, const datapar &);
friend datapar &operator*= (datapar &, const datapar &);
friend datapar &operator/= (datapar &, const datapar &);
friend datapar &operator%= (datapar &, const datapar &);
friend datapar &operator&= (datapar &, const datapar &);
friend datapar &operator|= (datapar &, const datapar &);
friend datapar &operator^= (datapar &, const datapar &);
friend datapar &operator<<=(datapar &, const datapar &);
friend datapar &operator>>=(datapar &, const datapar &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks Each of these operators only participates in overload resolution if the indicated operator can be applied to objects of type \type{value_type}.
  \pnum\effects Each of these operators performs the indicated operator component-wise on each of the corresponding elements of the arguments.
  \pnum\returns A reference to the first argument.
\end{itemdescr}

\wgSubsubsection{\datapar logical operators}{datapar.logical}
\realnote The omission of logical operators is deliberate.

\wgSubsubsection{\datapar compare operators}{datapar.comparison}
\begin{itemdecl}
friend mask_type operator==(const datapar &, const datapar &);
friend mask_type operator!=(const datapar &, const datapar &);
friend mask_type operator>=(const datapar &, const datapar &);
friend mask_type operator<=(const datapar &, const datapar &);
friend mask_type operator> (const datapar &, const datapar &);
friend mask_type operator< (const datapar &, const datapar &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns A \mask object initialized with the results of the component-wise application of the indicated operator.
\end{itemdescr}

\wgSubsubsection{\datapar reductions}{datapar.reductions}
\begin{itemdecl}
template <class BinaryOperation = std::plus<>, class T, class Abi>
T reduce(const datapar<T, Abi> &x, BinaryOperation binary_op = BinaryOperation());
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \code{\textit{GENERALIZED_SUM}(binary_op, x.data[i], \ldots)} \foralli.
  \pnum\requires \code{binary_op} shall be callable with two arguments of type \type T or two arguments of type \datapar[<T, A1>], where \type{A1} may be different to \type{Abi}.
  \pnum\realnote This overload of \code{reduce} does not require an initial value because \code x is guaranteed to be non-empty.
\end{itemdescr}

\begin{itemdecl}
template <class BinaryOperation = std::plus<>, class M, class V>
typename V::value_type reduce(
    const where_expression<M, V> &x,
    typename V::value_type neutral_element = default_neutral_element,
    BinaryOperation binary_op = BinaryOperation());
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns \code{\textit{GENERALIZED_SUM}(binary_op, x.data[i], \ldots)} \forallmaskedi{x.mask}.
  \pnum\requires \code{binary_op} shall be callable with two arguments of type \type T or two arguments of type \datapar[<T, A1>], where \type{A1} may be different to \type{Abi}.
  \pnum\realnote This overload of \code{reduce} requires a neutral value to enable a parallelized implementation:
  A temporary \datapar object initialized with \code{neutral_element} is conditionally assigned from \code{x.data} using \code{x.mask}.
  Subsequently, the parallelized reduction (without mask) is applied to the temporary object.
\end{itemdescr}

\begin{itemdecl}
template <class T, class A> T hmin(const datapar<T, A> &x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element \code{x[j]} for which \code{x[j] <= x[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class M, class V> T hmin(const where_expression<M, V> &x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element \code{x.data[j]} for which \code{x.mask[j] == true} and \code{x.data[j] <= x.data[i]} \foralli.
  \pnum\remarks If all elements in \code{x.mask} are \false, the return value is \code{numeric_limits<V::value_type>::max()}.
\end{itemdescr}

\begin{itemdecl}
template <class T, class A> T hmax(const datapar<T, A> &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element \code{x[j]} for which \code{x[j] >= x[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class M, class V> T hmax(const where_expression<M, V> &x);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns The value of an element \code{x.data[j]} for which \code{x.mask[j] == true} and \code{x.data[j] >= x.data[i]} \foralli.
  \pnum\remarks If all elements in \code{x.mask} are \false, the return value is \code{numeric_limits<V::value_type>::min()}.
\end{itemdescr}


\wgSubsubsection{\datapar casts}{datapar.casts}
\begin{itemdecl}
template <class T, class U, class... Us>
conditional_t<(T::size() == (U::size() + Us::size()...)), T,
            array<T, (U::size() + Us::size()...) / T::size()>> datapar_cast(U, Us...);
\end{itemdecl}
\begin{itemdescr}
  \pnum\remarks The \code{datapar_cast} function only participates in overload resolution if all of the following hold:
  \begin{itemize}
    \item \code{is_datapar_v<T>}
    \item \code{is_datapar_v<U>}
    \item All types in the template parameter pack \type{Us} are equal to \type U.
    \item \code{U::size() + Us::size()...} is an integral multiple of \code{T::size()}.
  \end{itemize}

  \pnum\returns A \datapar object initialized with the converted values as one object of \type T or an array of \type T.
  All scalar elements \code{x\textsubscript{i}} of the function argument(s) are converted as if
  \code{y\textsubscript{i} = static_cast<typename T::value_type>(x\textsubscript{i})} is executed.
  The resulting \code{y\textsubscript{i}} intialize the return object(s) of type \type T.
  \wgNote{%
    For \code{T::size() == 2 * U::size()} the following holds:
    \code{datapar_cast<T>(x0, x1)[i] == static_cast<typename T::value_type>(array<U, 2>\{x0, x1\}[i / U::size()][i \% U::size()])}.
    For \code{2 * T::size() == U::size()} the following holds:
    \code{datapar_cast<T>(x)[i][j] == static_cast<typename T::value_type>(x[i * T\MayBreak::size() + j])}.
  }
\end{itemdescr}

\wgSubsubsection{\datapar algorithms}{datapar.alg}
\begin{itemdecl}
template <class T, class A>
datapar<T, A> min(const datapar<T, A> &a, const datapar<T, A> &b);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns An object with the $i$-th element initialized with the smaller value of \code{a[i]} and \code{b[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T, class A>
datapar<T, A> max(const datapar<T, A> &, const datapar<T, A> &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns An object with the $i$-th element initialized with the larger value of \code{a[i]} and \code{b[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T, class A>
std::pair<datapar<T, A>, datapar<T, A>> minmax(const datapar<T, A> &,
                                               const datapar<T, A> &);
\end{itemdecl}
\begin{itemdescr}
  \pnum\returns An object with the $i$-th element in the first \type{pair} member initialized with the smaller value of \code{a[i]} and \code{b[i]} \foralli.
  The $i$-th element in the second \type{pair} member is initialized with the larger value of \code{a[i]} and \code{b[i]} \foralli.
\end{itemdescr}

\begin{itemdecl}
template <class T, class A>
datapar<T, A> clamp(const datapar<T, A> &v, const datapar<T, A> &lo,
                    const datapar<T, A> &hi);
\end{itemdecl}
\begin{itemdescr}
  \pnum\requires No element in \code{lo} shall be greater than the corresponding element in \code{hi}.
  \pnum\returns An object with the $i$-th element initialized with \code{lo[i]} if \code{v[i]} is smaller than \code{lo[i]}, \code{hi[i]} if \code{v[i]} is larger than \code{hi[i]}, otherwise \code{v[i]} \foralli.
\end{itemdescr}

\wgSubsubsection{\datapar math library}{datapar.math}
\lstinputlisting[]{math.cpp}

\pnum Each listed function concurrently applies the indicated mathematical function component-wise.
The results per component are not required to be binary equal to the application of the function which is overloaded for the element type.
\comment{Neither the C nor the \CC{} standard say anything about expected error/precision.
It seems returning 0 from all functions is a conforming implementation --- just bad QoI.}

\pnum If \code{abs()} is called with an argument of type \datapar[<X, Abi>] for which \code{is_unsigned<X>::value} is \true, the program is ill-formed.

% vim: tw=0 spell sw=2
